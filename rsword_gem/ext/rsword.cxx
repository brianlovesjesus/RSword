/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY
#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Ruby 1.9.1 has a "memoisation optimisation" when compiling with GCC which
 * breaks using rb_intern as an lvalue, as SWIG does.  We work around this
 * issue for now by disabling this.
 * https://sourceforge.net/tracker/?func=detail&aid=2859614&group_id=1645&atid=101645
 */
#ifdef rb_intern
# undef rb_intern
#endif

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef bind
# undef bind
#endif
#ifdef close
# undef close
#endif
#ifdef connect
# undef connect
#endif


/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif



/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a function in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. 
*/
static VALUE swig_ruby_trackings = Qnil;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a 
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  ID trackings_id = rb_intern( "@__trackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* No, it hasn't.  Create one ourselves */ 
  if ( swig_ruby_trackings == Qnil )
    {
      swig_ruby_trackings = rb_hash_new();
      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
    }

  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  return SWIG2NUM(ptr);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  return SWIG2NUM(object);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* Convert the Ruby number to a Ruby object */
  return NUM2SWIG(reference);
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), "%s", msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, "%s", x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
    {
      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 

/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Ruby extensions.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_NOUEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swift
*/
#ifndef SWIG_DIRECTOR_NOUEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif

#ifdef __cplusplus

#include <string>
#include <iostream>
#include <map>

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)

namespace Swig {
  /* memory handler */
  struct GCItem 
  {
    virtual ~GCItem()
    {
    }

    virtual ruby_owntype get_own() const
    {
      return 0;
    }
  };
  
  struct GCItem_var
  {
    GCItem_var(GCItem *item = 0) : _item(item)
    {
    }

    GCItem_var& operator=(GCItem *item)
    {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }
    
    ~GCItem_var() 
    {
      delete _item;
    }
    
    GCItem * operator->() const
    {
      return _item;
    }
    
  private:
    GCItem *_item;
  };


  template <typename Type>
  struct GCItem_T : GCItem
  {
    GCItem_T(Type *ptr) : _ptr(ptr)
    {
    }
    
    virtual ~GCItem_T() 
    {
      delete _ptr;
    }
    
  private:
    Type *_ptr;
  };

  struct GCItem_Object : GCItem
  {
    GCItem_Object(ruby_owntype own) : _own(own)
    {
    }
    
    virtual ~GCItem_Object() 
    {
    }

    ruby_owntype get_own() const
    {
      return _own;
    }
    
  private:
    ruby_owntype _own;
  };


  template <typename Type>
  struct GCArray_T : GCItem
  {
    GCArray_T(Type *ptr) : _ptr(ptr)
    {
    }
    
    virtual ~GCArray_T() 
    {
      delete[] _ptr;
    }
    
  private:
    Type *_ptr;
  };


  /* body args */
  struct body_args {
    VALUE recv;
    ID id;
    int argc;
    VALUE *argv;
  };
  
  /* Base class for director exceptions */
  class DirectorException {
  protected:
    VALUE swig_error;
    std::string swig_msg;
  protected:
    DirectorException(VALUE error)
      : swig_error(error)
    {
    }
    
    DirectorException(VALUE error, const char* hdr, const char* msg ="") 
      : swig_error(error), swig_msg(hdr) {
      if (strlen(msg)) {
	swig_msg += " ";
	swig_msg += msg;
      }
      if (swig_msg.size()) {
	VALUE str = rb_str_new(swig_msg.data(), swig_msg.size());
	swig_error = rb_exc_new3(error, str);
      } else {
	swig_error = error;
      }
    }
  public:
    VALUE getType() const  { 
      return CLASS_OF(swig_error); 
    }
    VALUE getError() const {
      return swig_error;
    }
    const std::string& getMessage() const 
    {
      return swig_msg;
    }
    
    virtual ~DirectorException() {}
  };
  
  /* unknown exception handler  */

  class UnknownExceptionHandler 
  {
#ifdef SWIG_DIRECTOR_UEH
    static void handler() {
      try {
	throw;
      } catch (DirectorException& e) {
	std::cerr << "SWIG Director exception caught:" << std::endl
		  << e.getMessage() << std::endl;
      } catch (std::exception& e) {
	std::cerr << "std::exception caught: "<< e.what() << std::endl;
      } catch (...) {
	std::cerr << "Unknown exception caught." << std::endl;
      }      
      std::cerr << std::endl
		<< "Ruby interpreter traceback:" << std::endl;
      std::cerr << std::endl;      
      std::cerr << "This exception was caught by the SWIG unexpected exception handler." << std::endl
		<< "Try using %feature(\"director:except\") to avoid reaching this point." << std::endl
		<< std::endl
		<< "Exception is being re-thrown, program will like abort/terminate." << std::endl;
      throw;
    }
    
  public:    
    std::unexpected_handler old;
    UnknownExceptionHandler(std::unexpected_handler nh = handler)
    {
      old = std::set_unexpected(nh);
    }

    ~UnknownExceptionHandler()
    {
      std::set_unexpected(old);
    }
#endif
  };


  /* Type mismatch in the return value from a Ruby method call */
  class DirectorTypeMismatchException : public Swig::DirectorException {
  public:
    DirectorTypeMismatchException(VALUE error, const char *msg="")
      : Swig::DirectorException(error, "SWIG director type mismatch", msg) 
    {
    }

    DirectorTypeMismatchException(const char *msg="")
      : Swig::DirectorException(rb_eTypeError, "SWIG director type mismatch", msg) 
    {
    }

    static void raise(VALUE error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* Any Ruby exception that occurs during a director method call */
  class DirectorMethodException : public Swig::DirectorException {
  public:
    DirectorMethodException(VALUE error) 
      : Swig::DirectorException(error) {
    }

    DirectorMethodException(const char* msg = "") 
      : Swig::DirectorException(rb_eRuntimeError, "SWIG director method error.", msg) {
    }
    
    static void raise(VALUE error)
    {
      throw DirectorMethodException(error);
    }    
  };

  /* Attempted to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public Swig::DirectorException
  {
  public:
    DirectorPureVirtualException(const char* msg = "") 
      : DirectorException(rb_eRuntimeError, "SWIG director pure virtual method called", msg)
    { 
    }

    static void raise(const char *msg) 
    {
      throw DirectorPureVirtualException(msg);
    }
  };

  /* Simple thread abstraction for pthreads on win32 */
#ifdef __THREAD__
# define __PTHREAD__
# if defined(_WIN32) || defined(__WIN32__)
#  define pthread_mutex_lock EnterCriticalSection
#  define pthread_mutex_unlock LeaveCriticalSection
#  define pthread_mutex_t CRITICAL_SECTION
#  define SWIG_MUTEX_INIT(var) var
# else
#  include <pthread.h>
#  define SWIG_MUTEX_INIT(var) var = PTHREAD_MUTEX_INITIALIZER 
# endif
#endif

#ifdef  __PTHREAD__
  struct Guard
  {
    pthread_mutex_t *_mutex;
    
    Guard(pthread_mutex_t &mutex) : _mutex(&mutex)
    {
      pthread_mutex_lock(_mutex);
    }
    
    ~Guard()
    {
      pthread_mutex_unlock(_mutex);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex) 
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped Ruby object */
    VALUE swig_self;
    /* flag indicating whether the object is owned by Ruby or c++ */
    mutable bool swig_disown_flag;

  public:
    /* wrap a Ruby object, optionally taking ownership */
    Director(VALUE self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
    }

    /* return a pointer to the wrapped Ruby object */
    VALUE swig_get_self() const { 
      return swig_self; 
    }

    /* acquire ownership of the wrapped Ruby object (the sense of "disown"
     * is from Ruby) */
    void swig_disown() const { 
      if (!swig_disown_flag) { 
        swig_disown_flag = true;
      } 
    }

  /* ownership management */
  private:
    typedef std::map<void*, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __PTHREAD__
    static pthread_mutex_t swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr)  const
    {
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }
    
    template <typename Type>
    void swig_acquire_ownership(Type *vptr)  const
    {
      if (vptr) {	
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, ruby_owntype own) const
    {
      if (vptr && own) {
	SWIG_GUARD(swig_mutex_own);
	swig_owner[vptr] = new GCItem_Object(own);
      }
    }
    
    ruby_owntype swig_release_ownership(void *vptr) const
    {
      ruby_owntype own = 0;
      if (vptr) {
	SWIG_GUARD(swig_mutex_own);
	swig_ownership_map::iterator iter = swig_owner.find(vptr);
	if (iter != swig_owner.end()) {
	  own = iter->second->get_own();
	  swig_owner.erase(iter);
	}
      }
      return own;
    }
  };
}

#endif /* __cplusplus */



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_MarkupCallback swig_types[0]
#define SWIGTYPE_p_MyMarkup swig_types[1]
#define SWIGTYPE_p_OSISData swig_types[2]
#define SWIGTYPE_p_ParameterMap swig_types[3]
#define SWIGTYPE_p_PyOSISHTMLHREF swig_types[4]
#define SWIGTYPE_p_PyStringMgr swig_types[5]
#define SWIGTYPE_p_PyThMLHTMLHREF swig_types[6]
#define SWIGTYPE_p_RenderCallback swig_types[7]
#define SWIGTYPE_p_ReturnSuccess swig_types[8]
#define SWIGTYPE_p_SWSearcher swig_types[9]
#define SWIGTYPE_p_ThMLData swig_types[10]
#define SWIGTYPE_p___u16 swig_types[11]
#define SWIGTYPE_p___u32 swig_types[12]
#define SWIGTYPE_p_allocator_type swig_types[13]
#define SWIGTYPE_p_char swig_types[14]
#define SWIGTYPE_p_difference_type swig_types[15]
#define SWIGTYPE_p_first_type swig_types[16]
#define SWIGTYPE_p_int swig_types[17]
#define SWIGTYPE_p_key_type swig_types[18]
#define SWIGTYPE_p_long swig_types[19]
#define SWIGTYPE_p_mapped_type swig_types[20]
#define SWIGTYPE_p_p_char swig_types[21]
#define SWIGTYPE_p_p_void swig_types[22]
#define SWIGTYPE_p_second_type swig_types[23]
#define SWIGTYPE_p_size_type swig_types[24]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t swig_types[25]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t swig_types[26]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t swig_types[27]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t swig_types[28]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t swig_types[29]
#define SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t swig_types[30]
#define SWIGTYPE_p_std__allocatorT_sword__DirEntry_t swig_types[31]
#define SWIGTYPE_p_std__allocatorT_sword__SWBuf_t swig_types[32]
#define SWIGTYPE_p_std__lessT_sword__SWBuf_t swig_types[33]
#define SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t swig_types[34]
#define SWIGTYPE_p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t swig_types[35]
#define SWIGTYPE_p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t swig_types[36]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t swig_types[37]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator swig_types[38]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator swig_types[39]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t swig_types[40]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator swig_types[41]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator swig_types[42]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t swig_types[43]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t swig_types[44]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator swig_types[45]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator swig_types[46]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t swig_types[47]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator swig_types[48]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator swig_types[49]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t swig_types[50]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator swig_types[51]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator swig_types[52]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t swig_types[53]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t swig_types[54]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t swig_types[55]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator swig_types[56]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator swig_types[57]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t swig_types[58]
#define SWIGTYPE_p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t swig_types[59]
#define SWIGTYPE_p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t swig_types[60]
#define SWIGTYPE_p_std__multimapT_sword__SWBuf_sword__SWBuf_t swig_types[61]
#define SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t swig_types[62]
#define SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t swig_types[63]
#define SWIGTYPE_p_swig__ConstIterator swig_types[64]
#define SWIGTYPE_p_swig__GC_VALUE swig_types[65]
#define SWIGTYPE_p_swig__Iterator swig_types[66]
#define SWIGTYPE_p_sword__BasicFilterUserData swig_types[67]
#define SWIGTYPE_p_sword__DirEntry swig_types[68]
#define SWIGTYPE_p_sword__EncodingFilterMgr swig_types[69]
#define SWIGTYPE_p_sword__FTPTransport swig_types[70]
#define SWIGTYPE_p_sword__FileDesc swig_types[71]
#define SWIGTYPE_p_sword__FileMgr swig_types[72]
#define SWIGTYPE_p_sword__GBFHTMLHREF swig_types[73]
#define SWIGTYPE_p_sword__InstallMgr swig_types[74]
#define SWIGTYPE_p_sword__InstallSource swig_types[75]
#define SWIGTYPE_p_sword__LZSSCompress swig_types[76]
#define SWIGTYPE_p_sword__ListKey swig_types[77]
#define SWIGTYPE_p_sword__LocaleMgr swig_types[78]
#define SWIGTYPE_p_sword__MarkupFilterMgr swig_types[79]
#define SWIGTYPE_p_sword__OSISHTMLHREF swig_types[80]
#define SWIGTYPE_p_sword__PLAINHTML swig_types[81]
#define SWIGTYPE_p_sword__RawCom swig_types[82]
#define SWIGTYPE_p_sword__RawGenBook swig_types[83]
#define SWIGTYPE_p_sword__RawLD swig_types[84]
#define SWIGTYPE_p_sword__RawLD4 swig_types[85]
#define SWIGTYPE_p_sword__RawStr swig_types[86]
#define SWIGTYPE_p_sword__RawStr4 swig_types[87]
#define SWIGTYPE_p_sword__RawText swig_types[88]
#define SWIGTYPE_p_sword__RawVerse swig_types[89]
#define SWIGTYPE_p_sword__SWBasicFilter swig_types[90]
#define SWIGTYPE_p_sword__SWBuf swig_types[91]
#define SWIGTYPE_p_sword__SWClass swig_types[92]
#define SWIGTYPE_p_sword__SWCom swig_types[93]
#define SWIGTYPE_p_sword__SWCompress swig_types[94]
#define SWIGTYPE_p_sword__SWConfig swig_types[95]
#define SWIGTYPE_p_sword__SWDisplay swig_types[96]
#define SWIGTYPE_p_sword__SWFilter swig_types[97]
#define SWIGTYPE_p_sword__SWFilterMgr swig_types[98]
#define SWIGTYPE_p_sword__SWGenBook swig_types[99]
#define SWIGTYPE_p_sword__SWKey swig_types[100]
#define SWIGTYPE_p_sword__SWLD swig_types[101]
#define SWIGTYPE_p_sword__SWLocale swig_types[102]
#define SWIGTYPE_p_sword__SWLog swig_types[103]
#define SWIGTYPE_p_sword__SWMgr swig_types[104]
#define SWIGTYPE_p_sword__SWModule swig_types[105]
#define SWIGTYPE_p_sword__SWObject swig_types[106]
#define SWIGTYPE_p_sword__SWOptionFilter swig_types[107]
#define SWIGTYPE_p_sword__SWSearchable swig_types[108]
#define SWIGTYPE_p_sword__SWText swig_types[109]
#define SWIGTYPE_p_sword__SWVersion swig_types[110]
#define SWIGTYPE_p_sword__SW_POSITION swig_types[111]
#define SWIGTYPE_p_sword__StatusReporter swig_types[112]
#define SWIGTYPE_p_sword__StringMgr swig_types[113]
#define SWIGTYPE_p_sword__ThMLHTMLHREF swig_types[114]
#define SWIGTYPE_p_sword__TreeKey swig_types[115]
#define SWIGTYPE_p_sword__TreeKeyIdx swig_types[116]
#define SWIGTYPE_p_sword__TreeKey__PositionChangeListener swig_types[117]
#define SWIGTYPE_p_sword__URL swig_types[118]
#define SWIGTYPE_p_sword__UTF8HTML swig_types[119]
#define SWIGTYPE_p_sword__VerseKey swig_types[120]
#define SWIGTYPE_p_sword__VerseMgr swig_types[121]
#define SWIGTYPE_p_sword__VerseMgr__System swig_types[122]
#define SWIGTYPE_p_sword__VerseTreeKey swig_types[123]
#define SWIGTYPE_p_sword__XMLTag swig_types[124]
#define SWIGTYPE_p_sword__ZipCompress swig_types[125]
#define SWIGTYPE_p_sword__abbrev swig_types[126]
#define SWIGTYPE_p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t swig_types[127]
#define SWIGTYPE_p_sword__sbook swig_types[128]
#define SWIGTYPE_p_sword__zCom swig_types[129]
#define SWIGTYPE_p_sword__zLD swig_types[130]
#define SWIGTYPE_p_sword__zStr swig_types[131]
#define SWIGTYPE_p_sword__zText swig_types[132]
#define SWIGTYPE_p_sword__zVerse swig_types[133]
#define SWIGTYPE_p_unsigned_long swig_types[134]
#define SWIGTYPE_p_unsigned_short swig_types[135]
#define SWIGTYPE_p_value_type swig_types[136]
#define SWIGTYPE_p_void swig_types[137]
static swig_type_info *swig_types[139];
static swig_module_info swig_module = {swig_types, 138, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_rsword
#define SWIG_name    "RSword"

static VALUE mSword;

#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIGVERSION 0x020004 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


#include "defs.h"


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


#include "swbuf.h"


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    #if defined(StringValuePtr)
    char *cstr = StringValuePtr(obj); 
    #else
    char *cstr = STR2CSTR(obj);
    #endif
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}





SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:/usr/local/share/swig/2.0.4/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


/*@SWIG:/usr/local/share/swig/2.0.4/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}

SWIGINTERN int
SWIG_AsVal_wchar_t (VALUE obj, wchar_t *val)
{    
  int res = SWIG_AsCharArray(obj, (char *) val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< wchar_t >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}



SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}

SWIGINTERN char sword_SWBuf_charAt2(sword::SWBuf *self,unsigned int pos){
                return self->charAt((unsigned long)pos);
        }

#include <stdexcept>


namespace swig {
  class GC_VALUE {
  protected:
    // Hash of all GC_VALUE's currently in use
    static VALUE _hash;

    VALUE  _obj;

    static ID hash_id;
    static ID   lt_id;
    static ID   gt_id;
    static ID   eq_id;
    static ID   le_id;
    static ID   ge_id;

    static ID  pos_id;
    static ID  neg_id;
    static ID  inv_id;

    static ID  add_id;
    static ID  sub_id;
    static ID  mul_id;
    static ID  div_id;
    static ID  mod_id;

    static ID  and_id;
    static ID   or_id;
    static ID  xor_id;

    static ID  lshift_id;
    static ID  rshift_id;

    struct OpArgs
    {
      VALUE src;
      ID    id;
      int   nargs;
      VALUE target;
    };


  public:
    static void initialize()
    {
      if ( _hash == Qnil ) 
	{ 
	  _hash = rb_hash_new();
	  rb_gc_register_address( &_hash );
	}
    }

    // this function is never called.  Provided for symmetry only.
    static void cleanup()
    {
      rb_gc_unregister_address( &_hash );
    }

    GC_VALUE() : _obj( Qnil )
    {
    }

    GC_VALUE(const GC_VALUE& item) : _obj(item._obj)
    {
      GC_register();
    }
    
    GC_VALUE(VALUE obj) :_obj(obj)
    {
      GC_register();
    }
    
    ~GC_VALUE() 
    {
      GC_unregister();
    }
    
    GC_VALUE & operator=(const GC_VALUE& item) 
    {
      GC_unregister();
      _obj = item._obj;
      GC_register();
      return *this;
    }

    void GC_register()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
      ++n;
      rb_hash_aset( _hash, _obj, INT2NUM(n) );
    }

    void GC_unregister()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      // this test should not be needed but I've noticed some very erratic
      // behavior of none being unregistered in some very rare situations.
      if ( BUILTIN_TYPE(_obj) == T_NONE ) return;

      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
      --n;
      if ( n )
	rb_hash_aset( _hash, _obj, INT2NUM(n) );
      else
	rb_hash_delete( _hash, _obj );
    }
    
    operator VALUE() const
    {
      return _obj;
    }

    VALUE inspect() const
    {
      return rb_inspect(_obj);
    }

    VALUE to_s() const
    {
      return rb_inspect(_obj);
    }

    static VALUE swig_protect_funcall( VALUE p )
    {
      OpArgs* args = (OpArgs*) p;
      return rb_funcall( args->src, args->id, args->nargs, args->target );
    }


#define GC_VALUE_CMP( op_id, op, cmp, cmpval ) \
    bool op( const GC_VALUE& other ) const \
    { \
      if ( FIXNUM_P(_obj) && FIXNUM_P(other._obj) ) \
      { \
	return _obj cmp other._obj; \
      } \
      bool  res = false; \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      if ( rb_respond_to( _obj, op_id ) == Qtrue ) \
	{ \
	  int status; \
	  OpArgs  args; \
          args.src    = _obj; \
	  args.id     = op_id; \
	  args.nargs  = 1; \
	  args.target = VALUE(other); \
	  ret = rb_protect( PROTECTFUNC(swig_protect_funcall), \
                            VALUE(&args), &status ); \
	} \
      if ( ret == Qnil ) { \
	VALUE a = rb_funcall(         _obj, hash_id, 0 ); \
	VALUE b = rb_funcall( VALUE(other), hash_id, 0 ); \
	res = a cmp b; \
      } \
      else \
	{ \
	  res = RTEST( ret ); \
	} \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return res; \
    }


    GC_VALUE_CMP( eq_id, operator==, ==, == 0 )
    GC_VALUE_CMP( lt_id, operator<,  < , <  0 )
    GC_VALUE_CMP( le_id, operator<=, <=, <= 0 )
    GC_VALUE_CMP( gt_id, operator>,  > , >  0 )
    GC_VALUE_CMP( ge_id, operator>=, >=, >= 0 )
#undef GC_VALUE_CMP

    bool operator!=( const GC_VALUE& other )
    {
      return !(this->operator==(other));
    }

#define GC_VALUE_UNARY( proc_id, op ) \
    GC_VALUE op() const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 0; \
      args.target = Qnil; \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return ret; \
    }

    GC_VALUE_UNARY( pos_id, operator+ )
    GC_VALUE_UNARY( neg_id, operator- )
    GC_VALUE_UNARY( inv_id, operator~ )
#undef GC_VALUE_BINARY

#define GC_VALUE_BINARY( proc_id, op ) \
    GC_VALUE op( const GC_VALUE& other ) const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 1; \
      args.target = VALUE(other); \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return GC_VALUE(ret); \
    }

    GC_VALUE_BINARY( add_id, operator+ );
    GC_VALUE_BINARY( sub_id, operator- );
    GC_VALUE_BINARY( mul_id, operator* );
    GC_VALUE_BINARY( div_id, operator/ );
    GC_VALUE_BINARY( mod_id, operator% );
    
    GC_VALUE_BINARY( and_id, operator& );
    GC_VALUE_BINARY( xor_id, operator^ );
    GC_VALUE_BINARY(  or_id, operator| );

    GC_VALUE_BINARY( lshift_id, operator<< );
    GC_VALUE_BINARY( rshift_id, operator>> );
#undef GC_VALUE_BINARY

  };

  ID  GC_VALUE::hash_id = rb_intern("hash");
  ID  GC_VALUE::lt_id = rb_intern("<");
  ID  GC_VALUE::gt_id = rb_intern(">");
  ID  GC_VALUE::eq_id = rb_intern("==");
  ID  GC_VALUE::le_id = rb_intern("<=");
  ID  GC_VALUE::ge_id = rb_intern(">=");

  ID  GC_VALUE::pos_id = rb_intern("+@");
  ID  GC_VALUE::neg_id = rb_intern("-@");
  ID  GC_VALUE::inv_id = rb_intern("~");

  ID  GC_VALUE::add_id = rb_intern("+");
  ID  GC_VALUE::sub_id = rb_intern("-");
  ID  GC_VALUE::mul_id = rb_intern("*");
  ID  GC_VALUE::div_id = rb_intern("/");
  ID  GC_VALUE::mod_id = rb_intern("%");

  ID  GC_VALUE::and_id = rb_intern("&");
  ID  GC_VALUE::or_id  = rb_intern("|");
  ID  GC_VALUE::xor_id = rb_intern("^");

  ID  GC_VALUE::lshift_id = rb_intern("<<");
  ID  GC_VALUE::rshift_id = rb_intern(">>");

  VALUE GC_VALUE::_hash = Qnil;

  typedef GC_VALUE LANGUAGE_OBJ;

} // namespace swig



#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>
#include <stddef.h>


#include <string>


#include <iostream>

  
namespace swig {
  struct stop_iteration {
  };

  /** 
   * Abstract base class used to represent all iterators of STL containers.
   */
  struct ConstIterator {
  public:
    typedef ConstIterator self_type;

  protected:
    GC_VALUE _seq;

  protected:
    ConstIterator(VALUE seq) : _seq(seq)
    {
    }

    // Random access iterator methods, but not required in Ruby
    virtual ptrdiff_t distance(const ConstIterator &x) const
    {
      throw std::invalid_argument("distance not supported");
    }

    virtual bool equal (const ConstIterator &x) const
    {
      throw std::invalid_argument("equal not supported");
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("advance not supported");
    }
      
  public:
    virtual ~ConstIterator() {}

    // Access iterator method, required by Ruby
    virtual VALUE value() const {
      throw std::invalid_argument("value not supported");
      return Qnil;
    };

    virtual VALUE setValue( const VALUE& v ) {
      throw std::invalid_argument("value= not supported");
      return Qnil;
    }

    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    virtual VALUE to_s() const {
      throw std::invalid_argument("to_s not supported");
      return Qnil;
    }

    virtual VALUE inspect() const {
      throw std::invalid_argument("inspect not supported");
      return Qnil;
    }
    
    virtual ConstIterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }

    //
    // C++ common/needed methods.  We emulate a bidirectional
    // operator, to be compatible with all the STL.
    // The iterator traits will then tell the STL what type of
    // iterator we really are.
    //
    ConstIterator() : _seq( Qnil )
    {
    }

    ConstIterator( const self_type& b ) : _seq( b._seq )
    {
    }

    self_type& operator=( const self_type& b )
    {
      _seq = b._seq;
      return *this;
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const ConstIterator& x) const
    {
      return ! operator==(x);
    }
      
    // Pre-decrement operator
    self_type& operator--()
    {
      return *previous();
    }

    // Pre-increment operator
    self_type& operator++()
    {
      return *next();
    }

    // Post-decrement operator
    self_type operator--(int)
    {
      self_type r = *this;
      previous();
      return r;
    }

    // Post-increment operator
    self_type operator++(int)
    {
      self_type r = *this;
      next();
      return r;
    }

    ConstIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    ConstIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }

    ConstIterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    ConstIterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const ConstIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::ConstIterator *");
	init = 1;
      }	
      return desc;
    }
  };


  /**
   * Abstract base class used to represent all non-const iterators of STL containers.
   * 
   */
  struct Iterator : public ConstIterator {
  public:
    typedef Iterator self_type;

  protected:
    Iterator(VALUE seq) : ConstIterator(seq)
    {
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("operation not supported");
    }

  public:
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::Iterator *");
	init = 1;
      }	
      return desc;
    }
    
    virtual Iterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }
      
    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const Iterator& x) const
    {
      return ! operator==(x);
    }
      
    Iterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    Iterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    Iterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    Iterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const Iterator& x) const
    {
      return x.distance(*this);
    }
  };

}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}


#include <stdexcept>


#include <algorithm>


#include <vector>


#include <utility>


#include <map>
#include <algorithm>
#include <stdexcept>


#include <list>


#include <map>
#include <algorithm>
#include <stdexcept>
#include <iostream>


#include "swmodule.h"
#include "filemgr.h"
#include "swconfig.h"


typedef std::map< sword::SWBuf, sword::SWBuf > AttributeValueMap;
typedef std::map< sword::SWBuf, AttributeValueMap> AttributeListMap;
typedef std::map< sword::SWBuf, AttributeListMap> AttributeTypeListMap; 
typedef std::multimap < sword::SWBuf, sword::SWBuf, std::less < sword::SWBuf > > PyConfigEntMap;
typedef std::map < sword::SWBuf, PyConfigEntMap > PySectionMap;


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}



namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static VALUE from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static VALUE from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static VALUE from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static VALUE from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline VALUE from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline VALUE from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(VALUE obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(VALUE obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(VALUE obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(VALUE obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(VALUE obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	static Type *v_def = (Type*) malloc(sizeof(Type));
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	return 0;
      }
    }
  };

  template <class Type>
  inline Type as(VALUE obj, bool te = false) {
    return traits_as< Type, typename traits< Type >::category >::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(VALUE obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(VALUE obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(VALUE obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


  namespace swig {
    template <>  struct traits<sword::SWBuf > {
      typedef pointer_category category;
      static const char* type_name() { return"sword::SWBuf"; }
    };
  }


  namespace swig {

    template <class T, class U >
    struct traits_asval<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(VALUE first, VALUE second,
			  std::pair<T,U> *val)
      {
	if (val) {
	  T *pfirst = &(val->first);
	  int res1 = swig::asval((VALUE)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = &(val->second);
	  int res2 = swig::asval((VALUE)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((VALUE)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((VALUE)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}	
      }

      static int asval(VALUE obj, std::pair<T,U> *val) {
	int res = SWIG_ERROR;
	if ( TYPE(obj) == T_ARRAY ) {
	  if (RARRAY_LEN(obj) == 2) {
	    VALUE first = rb_ary_entry(obj,0);
	    VALUE second = rb_ary_entry(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,
				swig::type_info<value_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = *p;
	}
	return res;
      }
    };

    template <class T, class U >
    struct traits_asptr<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(VALUE first, VALUE second,
			  std::pair<T,U> **val) 
      {
	if (val) {
	  value_type *vp = (new std::pair<T,U>);
	  T *pfirst = &(vp->first);
	  int res1 = swig::asval((VALUE)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = &(vp->second);
	  int res2 = swig::asval((VALUE)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  *val = vp;
	  return SWIG_AddNewMask(res1 > res2 ? res1 : res2);
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((VALUE)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((VALUE)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}	
      }

      static int asptr(VALUE obj, std::pair<T,U> **val) {
	int res = SWIG_ERROR;
	if ( TYPE(obj) == T_ARRAY ) {
	  if ( RARRAY_LEN(obj) == 2) {
	    VALUE first = rb_ary_entry(obj,0);
	    VALUE second = rb_ary_entry(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,
				swig::type_info<value_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };



    template <class T, class U >
    struct traits_from<std::pair<T,U> >   {
      static VALUE _wrap_pair_second( VALUE self )
      {
	std::pair< typename swig::noconst_traits<T >::noconst_type,U>* p = NULL;
	swig::asptr( self, &p );
	return swig::from( p->second );
      }

      static VALUE _wrap_pair_second_eq( VALUE self, VALUE arg )
      {
	std::pair< typename swig::noconst_traits<T >::noconst_type,U>* p = NULL;
	swig::asptr( self, &p );
	return swig::from( p->second );
      }

      static VALUE from(const std::pair<T,U>& val) {
	VALUE obj = rb_ary_new2(2);
	rb_ary_push(obj, swig::from<typename swig::noconst_traits<T >::noconst_type>(val.first));
	rb_ary_push(obj, swig::from(val.second));
	rb_define_singleton_method(obj, "second",
				   VALUEFUNC(_wrap_pair_second), 0 );
	rb_define_singleton_method(obj, "second=",
				   VALUEFUNC(_wrap_pair_second_eq), 1 );
	rb_obj_freeze(obj); // treat as immutable tuple
	return obj;
      }
    };

  }


      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,sword::SWBuf > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "sword::SWBuf" " >";
	  }
	};
      }
    

#include <functional>


namespace swig {
  template < class T >
  struct yield : public std::unary_function< T, bool >
  {
    bool
    operator()( const T& v ) const
    { 
      return RTEST( rb_yield( swig::from< T >(v) ) );
    }
  };


  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {

  /** 
   * Templated base classes for all custom const_iterators.
   *
   */
  template<typename OutConstIterator>
  class ConstIterator_T :  public ConstIterator
  {
  public:
    typedef OutConstIterator const_iter;
    typedef typename std::iterator_traits<const_iter>::value_type value_type;    
    typedef ConstIterator_T<const_iter> self_type;

  protected:

    
    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:
    ConstIterator_T() : ConstIterator(Qnil)
    {
    }

    ConstIterator_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator(seq), current(curr)
    {
    }

    const const_iter& get_current() const
    {
      return current;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    const_iter current;
  };


  /** 
   * Templated base classes for all custom non-const iterators.
   *
   */
  template<typename InOutIterator>
  class Iterator_T :  public Iterator
  {
  public:
    typedef InOutIterator nonconst_iter;

    // Make this class iterator STL compatible, by using iterator_traits
    typedef typename std::iterator_traits<nonconst_iter >::iterator_category iterator_category;
    typedef typename std::iterator_traits<nonconst_iter >::value_type        value_type;
    typedef typename std::iterator_traits<nonconst_iter >::difference_type   difference_type;
    typedef typename std::iterator_traits<nonconst_iter >::pointer           pointer;
    typedef typename std::iterator_traits<nonconst_iter >::reference         reference;

    typedef Iterator                         base;
    typedef Iterator_T< nonconst_iter > self_type;

  protected:

    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:

    Iterator_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator(seq), current(curr)
    {
    }

    const nonconst_iter& get_current() const
    {
      return current;
    }

    self_type& operator=( const self_type& b )
    {
      base::operator=( b );
      return *this;
    }
    
    self_type& operator=( const value_type& b )
    {
      *current = b;
      return *this;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    value_type& operator*()
    {
      return *current;
    }
    
    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    nonconst_iter current;
  };


  /**
   * Auxiliary functor to store the value of a ruby object inside
   * a reference of a compatible C++ type.  ie: Ruby -> C++
   * 
   */
  template <class ValueType>
  struct asval_oper 
  {
    typedef ValueType    value_type;
    typedef bool        result_type;
    bool operator()(VALUE obj, value_type& v) const
    {
      return ( swig::asval< value_type >(obj, &v) == SWIG_OK );
    }
  };

  /**
   * Auxiliary functor to return a ruby object from a C++ type. 
   * ie: C++ -> Ruby
   * 
   */
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef VALUE result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };


  /** 
   * ConstIterator class for a const_iterator with no end() boundaries.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorOpen_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;
    typedef ConstIteratorOpen_T<OutConstIterator, ValueType, FromOper> self_type;
    
    ConstIteratorOpen_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * Iterator class for an iterator with no end() boundaries.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorOpen_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper  from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;

  public:
    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }

    virtual VALUE setValue( const VALUE& v )
    {
      value_type& dst = *base::current;
      if ( asval(v, dst) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * ConstIterator class for a const_iterator where begin() and end() boundaries are known.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorClosed_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;    
    typedef ConstIteratorClosed_T<OutConstIterator, ValueType, FromOper> self_type;
    
  protected:
    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    ConstIteratorClosed_T(const_iter curr, const_iter first, 
			  const_iter last, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }


  private:
    const_iter begin;
    const_iter end;
  };

  /** 
   * Iterator class for a iterator where begin() and end() boundaries are known.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorClosed_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    // Iterator setter method, required by Ruby
    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      value_type& dst = *base::current;
      if ( asval( v, dst ) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorOpen_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, bool, FromOper, AsvalOper> self_type;

    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }

    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    virtual VALUE setValue( const VALUE& v )
    {
      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }    
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
    
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorClosed_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, bool, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }

    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }

    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };


  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, const InOutIter& begin,
			 const InOutIter& end, VALUE seq = Qnil)
  {
    return new IteratorClosed_T<InOutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, VALUE seq = Qnil)
  {
    return new IteratorOpen_T<InOutIter>(current, seq);
  }

  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, const OutIter& begin,
                       const OutIter& end, VALUE seq = Qnil)
  {
    return new ConstIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, VALUE seq = Qnil)
  {
    return new ConstIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{

  /**
   * This class is a proxy class for references, used to return and set values
   * of an element of a Ruby Array of stuff.
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_Ref
  {
    RubySequence_Ref(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      VALUE item = rb_ary_entry(_seq, _index );
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	VALUE lastErr = rb_gv_get("$!");
	if ( lastErr == Qnil ) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	VALUE str = rb_str_new2(msg);
	str = rb_str_cat2( str, e.what() );
	SWIG_Ruby_ExceptionType( NULL, str );
	throw;
      }
    }

    RubySequence_Ref& operator=(const T& v)
    {
      rb_ary_set(_seq, _index, swig::from< T >(v));
      return *this;
    }

  private:
    VALUE  _seq;
    int _index;
  };


  /**
   * This class is a proxy to return a pointer to a class, usually
   * RubySequence_Ref. 
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_ArrowProxy
  {
    RubySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };


  /**
   * Input Iterator.  This adapator class is a random access iterator that 
   * allows you to use STL algorithms with a Ruby class (a Ruby Array by default).
   * 
   */
  template <class T, class Reference = RubySequence_Ref< T > >
  struct RubySequence_InputIterator
  {
    typedef RubySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef ptrdiff_t difference_type;

    RubySequence_InputIterator()
    {
    }

    RubySequence_InputIterator(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    RubySequence_ArrowProxy<T>
    operator->() const {
      return RubySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    VALUE  _seq;
    difference_type _index;
  };


  /**
   * This adaptor class allows you to use a Ruby Array as if it was an STL
   * container, giving it begin(), end(), and iterators.
   * 
   */
  template <class T>
  struct RubySequence_Cont
  {
    typedef RubySequence_Ref<T> reference;
    typedef const RubySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef RubySequence_InputIterator<T, reference> iterator;
    typedef RubySequence_InputIterator<T, const_reference> const_iterator;

    RubySequence_Cont(VALUE  seq) : _seq(0)
    {
      if (!rb_obj_is_kind_of(seq, rb_cArray)) {
	throw std::invalid_argument("an Array is expected");
      }
      _seq = seq;
    }

    ~RubySequence_Cont()
    {
    }

    size_type size() const
    {
      return RARRAY_LEN(_seq);
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = false) const
    {
      int s = (int) size();
      for (int i = 0; i < s; ++i) {
	VALUE item = rb_ary_entry(_seq, i );
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    VALUE  _seq;
  };

}


namespace swig {
  template <class RubySeq, class Seq>
  inline void
  assign(const RubySeq& rubyseq, Seq* seq) {
    // seq->assign(rubyseq.begin(), rubyseq.end()); // not used as not always implemented
    typedef typename RubySeq::value_type value_type;
    typename RubySeq::const_iterator it = rubyseq.begin();
    for (;it != rubyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  RubySequence_Cont<value_type> rubyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return rubyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, "%s", e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	if (SWIG_ConvertPtr(obj,(void**)&p,
			    swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  // Partial specialization for GC_VALUE's.  No need to typecheck each
  // element.
  template< class Seq >
  struct traits_asptr_stdseq< Seq, swig::GC_VALUE > {
    typedef Seq sequence;
    typedef swig::GC_VALUE value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  if (seq) {
	    RubySequence_Cont<value_type> rubyseq(obj);
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return true;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, "%s", e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	if (SWIG_ConvertPtr(obj,(void**)&p,
			    swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static VALUE from(const sequence& seq) {






      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	VALUE obj = rb_ary_new2((int)size);
	int i = 0;
	for (const_iterator it = seq.begin();
	     it != seq.end(); ++it, ++i) {
	  rb_ary_push(obj, swig::from< value_type >(*it));
	}
	rb_obj_freeze(obj);  // treat as immutable result
	return obj;
      } else {
	rb_raise(rb_eRangeError,"sequence size not valid in ruby");
	return Qnil;
      }
    }
  };
}


  namespace swig {
    template <class RubySeq, class K, class T >
    inline void
    assign(const RubySeq& rubyseq, std::map<K,T > *map) {
      typedef typename std::map<K,T>::value_type value_type;
      typename RubySeq::const_iterator it = rubyseq.begin();
      for (;it != rubyseq.end(); ++it) {
	map->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T>
    struct traits_asptr<std::map<K,T> >  {
      typedef std::map<K,T> map_type;
      static int asptr(VALUE obj, map_type **val) {
	int res = SWIG_ERROR;
	if ( TYPE(obj) == T_HASH ) {
	  static ID id_to_a = rb_intern("to_a");
	  VALUE items = rb_funcall(obj, id_to_a, 0);
	  res = traits_asptr_stdseq<std::map<K,T>, std::pair<K, T> >::asptr(items, val);
	} else {
	  map_type *p;
	  res = SWIG_ConvertPtr(obj,(void**)&p,swig::type_info<map_type>(),0);
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };
      
    template <class K, class T >
    struct traits_from<std::map<K,T> >  {
      typedef std::map<K,T> map_type;
      typedef typename map_type::const_iterator const_iterator;
      typedef typename map_type::size_type size_type;
            
      static VALUE from(const map_type& map) {
	swig_type_info *desc = swig::type_info<map_type>();
	if (desc && desc->clientdata) {
	  return SWIG_NewPointerObj(new map_type(map), desc, SWIG_POINTER_OWN);
	} else {
	  size_type size = map.size();
	  int rubysize = (size <= (size_type) INT_MAX) ? (int) size : -1;
	  if (rubysize < 0) {
	    SWIG_RUBY_THREAD_BEGIN_BLOCK;
	    rb_raise( rb_eRuntimeError, "map size not valid in Ruby");
	    SWIG_RUBY_THREAD_END_BLOCK;
	    return Qnil;
	  }
	  VALUE obj = rb_hash_new();
	  for (const_iterator i= map.begin(); i!= map.end(); ++i) {
	    VALUE key = swig::from(i->first);
	    VALUE val = swig::from(i->second);
	    rb_hash_aset(obj, key, val);
	  }
	  return obj;
	}
      }
    };

    template <class ValueType>
    struct from_key_oper 
    {
      typedef const ValueType& argument_type;
      typedef  VALUE result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.first);
      }
    };

    template <class ValueType>
    struct from_value_oper 
    {
      typedef const ValueType& argument_type;
      typedef  VALUE result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.second);
      }
    };

    template<class OutIterator, class FromOper, 
	     class ValueType = typename OutIterator::value_type>
    struct MapIterator_T : ConstIteratorClosed_T<OutIterator, ValueType, FromOper>
    {
      MapIterator_T(OutIterator curr, OutIterator first, OutIterator last, VALUE seq)
	: ConstIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
      {
      }
    };


    template<class OutIterator,
	     class FromOper = from_key_oper<typename OutIterator::value_type> >
    struct MapKeyIterator_T : MapIterator_T<OutIterator, FromOper>
    {
      MapKeyIterator_T(OutIterator curr, OutIterator first, OutIterator last, VALUE seq)
	: MapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };

    template<typename OutIter>
    inline ConstIterator*
    make_output_key_iterator(const OutIter& current, const OutIter& begin, 
			     const OutIter& end, VALUE seq = 0)
    {
      return new MapKeyIterator_T<OutIter>(current, begin, end, seq);
    }

    template<class OutIterator,
	     class FromOper = from_value_oper<typename OutIterator::value_type> >
    struct MapValueIterator_T : MapIterator_T<OutIterator, FromOper>
    {
      MapValueIterator_T(OutIterator curr, OutIterator first, OutIterator last, VALUE seq)
	: MapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };
    

    template<typename OutIter>
    inline ConstIterator*
    make_output_value_iterator(const OutIter& current, const OutIter& begin, 
			       const OutIter& end, VALUE seq = 0)
    {
      return new MapValueIterator_T<OutIter>(current, begin, end, seq);
    }
  }


      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, sword::SWBuf, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "sword::SWBuf" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__dup(std::map< sword::SWBuf,sword::SWBuf > *self){
      return new std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____delete__(std::map< sword::SWBuf,sword::SWBuf > *self,std::map< sword::SWBuf,sword::SWBuf >::key_type const &key){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__has_key(std::map< sword::SWBuf,sword::SWBuf > const *self,std::map< sword::SWBuf,sword::SWBuf >::key_type const &key){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__keys(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each(std::map< sword::SWBuf,sword::SWBuf > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__select(std::map< sword::SWBuf,sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >* r = new std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >;
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__values_at(std::map< sword::SWBuf,sword::SWBuf > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each_key(std::map< sword::SWBuf,sword::SWBuf > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__values(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each_value(std::map< sword::SWBuf,sword::SWBuf > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__entries(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type, 
		     std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____contains__(std::map< sword::SWBuf,sword::SWBuf > *self,std::map< sword::SWBuf,sword::SWBuf >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__key_iterator(std::map< sword::SWBuf,sword::SWBuf > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__value_iterator(std::map< sword::SWBuf,sword::SWBuf > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____getitem__(std::map< sword::SWBuf,sword::SWBuf > const *self,std::map< sword::SWBuf,sword::SWBuf >::key_type const &key){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____setitem__(std::map< sword::SWBuf,sword::SWBuf > *self,std::map< sword::SWBuf,sword::SWBuf >::key_type const &key,std::map< sword::SWBuf,sword::SWBuf >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__inspect(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__to_a(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type, 
	    std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__to_s(std::map< sword::SWBuf,sword::SWBuf > *self){
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::key_type, 
	    std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__dup(std::map< sword::SWBuf,AttributeValueMap > *self){
      return new std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____delete__(std::map< sword::SWBuf,AttributeValueMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__has_key(std::map< sword::SWBuf,AttributeValueMap > const *self,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__keys(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each(std::map< sword::SWBuf,AttributeValueMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__select(std::map< sword::SWBuf,AttributeValueMap > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >* r = new std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >;
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__values_at(std::map< sword::SWBuf,AttributeValueMap > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each_key(std::map< sword::SWBuf,AttributeValueMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__values(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each_value(std::map< sword::SWBuf,AttributeValueMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__entries(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type, 
		     std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____contains__(std::map< sword::SWBuf,AttributeValueMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__key_iterator(std::map< sword::SWBuf,AttributeValueMap > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__value_iterator(std::map< sword::SWBuf,AttributeValueMap > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____getitem__(std::map< sword::SWBuf,AttributeValueMap > const *self,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____setitem__(std::map< sword::SWBuf,AttributeValueMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &key,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__inspect(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__to_a(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type, 
	    std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__to_s(std::map< sword::SWBuf,AttributeValueMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::key_type, 
	    std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__dup(std::map< sword::SWBuf,AttributeListMap > *self){
      return new std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____delete__(std::map< sword::SWBuf,AttributeListMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__has_key(std::map< sword::SWBuf,AttributeListMap > const *self,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__keys(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each(std::map< sword::SWBuf,AttributeListMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__select(std::map< sword::SWBuf,AttributeListMap > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >* r = new std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >;
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__values_at(std::map< sword::SWBuf,AttributeListMap > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each_key(std::map< sword::SWBuf,AttributeListMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__values(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each_value(std::map< sword::SWBuf,AttributeListMap > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__entries(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type, 
		     std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____contains__(std::map< sword::SWBuf,AttributeListMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__key_iterator(std::map< sword::SWBuf,AttributeListMap > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__value_iterator(std::map< sword::SWBuf,AttributeListMap > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____getitem__(std::map< sword::SWBuf,AttributeListMap > const *self,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &key){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____setitem__(std::map< sword::SWBuf,AttributeListMap > *self,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &key,std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__inspect(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__to_a(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type, 
	    std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__to_s(std::map< sword::SWBuf,AttributeListMap > *self){
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::key_type, 
	    std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

  namespace swig {
    template <>  struct traits<std::multimap< sword::SWBuf,sword::SWBuf > > {
      typedef pointer_category category;
      static const char* type_name() { return"std::multimap< sword::SWBuf,sword::SWBuf >"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "std::multimap< sword::SWBuf,sword::SWBuf >" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, std::multimap< sword::SWBuf,sword::SWBuf >, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "std::multimap< sword::SWBuf,sword::SWBuf >" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__dup(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      return new std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____delete__(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &key){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__has_key(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *self,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &key){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__keys(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__select(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >* r = new std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >;
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__values_at(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each_key(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__values(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each_value(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->begin();
	std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__entries(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type, 
		     std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____contains__(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__key_iterator(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__value_iterator(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____getitem__(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *self,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &key){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____setitem__(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &key,std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__inspect(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__to_a(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type, 
	    std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__to_s(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *self){
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator i = self->begin();
      std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::key_type, 
	    std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

  namespace swig {
    template <>  struct traits<sword::SWModule > {
      typedef pointer_category category;
      static const char* type_name() { return"sword::SWModule"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,sword::SWModule* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "sword::SWModule" " * >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, sword::SWModule *, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "sword::SWModule *" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__dup(std::map< sword::SWBuf,sword::SWModule * > *self){
      return new std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____delete__(std::map< sword::SWBuf,sword::SWModule * > *self,std::map< sword::SWBuf,sword::SWModule * >::key_type const &key){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__has_key(std::map< sword::SWBuf,sword::SWModule * > const *self,std::map< sword::SWBuf,sword::SWModule * >::key_type const &key){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__keys(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each(std::map< sword::SWBuf,sword::SWModule * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__select(std::map< sword::SWBuf,sword::SWModule * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >* r = new std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >;
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__values_at(std::map< sword::SWBuf,sword::SWModule * > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each_key(std::map< sword::SWBuf,sword::SWModule * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__values(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each_value(std::map< sword::SWBuf,sword::SWModule * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__entries(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type, 
		     std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____contains__(std::map< sword::SWBuf,sword::SWModule * > *self,std::map< sword::SWBuf,sword::SWModule * >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__key_iterator(std::map< sword::SWBuf,sword::SWModule * > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__value_iterator(std::map< sword::SWBuf,sword::SWModule * > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____getitem__(std::map< sword::SWBuf,sword::SWModule * > const *self,std::map< sword::SWBuf,sword::SWModule * >::key_type const &key){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____setitem__(std::map< sword::SWBuf,sword::SWModule * > *self,std::map< sword::SWBuf,sword::SWModule * >::key_type const &key,std::map< sword::SWBuf,sword::SWModule * >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__inspect(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__to_a(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type, 
	    std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__to_s(std::map< sword::SWBuf,sword::SWModule * > *self){
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::key_type, 
	    std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(VALUE obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static VALUE from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<sword::SWBuf, std::allocator< sword::SWBuf > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "sword::SWBuf" "," "std::allocator< sword::SWBuf >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__dup(std::vector< sword::SWBuf > *self){
      return new std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__inspect(std::vector< sword::SWBuf > *self){
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > >();
      VALUE str = rb_str_new2(type_name);
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__to_a(std::vector< sword::SWBuf > *self){
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__to_s(std::vector< sword::SWBuf > *self){
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator i = self->begin();
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__slice(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::difference_type i,std::vector< sword::SWBuf >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__each(std::vector< sword::SWBuf > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
	std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__select(std::vector< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* r = new std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >;
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__reject_bang(std::vector< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator i = self->begin();
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__delete_at(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____delete2__(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__pop(std::vector< sword::SWBuf > *self){
      if (self->empty()) return Qnil;
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( x );
    }
SWIGINTERN std::vector< sword::SWBuf >::value_type const std_vector_Sl_sword_SWBuf_Sg__push(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__reject(std::vector< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* r = new std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__at(std::vector< sword::SWBuf > const *self,std::vector< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_0(std::vector< sword::SWBuf > const *self,std::vector< sword::SWBuf >::difference_type i,std::vector< sword::SWBuf >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_1(std::vector< sword::SWBuf > const *self,std::vector< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_2(std::vector< sword::SWBuf > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____setitem____SWIG_0(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::difference_type i,std::vector< sword::SWBuf >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg____setitem____SWIG_1(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::difference_type i,std::vector< sword::SWBuf >::difference_type j,std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_SWBuf_Sg__shift(std::vector< sword::SWBuf > *self){
      if (self->empty()) return Qnil;
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( x );
    }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__insert__SWIG_0(std::vector< sword::SWBuf > *self,std::vector< sword::SWBuf >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type val = swig::as<std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError, "%s",
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *std_vector_Sl_sword_SWBuf_Sg__unshift(std::vector< sword::SWBuf > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type val = swig::as<std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError, "%s",
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <class T >
    struct traits_asptr<std::list<T> >  {
      static int asptr(VALUE obj, std::list<T> **lis) {
	return traits_asptr_stdseq<std::list<T> >::asptr(obj, lis);
      }
    };

    template <class T>
    struct traits_from<std::list<T> > {
      static VALUE from(const std::list<T> & vec) {
	return traits_from_stdseq<std::list<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::list<sword::SWBuf, std::allocator< sword::SWBuf > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::list<" "sword::SWBuf" ", " "std::allocator< sword::SWBuf >" " >";
	  }
	};
      }
    
SWIGINTERN std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *std_list_Sl_sword_SWBuf_Sg__dup(std::list< sword::SWBuf > *self){
      return new std::list<sword::SWBuf,std::allocator< sword::SWBuf > >(*self);
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__inspect(std::list< sword::SWBuf > *self){
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >();
      VALUE str = rb_str_new2(type_name);
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__to_a(std::list< sword::SWBuf > *self){
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__to_s(std::list< sword::SWBuf > *self){
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator i = self->begin();
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__slice(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::difference_type i,std::list< sword::SWBuf >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *std_list_Sl_sword_SWBuf_Sg__each(std::list< sword::SWBuf > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
	std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *std_list_Sl_sword_SWBuf_Sg__select(std::list< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* r = new std::list<sword::SWBuf,std::allocator< sword::SWBuf > >;
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator i = self->begin();
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *std_list_Sl_sword_SWBuf_Sg__reject_bang(std::list< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator i = self->begin();
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__delete_at(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____delete2__(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__pop(std::list< sword::SWBuf > *self){
      if (self->empty()) return Qnil;
      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( x );
    }
SWIGINTERN std::list< sword::SWBuf >::value_type const std_list_Sl_sword_SWBuf_Sg__push(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *std_list_Sl_sword_SWBuf_Sg__reject(std::list< sword::SWBuf > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* r = new std::list<sword::SWBuf,std::allocator< sword::SWBuf > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg__at(std::list< sword::SWBuf > const *self,std::list< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_0(std::list< sword::SWBuf > const *self,std::list< sword::SWBuf >::difference_type i,std::list< sword::SWBuf >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_1(std::list< sword::SWBuf > const *self,std::list< sword::SWBuf >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_2(std::list< sword::SWBuf > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____setitem____SWIG_0(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::difference_type i,std::list< sword::SWBuf >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::list<sword::SWBuf,std::allocator< sword::SWBuf > >::value_type >( x );
      }
SWIGINTERN VALUE std_list_Sl_sword_SWBuf_Sg____setitem____SWIG_1(std::list< sword::SWBuf > *self,std::list< sword::SWBuf >::difference_type i,std::list< sword::SWBuf >::difference_type j,std::list< sword::SWBuf,std::allocator< sword::SWBuf > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::list<sword::SWBuf,std::allocator< sword::SWBuf > >* >( &v );
      return r;
    }

#include "installmgr.h"


  namespace swig {
    template <>  struct traits<sword::InstallSource > {
      typedef pointer_category category;
      static const char* type_name() { return"sword::InstallSource"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::pair<sword::SWBuf,sword::InstallSource* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWBuf" "," "sword::InstallSource" " * >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWBuf, sword::InstallSource *, std::less< sword::SWBuf >, std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWBuf" "," "sword::InstallSource *" "," "std::less< sword::SWBuf >" "," "std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > >" " >";
	  }
	};
      }
    
SWIGINTERN std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__dup(std::map< sword::SWBuf,sword::InstallSource * > *self){
      return new std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >(*self);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____delete__(std::map< sword::SWBuf,sword::InstallSource * > *self,std::map< sword::SWBuf,sword::InstallSource * >::key_type const &key){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->find(key);
      if (i != self->end()) {
	self->erase(i);
	return swig::from( key );
      }
      else {
	return Qnil;
      }
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__has_key(std::map< sword::SWBuf,sword::InstallSource * > const *self,std::map< sword::SWBuf,sword::InstallSource * >::key_type const &key){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->find(key);
      return i != self->end();
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__keys(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->first) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each(std::map< sword::SWBuf,sword::InstallSource * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE k, v;
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    const std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type&    key = i->first;
	    const std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type& val = i->second;

	    k = swig::from<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type>(key);
	    v = swig::from<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type>(val);
	    rb_yield_values(2, k, v);
	  }
	
	return self;
      }
SWIGINTERN std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__select(std::map< sword::SWBuf,sword::InstallSource * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >* r = new std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >;
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE k = swig::from<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type>(i->first);
	  VALUE v = swig::from<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type>(i->second);
	  if ( RTEST( rb_yield_values(2, k, v) ) )
	    self->insert(r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__values_at(std::map< sword::SWBuf,sword::InstallSource * > *self,int argc,VALUE *argv,...){
    
    VALUE r = rb_ary_new();
    ID   id = rb_intern("[]");
    swig_type_info* type = swig::type_info< std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > >();
    VALUE me = SWIG_NewPointerObj( self, type, 0 );
    for ( int i = 0; i < argc; ++i )
      {
	VALUE key = argv[i];
	VALUE tmp = rb_funcall( me, id, 1, key );
	rb_ary_push( r, tmp );
      }
    
    return r;
  }
SWIGINTERN std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each_key(std::map< sword::SWBuf,sword::InstallSource * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->first );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__values(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from(i->second) );
      }
      return ary;
    }
SWIGINTERN std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each_value(std::map< sword::SWBuf,sword::InstallSource * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->begin();
	std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from( i->second );
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__entries(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type size = self->size();
      int rubysize = (size <= (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::size_type) INT_MAX) ? (int) size : -1;
      if (rubysize < 0) {
	SWIG_RUBY_THREAD_BEGIN_BLOCK;
	rb_raise(rb_eRuntimeError, "map size not valid in Ruby");
	SWIG_RUBY_THREAD_END_BLOCK;
	return Qnil;
      }
      VALUE ary = rb_ary_new2(rubysize);
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator e = self->end();
      for ( ; i != e; ++i ) {
	rb_ary_push( ary, swig::from<std::pair<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type, 
		     std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type> >(*i) );
      }
      return ary;
    }
SWIGINTERN bool std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____contains__(std::map< sword::SWBuf,sword::InstallSource * > *self,std::map< sword::SWBuf,sword::InstallSource * >::key_type const &key){
      return self->find(key) != self->end();
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__key_iterator(std::map< sword::SWBuf,sword::InstallSource * > *self,VALUE *RUBY_SELF){
      return swig::make_output_key_iterator(self->begin(), self->begin(), 
					    self->end(), *RUBY_SELF);
    }
SWIGINTERN swig::ConstIterator *std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__value_iterator(std::map< sword::SWBuf,sword::InstallSource * > *self,VALUE *RUBY_SELF){
      return swig::make_output_value_iterator(self->begin(), self->begin(), 
					      self->end(), *RUBY_SELF);
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____getitem__(std::map< sword::SWBuf,sword::InstallSource * > const *self,std::map< sword::SWBuf,sword::InstallSource * >::key_type const &key){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->find(key);
      if ( i != self->end() )
	return swig::from<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type>( i->second );
      else
	return Qnil;
    }
SWIGINTERN void std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____setitem__(std::map< sword::SWBuf,sword::InstallSource * > *self,std::map< sword::SWBuf,sword::InstallSource * >::key_type const &key,std::map< sword::SWBuf,sword::InstallSource * >::mapped_type const &x){
      (*self)[key] = x;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__inspect(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > >();
      VALUE str = rb_str_new2( type_name );
      str = rb_str_cat2( str, " {" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type >( i->first );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	  str = rb_str_cat2( str, "=>" );
	  tmp = swig::from< std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type >( i->second );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "}" );
      return str;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__to_a(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type, 
	    std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type> >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__to_s(std::map< sword::SWBuf,sword::InstallSource * > *self){
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator i = self->begin();
      std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  // @todo: improve -- this should just be swig::from(*i)
	  tmp = swig::from< std::pair<std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::key_type, 
	    std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::mapped_type> >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }

  namespace swig {
    template <>  struct traits<sword::DirEntry > {
      typedef pointer_category category;
      static const char* type_name() { return"sword::DirEntry"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<sword::DirEntry, std::allocator< sword::DirEntry > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "sword::DirEntry" "," "std::allocator< sword::DirEntry >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__dup(std::vector< sword::DirEntry > *self){
      return new std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__inspect(std::vector< sword::DirEntry > *self){
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator i = self->begin();
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator e = self->end();
      const char *type_name = swig::type_name< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > >();
      VALUE str = rb_str_new2(type_name);
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__to_a(std::vector< sword::DirEntry > *self){
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator i = self->begin();
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__to_s(std::vector< sword::DirEntry > *self){
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator i = self->begin();
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__slice(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::difference_type i,std::vector< sword::DirEntry >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__each(std::vector< sword::DirEntry > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator i = self->begin();
	std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__select(std::vector< sword::DirEntry > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* r = new std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >;
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator i = self->begin();
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__reject_bang(std::vector< sword::DirEntry > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator i = self->begin();
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__delete_at(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____delete2__(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__pop(std::vector< sword::DirEntry > *self){
      if (self->empty()) return Qnil;
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( x );
    }
SWIGINTERN std::vector< sword::DirEntry >::value_type const std_vector_Sl_sword_DirEntry_Sg__push(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__reject(std::vector< sword::DirEntry > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* r = new std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__at(std::vector< sword::DirEntry > const *self,std::vector< sword::DirEntry >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_0(std::vector< sword::DirEntry > const *self,std::vector< sword::DirEntry >::difference_type i,std::vector< sword::DirEntry >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_1(std::vector< sword::DirEntry > const *self,std::vector< sword::DirEntry >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_2(std::vector< sword::DirEntry > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____setitem____SWIG_0(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::difference_type i,std::vector< sword::DirEntry >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg____setitem____SWIG_1(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::difference_type i,std::vector< sword::DirEntry >::difference_type j,std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_sword_DirEntry_Sg__shift(std::vector< sword::DirEntry > *self){
      if (self->empty()) return Qnil;
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type >( x );
    }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__insert__SWIG_0(std::vector< sword::DirEntry > *self,std::vector< sword::DirEntry >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type val = swig::as<std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError, "%s",
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *std_vector_Sl_sword_DirEntry_Sg__unshift(std::vector< sword::DirEntry > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type val = swig::as<std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError, "%s",
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

#include "swobject.h"


#include "swconfig.h"

SWIGINTERN void sword_SWConfig_set(sword::SWConfig *self,char const *group,char const *entry,char const *value){
	self->Sections[group][entry] = value;
  }
SWIGINTERN char const *sword_SWConfig_get(sword::SWConfig *self,char const *group,char const *entry){
	return self->Sections[group][entry].c_str();
  }
SWIGINTERN PySectionMap *sword_SWConfig_getSections(sword::SWConfig *self){
    return (PySectionMap* /*std::map < sword::SWBuf, std::multimap < sword::SWBuf, sword::SWBuf > > * */) &self->Sections;
  }

#include "swversion.h"


#include "rawverse.h"
#include "zverse.h"
#include "rawstr.h"
#include "rawstr4.h"
#include "zstr.h"
#include "swgenbook.h"
#include "lzsscomprs.h"
#include "zipcomprs.h"
#include "versekey.h"
#include "versetreekey.h"
#include "treekey.h"
#include "rawgenbook.h"
#include "swtext.h"
#include "swcom.h"
#include "rawcom.h"
#include "swld.h"
#include "zld.h"
#include "zcom.h"
#include "ztext.h"
#include "rawld.h"
#include "rawld4.h"
#include "treekeyidx.h"
#include "rawtext.h"




SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (VALUE obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_signed_SS_char  (signed char value)
{    
  return SWIG_From_long  (value);
}


#include "swkey.h"


SWIGINTERN int
SWIG_AsVal_signed_SS_char (VALUE obj, signed char *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SCHAR_MIN || v > SCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< signed char >(v);
    }
  }  
  return res;
}


#include "listkey.h"

SWIGINTERN sword::ListKey *sword_ListKey_castTo(sword::SWKey *o){
		return dynamic_cast<sword::ListKey*>(o);
	}

#include "versekey.h"
#include "versemgr.h"

SWIGINTERN sword::VerseKey *sword_VerseKey_castTo(sword::SWKey *o){
		return dynamic_cast<sword::VerseKey*>(o);
	}
SWIGINTERN int const sword_VerseKey_bookCount(sword::VerseKey *self,int const testament){
		if ( (testament < 1) || (testament > 2) ) {
			return 0;
		};
		return self->BMAX[testament-1];
	}
SWIGINTERN int const sword_VerseKey_getBookCount(sword::VerseKey *self){
        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
        return system->getBookCount();
    }
SWIGINTERN char const *sword_VerseKey_bookName(sword::VerseKey *self,int const testament,int const book){
		if ( (testament < 1) || (testament > 2) ) {
			return 0;
		};
		if ( (book < 1) || (book > self->BMAX[testament-1]) ) {
			return 0;
		}

        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
        
        int book_num = (book - 1) + (
            (testament == 2) ? self->BMAX[0] : 0
        );

        const sword::VerseMgr::Book* b = system->getBook(book_num);
        if(!b) {
            fprintf(stderr, "b is null for %d?!?\n", book_num);
            return 0;
        }
        return b->getLongName();

 
	}
SWIGINTERN int sword_VerseKey_getBookNumberByOSISName(sword::VerseKey *self,char const *bookname){
        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
        return system->getBookNumberByOSISName(bookname);
   }
SWIGINTERN char const *sword_VerseKey_getOSISBookName__SWIG_1(sword::VerseKey *self,int const book){
        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
   		if ( (book < 0) || (book >= system->getBookCount()))
            return 0;

        return system->getBook(book)->getOSISName();
    }
SWIGINTERN int const sword_VerseKey_chapterCount(sword::VerseKey *self,int const testament,int const book){
		if ( (testament < 1) || (testament > 2) ) {
			return 0;
		};
		if ( (book < 1) || (book > self->BMAX[testament-1]) ) {
			return 0;
		}

        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
        
        int book_num = (book - 1) + (
            (testament == 2) ? self->BMAX[0] : 0
        );

        const sword::VerseMgr::Book* b = system->getBook(book_num);
        if(!b) {
            fprintf(stderr, "b is null for %d?!?\n", book_num);
            return 0;
        }        

        return b->getChapterMax();
	}
SWIGINTERN int const sword_VerseKey_verseCount(sword::VerseKey *self,int const testament,int const book,int const chapter){
		if ( (testament < 1) || (testament > 2) ) {
			return 0;
		};
		if ( (book < 1) || (book > self->BMAX[testament-1]) ) {
			return 0;
		}

        const sword::VerseMgr::System* system = sword::VerseMgr::getSystemVerseMgr()->getVersificationSystem(
            self->getVersificationSystem()
        );
        
        int book_num = (book - 1) + (
            (testament == 2) ? self->BMAX[0] : 0
        );

        const sword::VerseMgr::Book* b = system->getBook(book_num);
        if(!b) {
            fprintf(stderr, "b is null for %d?!?\n", book_num);
            return 0;
        }
		if ( (chapter < 1) || (chapter > b->getChapterMax()) ) {
			return 0;
		}

		return b->getVerseMax(chapter);

	}
SWIGINTERN int sword_abbrev_getAbbrevCount(sword::abbrev *self){
		int abbrevsCnt;
		for (abbrevsCnt = 0; *self[abbrevsCnt].ab; abbrevsCnt++) {}
		return abbrevsCnt-1;
	}
SWIGINTERN sword::abbrev const *sword_abbrev_getAbbrevData(sword::abbrev *self,int i){
		return &(self[i]);
	}

SWIGINTERN int
SWIG_AsVal_unsigned_SS_char (VALUE obj, unsigned char *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UCHAR_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned char >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

SWIGINTERN int const sword_sbook_verseMax(sword::sbook *self,int chapter){
		if ( chapter > 0  && chapter < self->chapmax ) {
			return self->versemax[chapter-1];
		} else {
			return 0;
		}
	}

#include "treekey.h"

SWIGINTERN sword::TreeKey *sword_TreeKey_castTo(sword::SWKey *o){
		return dynamic_cast<sword::TreeKey*>(o);
	}

#include "treekeyidx.h"

SWIGINTERN sword::TreeKeyIdx *sword_TreeKeyIdx_castTo(sword::SWKey *o){
		return dynamic_cast<sword::TreeKeyIdx*>(o);
	}

#include "versetreekey.h"

SWIGINTERN sword::VerseTreeKey *sword_VerseTreeKey_castTo(sword::SWKey *o){
		return dynamic_cast<sword::VerseTreeKey*>(o);
	}

#include "swdisp.h"


#include <swfilter.h>


#include "swoptfilter.h"

SWIGINTERN sword::SWOptionFilter *sword_SWOptionFilter_castTo(sword::SWFilter *o){
		return dynamic_cast<sword::SWOptionFilter*>(o);
	}

#include <swfiltermgr.h>


#include "stringmgr.h"
class PyStringMgr : public sword::StringMgr
{
    public:
       char *upperUTF8(char *text, unsigned int max = 0) const
        {
            sword::SWBuf buf=(const char*)text;
            getUpper(&buf);
            strncpy(text, buf.c_str(), (max) ? max : strlen(text));
            return text;
        }

        virtual void getUpper(sword::SWBuf* test) const = 0;
};


#include "swsearchable.h"

SWIGINTERN bool sword_SWSearchable_isSearchSupported__SWIG_0(sword::SWSearchable *self,char const *istr,int searchType=0,int flags=0,sword::SWKey *scope=0){
                bool checksupported = true;
                self->search(istr, searchType, flags, scope, &checksupported);
                return checksupported;
        }
SWIGINTERN sword::ListKey &sword_SWSearchable_doSearch__SWIG_0(sword::SWSearchable *self,char const *istr,int searchType=0,int flags=0,sword::SWKey *scope=0){
                return self->search(istr, searchType, flags, scope);
        }

#include "swmodule.h"

SWIGINTERN sword::SWModule *sword_SWModule_castTo(sword::SWSearchable *o){
		return dynamic_cast<sword::SWModule*>(o);
	}
SWIGINTERN std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > &sword_SWModule_getEntryAttributesMap(sword::SWModule *self){
            return self->getEntryAttributes();
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *sword_SWModule_getConfigMap(sword::SWModule *self){
    return ( std::map < sword::SWBuf, sword::SWBuf > * ) &self->getConfig();
  }

#include <swmgr.h>

SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > sword_SWMgr_getGlobalOptionsVector(sword::SWMgr *self){
        std::list<sword::SWBuf> l(self->getGlobalOptions());
        return std::vector< sword::SWBuf >(l.begin(), l.end());
    }
SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > sword_SWMgr_getGlobalOptionValuesVector(sword::SWMgr *self,char const *option){
        std::list<sword::SWBuf> l(self->getGlobalOptionValues(option));
        return std::vector< sword::SWBuf >(l.begin(), l.end());
    }
SWIGINTERN std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > &sword_SWMgr_getModules(sword::SWMgr *self){
        return self->Modules;
    }
SWIGINTERN sword::SWModule *sword_SWMgr_getModuleAt(sword::SWMgr *self,int const pos){
        if (pos < 0 || pos > (int)self->Modules.size() )
            return 0;
    
        sword::ModMap::iterator it = self->Modules.begin(); 
        
        for (int i = 0; i < pos; ++i) {
            it++;
        }

        if ( it != self->Modules.end() ) {
            return (*it).second;
        }
        
        return 0;
    }

#include "encfiltmgr.h"

SWIGINTERN sword::EncodingFilterMgr *sword_EncodingFilterMgr_castTo(sword::SWFilterMgr *o){
		return dynamic_cast<sword::EncodingFilterMgr*>(o);
	}

#include <markupfiltmgr.h>
using namespace sword;

SWIGINTERN sword::MarkupFilterMgr *sword_MarkupFilterMgr_castTo(sword::SWFilterMgr *o){
		return dynamic_cast<sword::MarkupFilterMgr*>(o);
	}

#include "swlocale.h"

SWIGINTERN sword::abbrev const *sword_SWLocale_getBookAbbrevs(sword::SWLocale *self){
        int x;
        return self->getBookAbbrevs(&x);
    }

#include <swcomprs.h>


#include <lzsscomprs.h>

SWIGINTERN sword::LZSSCompress *sword_LZSSCompress_castTo(sword::SWCompress *o){
		return dynamic_cast<sword::LZSSCompress*>(o);
	}

#include <zipcomprs.h>

SWIGINTERN sword::ZipCompress *sword_ZipCompress_castTo(sword::SWCompress *o){
		return dynamic_cast<sword::ZipCompress*>(o);
	}

#include "swcom.h"

SWIGINTERN sword::SWCom *sword_SWCom_castTo(sword::SWModule *o){
		return dynamic_cast<sword::SWCom*>(o);
	}

#include "rawcom.h"

SWIGINTERN sword::RawCom *sword_RawCom_castTo(sword::SWModule *o){
		return dynamic_cast<sword::RawCom*>(o);
	}

#include "zverse.h"
#include "zcom.h"

SWIGINTERN sword::zCom *sword_zCom_castTo(sword::SWModule *o){
		return dynamic_cast<sword::zCom*>(o);
	}

#include "swgenbook.h"

SWIGINTERN sword::SWGenBook *sword_SWGenBook_castTo(sword::SWModule *o){
		return dynamic_cast<sword::SWGenBook*>(o);
	}

#include "rawgenbook.h"

SWIGINTERN sword::RawGenBook *sword_RawGenBook_castTo(sword::SWModule *o){
		return dynamic_cast<sword::RawGenBook*>(o);
	}

#include "swld.h"

SWIGINTERN sword::SWLD *sword_SWLD_castTo(sword::SWModule *o){
		return dynamic_cast<sword::SWLD*>(o);
	}

#include "rawld.h"

SWIGINTERN sword::RawLD *sword_RawLD_castTo(sword::SWModule *o){
		return dynamic_cast<sword::RawLD*>(o);
	}

#include "rawld4.h"

SWIGINTERN sword::RawLD4 *sword_RawLD4_castTo(sword::SWModule *o){
		return dynamic_cast<sword::RawLD4*>(o);
	}

#include "zld.h"

SWIGINTERN sword::zLD *sword_zLD_castTo(sword::SWModule *o){
		return dynamic_cast<sword::zLD*>(o);
	}

#include "swtext.h"

SWIGINTERN sword::SWText *sword_SWText_castTo(sword::SWModule *o){
		return dynamic_cast<sword::SWText*>(o);
	}

#include "rawtext.h"

SWIGINTERN sword::RawText *sword_RawText_castTo(sword::SWModule *o){
		return dynamic_cast<sword::RawText*>(o);
	}

#include "ztext.h"

SWIGINTERN sword::zText *sword_zText_castTo(sword::SWModule *o){
		return dynamic_cast<sword::zText*>(o);
	}

#include <localemgr.h>

SWIGINTERN std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > sword_LocaleMgr_getAvailableLocalesVector(sword::LocaleMgr *self){
        std::list<sword::SWBuf> l(self->getAvailableLocales());
        return std::vector< sword::SWBuf >(l.begin(), l.end());
    }

#include <url.h>


#include <utilxml.h>


#include <swbasicfilter.h>
#include <osishtmlhref.h>
#include <plainhtml.h>
#include <thmlhtmlhref.h>
#include <gbfhtmlhref.h>
#include "utf8html.h"

 
#include "markupcallback.h"
#include "rendercallback.h"
#include "searcher.h"


#include "swlog.h"


#include "ftptrans.h"


/*@SWIG:/usr/local/share/swig/2.0.4/ruby/rubyprimtypes.swg,19,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = NUM2DBL(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


#include "installmgr.h"


namespace swig {
  template <> struct traits<int > {
    typedef value_category category;
    static const char* type_name() { return"int"; }
  };  
  template <>  struct traits_asval<int > {   
    typedef int value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_int (obj, val);
    }
  };
  template <>  struct traits_from<int > {
    typedef int value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_int  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::pair<sword::SWModule*,int > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "sword::SWModule" " *," "int" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::map<sword::SWModule *, int, std::less< sword::SWModule * >, std::allocator< std::pair< sword::SWModule *const,int > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "sword::SWModule *" "," "int" "," "std::less< sword::SWModule * >" "," "std::allocator< std::pair< sword::SWModule *const,int > >" " >";
	  }
	};
      }
    
/* ---------------------------------------------------
 * C++ director class helpers
 * --------------------------------------------------- */



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "rsword.h"

swig_class SwigClassSWBuf;

SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWBuf *)new sword::SWBuf();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  unsigned long arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWBuf", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","sword::SWBuf", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  result = (sword::SWBuf *)new sword::SWBuf((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWBuf", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWBuf *)new sword::SWBuf((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","sword::SWBuf", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  result = (sword::SWBuf *)new sword::SWBuf(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = 0 ;
  unsigned long arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const &","sword::SWBuf", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","sword::SWBuf", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","sword::SWBuf", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  result = (sword::SWBuf *)new sword::SWBuf((sword::SWBuf const &)*arg1,arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWBuf_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWBuf_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWBuf);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWBuf__SWIG_5(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWBuf";
  sword::SWBuf *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const &","sword::SWBuf", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","sword::SWBuf", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (sword::SWBuf *)new sword::SWBuf((sword::SWBuf const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SWBuf(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SWBuf__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWBuf__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_char(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SWBuf__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWBuf__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SWBuf__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SWBuf__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "SWBuf.new", 
    "    SWBuf.new()\n"
    "    SWBuf.new(char const *initVal, unsigned long initSize)\n"
    "    SWBuf.new(char const *initVal)\n"
    "    SWBuf.new(char initVal)\n"
    "    SWBuf.new(sword::SWBuf const &other, unsigned long initSize)\n"
    "    SWBuf.new(sword::SWBuf const &other)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_SWBuf(sword::SWBuf *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWBuf_setFillByte(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","setFillByte", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setFillByte", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setFillByte(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_getFillByte(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","getFillByte", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (char)(arg1)->getFillByte();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_c_str(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","c_str", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (char *)((sword::SWBuf const *)arg1)->c_str();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWBuf.size

  call-seq:
    size -> unsigned long
    size(newSize)

Size or Length of the SWBuf.
*/
SWIGINTERN VALUE
_wrap_SWBuf_size__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (unsigned long)((sword::SWBuf const *)arg1)->size();
  vresult = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_size__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","size", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  (arg1)->size(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_size(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWBuf_size__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWBuf_size__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWBuf.size", 
    "    void SWBuf.size()\n"
    "    void SWBuf.size(unsigned long newSize)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_length(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","length", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (unsigned long)((sword::SWBuf const *)arg1)->length();
  vresult = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","set", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","set", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->set((sword::SWBuf const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","set", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->set((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_set(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_set__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_set__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWBuf.set", 
    "    void SWBuf.set(sword::SWBuf const &newVal)\n"
    "    void SWBuf.set(char const *newVal)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_setFormatted(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","setFormatted", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setFormatted", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWBuf *) &(arg1)->setFormatted((char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_setSize(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","setSize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","setSize", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  (arg1)->setSize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_resize(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  (arg1)->resize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","append", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","append", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->append((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","append", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->append((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","append", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","append", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","append", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->append((sword::SWBuf const &)*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","append", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","append", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->append((sword::SWBuf const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","append", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->append(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_append__SWIG_5(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  wchar_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  wchar_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_wchar_t(argv[0], &val2);
  //ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "wchar_t","append", 2, argv[0] ));
  } 
  arg2 = static_cast< wchar_t >(val2);
  (arg1)->append(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_append(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_append__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_wchar_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWBuf_append__SWIG_5(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWBuf_append__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_append__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWBuf_append__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWBuf_append__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SWBuf.append", 
    "    void SWBuf.append(char const *str, long max)\n"
    "    void SWBuf.append(char const *str)\n"
    "    void SWBuf.append(sword::SWBuf const &str, long max)\n"
    "    void SWBuf.append(sword::SWBuf const &str)\n"
    "    void SWBuf.append(char ch)\n"
    "    void SWBuf.append(wchar_t wch)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_appendFormatted(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","appendFormatted", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","appendFormatted", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->appendFormatted((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}



/*
  Document-method: Sword::SWBuf.insert

  call-seq:
    insert(pos, str, start=0, max=-1)
    insert(pos, str, start=0)
    insert(pos, str)
    insert(pos, str, start=0, max=-1)
    insert(pos, str, start=0)
    insert(pos, str)
    insert(pos, c)

Insert one or more new elements in the SWBuf.
*/
SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  char *arg3 = (char *) 0 ;
  unsigned long arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  unsigned long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","insert", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_unsigned_SS_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned long","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned long >(val4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","insert", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  (arg1)->insert(arg2,(char const *)arg3,arg4,arg5);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  char *arg3 = (char *) 0 ;
  unsigned long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  unsigned long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","insert", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_unsigned_SS_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned long","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned long >(val4);
  (arg1)->insert(arg2,(char const *)arg3,arg4);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","insert", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->insert(arg2,(char const *)arg3);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  sword::SWBuf *arg3 = 0 ;
  unsigned long arg4 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned long","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned long >(val4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","insert", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  (arg1)->insert(arg2,(sword::SWBuf const &)*arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  sword::SWBuf *arg3 = 0 ;
  unsigned long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  unsigned long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned long","insert", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned long >(val4);
  (arg1)->insert(arg2,(sword::SWBuf const &)*arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_5(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  sword::SWBuf *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  (arg1)->insert(arg2,(sword::SWBuf const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_insert__SWIG_6(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned long arg2 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->insert(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_insert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SWBuf_insert__SWIG_5(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWBuf_insert__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SWBuf_insert__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWBuf_insert__SWIG_4(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWBuf_insert__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_SWBuf_insert__SWIG_3(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_SWBuf_insert__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "SWBuf.insert", 
    "    void SWBuf.insert(unsigned long pos, char const *str, unsigned long start, long max)\n"
    "    void SWBuf.insert(unsigned long pos, char const *str, unsigned long start)\n"
    "    void SWBuf.insert(unsigned long pos, char const *str)\n"
    "    void SWBuf.insert(unsigned long pos, sword::SWBuf const &str, unsigned long start, long max)\n"
    "    void SWBuf.insert(unsigned long pos, sword::SWBuf const &str, unsigned long start)\n"
    "    void SWBuf.insert(unsigned long pos, sword::SWBuf const &str)\n"
    "    void SWBuf.insert(unsigned long pos, char c)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_getRawData(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","getRawData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (char *)(arg1)->getRawData();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_trimStart(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","trimStart", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (sword::SWBuf *) &(arg1)->trimStart();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_trimEnd(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","trimEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (sword::SWBuf *) &(arg1)->trimEnd();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_trim(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","trim", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (sword::SWBuf *) &(arg1)->trim();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_stripPrefix__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","stripPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","stripPrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","stripPrefix", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (char *)(arg1)->stripPrefix(arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_stripPrefix__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","stripPrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","stripPrefix", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char *)(arg1)->stripPrefix(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_stripPrefix(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWBuf_stripPrefix__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWBuf_stripPrefix__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SWBuf.stripPrefix", 
    "    char const * SWBuf.stripPrefix(char separator, bool endOfStringAsSeparator)\n"
    "    char const * SWBuf.stripPrefix(char separator)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_replaceBytes(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","replaceBytes", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","replaceBytes", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","replaceBytes", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  result = (sword::SWBuf *) &(arg1)->replaceBytes((char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_startsWith__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","startsWith", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","startsWith", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","startsWith", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (bool)((sword::SWBuf const *)arg1)->startsWith((sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_endsWith__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","endsWith", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","endsWith", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","endsWith", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (bool)((sword::SWBuf const *)arg1)->endsWith((sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_indexOf(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","indexOf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","indexOf", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","indexOf", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (long)((sword::SWBuf const *)arg1)->indexOf((sword::SWBuf const &)*arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_compare__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (int)((sword::SWBuf const *)arg1)->compare((sword::SWBuf const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_startsWith__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","startsWith", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","startsWith", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)((sword::SWBuf const *)arg1)->startsWith((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_startsWith(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_startsWith__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_startsWith__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWBuf.startsWith", 
    "    bool SWBuf.startsWith(sword::SWBuf const &prefix)\n"
    "    bool SWBuf.startsWith(char const *prefix)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_endsWith__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","endsWith", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","endsWith", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)((sword::SWBuf const *)arg1)->endsWith((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_endsWith(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_endsWith__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_endsWith__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWBuf.endsWith", 
    "    bool SWBuf.endsWith(sword::SWBuf const &postfix)\n"
    "    bool SWBuf.endsWith(char const *postfix)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_compare__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf const *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","compare", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)((sword::SWBuf const *)arg1)->compare((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBuf_compare(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_compare__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBuf_compare__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWBuf.compare", 
    "    int SWBuf.compare(sword::SWBuf const &other)\n"
    "    int SWBuf.compare(char const *other)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBuf_charAt2(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = (sword::SWBuf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf *","charAt2", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","charAt2", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (char)sword_SWBuf_charAt2(arg1,arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassGC_VALUE;


/*
  Document-method: Sword::GC_VALUE.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_inspect(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  swig::GC_VALUE r1 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  r1 = self; arg1 = &r1;
  result = (VALUE)((swig::GC_VALUE const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::GC_VALUE.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_GC_VALUE_to_s(int argc, VALUE *argv, VALUE self) {
  swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  swig::GC_VALUE r1 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  r1 = self; arg1 = &r1;
  result = (VALUE)((swig::GC_VALUE const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassConstIterator;

SWIGINTERN void
free_swig_ConstIterator(swig::ConstIterator *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","value", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (VALUE)((swig::ConstIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.dup

  call-seq:
    dup -> ConstIterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (VALUE)((swig::ConstIterator const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (VALUE)((swig::ConstIterator const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::ConstIterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (swig::ConstIterator *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.next", 
    "    swig::ConstIterator * ConstIterator.next(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::ConstIterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  try {
    result = (swig::ConstIterator *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.previous", 
    "    swig::ConstIterator * ConstIterator.previous(size_t n)\n"
    "    swig::ConstIterator * ConstIterator.previous()\n");
  
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = (bool)((swig::ConstIterator const *)arg1)->operator ==((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.+

  call-seq:
    +(n) -> ConstIterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ConstIterator.-

  call-seq:
    -(n) -> ConstIterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ;
  swig::ConstIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = ((swig::ConstIterator const *)arg1)->operator -((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
    "    __sub__.new(ptrdiff_t n)\n"
    "    __sub__.new(swig::ConstIterator const &x)\n");
  
  return Qnil;
}


swig_class SwigClassIterator;

SWIGINTERN VALUE
_wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  VALUE *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE temp2 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","setValue", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  temp2 = static_cast< VALUE >(argv[0]);
  arg2 = &temp2;
  result = (VALUE)(arg1)->setValue((VALUE const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::Iterator.dup

  call-seq:
    dup -> Iterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (swig::Iterator *)((swig::Iterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::Iterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  try {
    result = (swig::Iterator *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_next__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_next__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.next", 
    "    swig::Iterator * Iterator.next(size_t n)\n"
    "    swig::Iterator * Iterator.next()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] ));
  } 
  arg2 = static_cast< size_t >(val2);
  result = (swig::Iterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  try {
    result = (swig::Iterator *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Iterator_previous__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator_previous__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.previous", 
    "    swig::Iterator * Iterator.previous(size_t n)\n"
    "    swig::Iterator * Iterator.previous()\n");
  
  return Qnil;
}



/*
  Document-method: Sword::Iterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_Iterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (VALUE)((swig::Iterator const *)arg1)->inspect();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::Iterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_Iterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  result = (VALUE)((swig::Iterator const *)arg1)->to_s();
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::Iterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = (bool)((swig::Iterator const *)arg1)->operator ==((swig::Iterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::Iterator.+

  call-seq:
    +(n) -> Iterator

Add operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator +", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::Iterator.-

  call-seq:
    -(n) -> Iterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::Iterator *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] ));
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_Ruby_ExceptionType(NULL, Qnil);
      SWIG_fail;
    }
  }
  
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  ptrdiff_t result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self )); 
  }
  arg1 = reinterpret_cast< swig::Iterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator -", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator -", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = ((swig::Iterator const *)arg1)->operator -((swig::Iterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__Iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Iterator___sub____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__Iterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Iterator___sub____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new", 
    "    __sub__.new(ptrdiff_t n)\n"
    "    __sub__.new(swig::Iterator const &x)\n");
  
  return Qnil;
}


SWIGINTERN void
free_swig_Iterator(swig::Iterator *arg1) {
    delete arg1;
}

swig_class SwigClassAttributeValueMap;

SWIGINTERN VALUE
_wrap_new_AttributeValueMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::AttributeValueMap";
  std::map< sword::SWBuf,sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,sword::SWBuf)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,sword::SWBuf)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf > *)new std::map< sword::SWBuf,sword::SWBuf >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.dup

  call-seq:
    dup -> AttributeValueMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__has_key((std::map< sword::SWBuf,sword::SWBuf > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.each

  call-seq:
    each -> AttributeValueMap

Iterate thru each element in the AttributeValueMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.select

  call-seq:
    select -> AttributeValueMap

Iterate thru each element in the AttributeValueMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.each_key

  call-seq:
    each_key -> AttributeValueMap

Iterate thru each key element in the AttributeValueMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.each_value

  call-seq:
    each_value -> AttributeValueMap

Iterate thru each key element in the AttributeValueMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____getitem__((std::map< sword::SWBuf,sword::SWBuf > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::mapped_type const &","__setitem__", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::mapped_type const &","__setitem__", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::mapped_type * >(argp3);
  try {
    std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(sword::SWBuf const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.to_a

  call-seq:
    to_a -> VALUE

Convert AttributeValueMap to an Array.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_AttributeValueMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::AttributeValueMap";
  std::map< sword::SWBuf,sword::SWBuf > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,sword::SWBuf > *)new std::map< sword::SWBuf,sword::SWBuf >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AttributeValueMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AttributeValueMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AttributeValueMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::AttributeValueMap";
  std::map< sword::SWBuf,sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *ptr = (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const &","std::map<(sword::SWBuf,sword::SWBuf)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf > const &","std::map<(sword::SWBuf,sword::SWBuf)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,sword::SWBuf > *)new std::map< sword::SWBuf,sword::SWBuf >((std::map< sword::SWBuf,sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AttributeValueMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_AttributeValueMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeValueMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeValueMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "AttributeValueMap.new", 
    "    AttributeValueMap.new(std::less< sword::SWBuf > const &)\n"
    "    AttributeValueMap.new()\n"
    "    AttributeValueMap.new(std::map< sword::SWBuf,sword::SWBuf > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.empty?

  call-seq:
    empty? -> bool

Check if the AttributeValueMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,sword::SWBuf > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.size

  call-seq:
    size -> size_type

Size or Length of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::SWBuf > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.clear

  call-seq:
    clear

Clear AttributeValueMap contents.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::SWBuf > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::allocator_type(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.erase

  call-seq:
    erase(x) -> size_type
    erase(position)
    erase(first, last)

Delete a portion of the AttributeValueMap.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,sword::SWBuf >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,sword::SWBuf > const *)arg1)->count((std::map< sword::SWBuf,sword::SWBuf >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator arg2 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_AttributeValueMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeValueMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeValueMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_AttributeValueMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "AttributeValueMap.erase", 
    "    void AttributeValueMap.erase(std::map< sword::SWBuf,sword::SWBuf >::key_type const &x)\n"
    "    void AttributeValueMap.erase(std::map< sword::SWBuf,sword::SWBuf >::iterator position)\n"
    "    void AttributeValueMap.erase(std::map< sword::SWBuf,sword::SWBuf >::iterator first, std::map< sword::SWBuf,sword::SWBuf >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeValueMap.find

  call-seq:
    find(x) -> iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_AttributeValueMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,sword::SWBuf >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,sword::SWBuf >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeValueMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWBuf > *arg1 = (std::map< sword::SWBuf,sword::SWBuf > *) 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWBuf >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWBuf >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,sword::SWBuf >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWBuf >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWBuf >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg_(std::map< sword::SWBuf,sword::SWBuf > *arg1) {
    delete arg1;
}

swig_class SwigClassAttributeListMap;

SWIGINTERN VALUE
_wrap_new_AttributeListMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::AttributeListMap";
  std::map< sword::SWBuf,AttributeValueMap > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,AttributeValueMap)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,AttributeValueMap)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,AttributeValueMap > *)new std::map< sword::SWBuf,AttributeValueMap >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.dup

  call-seq:
    dup -> AttributeListMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__has_key((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.each

  call-seq:
    each -> AttributeListMap

Iterate thru each element in the AttributeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.select

  call-seq:
    select -> AttributeListMap

Iterate thru each element in the AttributeListMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.each_key

  call-seq:
    each_key -> AttributeListMap

Iterate thru each key element in the AttributeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.each_value

  call-seq:
    each_value -> AttributeListMap

Iterate thru each key element in the AttributeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____getitem__((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  {
    std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *ptr = (std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)0;
    res3 = swig::asptr(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::mapped_type const &","__setitem__", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::mapped_type const &","__setitem__", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.to_a

  call-seq:
    to_a -> VALUE

Convert AttributeListMap to an Array.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_AttributeListMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::AttributeListMap";
  std::map< sword::SWBuf,AttributeValueMap > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,AttributeValueMap > *)new std::map< sword::SWBuf,AttributeValueMap >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AttributeListMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AttributeListMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AttributeListMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::AttributeListMap";
  std::map< sword::SWBuf,AttributeValueMap > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *ptr = (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const &","std::map<(sword::SWBuf,AttributeValueMap)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,AttributeValueMap > const &","std::map<(sword::SWBuf,AttributeValueMap)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,AttributeValueMap > *)new std::map< sword::SWBuf,AttributeValueMap >((std::map< sword::SWBuf,AttributeValueMap > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AttributeListMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_AttributeListMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeListMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeListMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "AttributeListMap.new", 
    "    AttributeListMap.new(std::less< sword::SWBuf > const &)\n"
    "    AttributeListMap.new()\n"
    "    AttributeListMap.new(std::map< sword::SWBuf,AttributeValueMap > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.empty?

  call-seq:
    empty? -> bool

Check if the AttributeListMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,AttributeValueMap > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.size

  call-seq:
    size -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::size_type

Size or Length of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = ((std::map< sword::SWBuf,AttributeValueMap > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.clear

  call-seq:
    clear

Clear AttributeListMap contents.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,AttributeValueMap > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,AttributeValueMap > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = ((std::map< sword::SWBuf,AttributeValueMap > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::allocator_type(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.begin

  call-seq:
    begin -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::iterator

Return an iterator to the beginning of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.end

  call-seq:
    end -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::iterator

Return an iterator to past the end of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.rbegin

  call-seq:
    rbegin -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::reverse_iterator

Return a reverse iterator to the beginning (the end) of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.rend

  call-seq:
    rend -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.erase

  call-seq:
    erase(x) -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::size_type
    erase(position)
    erase(first, last)

Delete a portion of the AttributeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,AttributeValueMap > const *)arg1)->count((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > arg2 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_AttributeListMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeListMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeListMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_AttributeListMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "AttributeListMap.erase", 
    "    void AttributeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &x)\n"
    "    void AttributeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator position)\n"
    "    void AttributeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator first, std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeListMap.find

  call-seq:
    find(x) -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>::iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_AttributeListMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeListMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeValueMap > *arg1 = (std::map< sword::SWBuf,AttributeValueMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeValueMap > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeValueMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg_(std::map< sword::SWBuf,AttributeValueMap > *arg1) {
    delete arg1;
}

swig_class SwigClassAttributeTypeListMap;

SWIGINTERN VALUE
_wrap_new_AttributeTypeListMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::AttributeTypeListMap";
  std::map< sword::SWBuf,AttributeListMap > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,AttributeListMap)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,AttributeListMap)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,AttributeListMap > *)new std::map< sword::SWBuf,AttributeListMap >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.dup

  call-seq:
    dup -> AttributeTypeListMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__has_key((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.each

  call-seq:
    each -> AttributeTypeListMap

Iterate thru each element in the AttributeTypeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.select

  call-seq:
    select -> AttributeTypeListMap

Iterate thru each element in the AttributeTypeListMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.each_key

  call-seq:
    each_key -> AttributeTypeListMap

Iterate thru each key element in the AttributeTypeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.each_value

  call-seq:
    each_value -> AttributeTypeListMap

Iterate thru each key element in the AttributeTypeListMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____getitem__((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  {
    std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *ptr = (std::map<sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *)0;
    res3 = swig::asptr(argv[1], &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::mapped_type const &","__setitem__", 3, argv[1] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::mapped_type const &","__setitem__", 3, argv[1])); 
    }
    arg3 = ptr;
  }
  try {
    std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.to_a

  call-seq:
    to_a -> VALUE

Convert AttributeTypeListMap to an Array.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_AttributeTypeListMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::AttributeTypeListMap";
  std::map< sword::SWBuf,AttributeListMap > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,AttributeListMap > *)new std::map< sword::SWBuf,AttributeListMap >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_AttributeTypeListMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_AttributeTypeListMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::AttributeTypeListMap";
  std::map< sword::SWBuf,AttributeListMap > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > *ptr = (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const &","std::map<(sword::SWBuf,AttributeListMap)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,AttributeListMap > const &","std::map<(sword::SWBuf,AttributeListMap)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,AttributeListMap > *)new std::map< sword::SWBuf,AttributeListMap >((std::map< sword::SWBuf,AttributeListMap > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_AttributeTypeListMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_AttributeTypeListMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeTypeListMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AttributeTypeListMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "AttributeTypeListMap.new", 
    "    AttributeTypeListMap.new(std::less< sword::SWBuf > const &)\n"
    "    AttributeTypeListMap.new()\n"
    "    AttributeTypeListMap.new(std::map< sword::SWBuf,AttributeListMap > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.empty?

  call-seq:
    empty? -> bool

Check if the AttributeTypeListMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,AttributeListMap > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.size

  call-seq:
    size -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::size_type

Size or Length of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = ((std::map< sword::SWBuf,AttributeListMap > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.clear

  call-seq:
    clear

Clear AttributeTypeListMap contents.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,AttributeListMap > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,AttributeListMap > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = ((std::map< sword::SWBuf,AttributeListMap > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::allocator_type(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.begin

  call-seq:
    begin -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::iterator

Return an iterator to the beginning of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.end

  call-seq:
    end -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::iterator

Return an iterator to past the end of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.rbegin

  call-seq:
    rbegin -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::reverse_iterator

Return a reverse iterator to the beginning (the end) of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.rend

  call-seq:
    rend -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.erase

  call-seq:
    erase(x) -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::size_type
    erase(position)
    erase(first, last)

Delete a portion of the AttributeTypeListMap.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,AttributeListMap > const *)arg1)->count((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > arg2 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_AttributeTypeListMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeTypeListMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_AttributeTypeListMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_AttributeTypeListMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "AttributeTypeListMap.erase", 
    "    void AttributeTypeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &x)\n"
    "    void AttributeTypeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator position)\n"
    "    void AttributeTypeListMap.erase(std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator first, std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::AttributeTypeListMap.find

  call-seq:
    find(x) -> std::map<(sword::SWBuf,std::map<(sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,std::map<(sword::SWBuf,sword::SWBuf,std::less<(sword::SWBuf)>,std::allocator<(std::pair<(q(const).sword::SWBuf,sword::SWBuf)>)>)>)>)>)>)>::iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_AttributeTypeListMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_AttributeTypeListMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,AttributeListMap > *arg1 = (std::map< sword::SWBuf,AttributeListMap > *) 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  SwigValueWrapper< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,AttributeListMap > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,AttributeListMap > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator(static_cast< const std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg_(std::map< sword::SWBuf,AttributeListMap > *arg1) {
    delete arg1;
}

swig_class SwigClassPySectionMap;

SWIGINTERN VALUE
_wrap_new_PySectionMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::PySectionMap";
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,std::multimap<(sword::SWBuf,sword::SWBuf)>)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,std::multimap<(sword::SWBuf,sword::SWBuf)>)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *)new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.dup

  call-seq:
    dup -> PySectionMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__has_key((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.each

  call-seq:
    each -> PySectionMap

Iterate thru each element in the PySectionMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.select

  call-seq:
    select -> PySectionMap

Iterate thru each element in the PySectionMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.each_key

  call-seq:
    each_key -> PySectionMap

Iterate thru each key element in the PySectionMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.each_value

  call-seq:
    each_value -> PySectionMap

Iterate thru each key element in the PySectionMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_PySectionMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____getitem__((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_PySectionMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapT_sword__SWBuf_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type const &","__setitem__", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type const &","__setitem__", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type * >(argp3);
  try {
    std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(std::multimap< sword::SWBuf,sword::SWBuf > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.to_a

  call-seq:
    to_a -> VALUE

Convert PySectionMap to an Array.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_PySectionMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::PySectionMap";
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *)new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PySectionMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PySectionMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PySectionMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::PySectionMap";
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *ptr = (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const &","std::map<(sword::SWBuf,std::multimap<(sword::SWBuf,sword::SWBuf)>)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const &","std::map<(sword::SWBuf,std::multimap<(sword::SWBuf,sword::SWBuf)>)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *)new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_PySectionMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_PySectionMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PySectionMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PySectionMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "PySectionMap.new", 
    "    PySectionMap.new(std::less< sword::SWBuf > const &)\n"
    "    PySectionMap.new()\n"
    "    PySectionMap.new(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.empty?

  call-seq:
    empty? -> bool

Check if the PySectionMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.size

  call-seq:
    size -> size_type

Size or Length of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = ((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.clear

  call-seq:
    clear

Clear PySectionMap contents.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = ((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::allocator_type(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.erase

  call-seq:
    erase(x) -> size_type
    erase(position)
    erase(first, last)

Delete a portion of the PySectionMap.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > const *)arg1)->count((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator arg2 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_PySectionMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_PySectionMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_PySectionMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_PySectionMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "PySectionMap.erase", 
    "    void PySectionMap.erase(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &x)\n"
    "    void PySectionMap.erase(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator position)\n"
    "    void PySectionMap.erase(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator first, std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::PySectionMap.find

  call-seq:
    find(x) -> iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_PySectionMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PySectionMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1 = (std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *) 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator(static_cast< const std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg_(std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *arg1) {
    delete arg1;
}

swig_class SwigClassModuleMap;

SWIGINTERN VALUE
_wrap_new_ModuleMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::ModuleMap";
  std::map< sword::SWBuf,sword::SWModule * > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,p.sword::SWModule)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,p.sword::SWModule)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule * > *)new std::map< sword::SWBuf,sword::SWModule * >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.dup

  call-seq:
    dup -> ModuleMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__has_key((std::map< sword::SWBuf,sword::SWModule * > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.each

  call-seq:
    each -> ModuleMap

Iterate thru each element in the ModuleMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.select

  call-seq:
    select -> ModuleMap

Iterate thru each element in the ModuleMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.each_key

  call-seq:
    each_key -> ModuleMap

Iterate thru each key element in the ModuleMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.each_value

  call-seq:
    each_value -> ModuleMap

Iterate thru each key element in the ModuleMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_ModuleMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____getitem__((std::map< sword::SWBuf,sword::SWModule * > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_ModuleMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::mapped_type temp3 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::mapped_type","__setitem__", 3, argv[1] )); 
  }
  temp3 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::mapped_type >(argp3);
  arg3 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::mapped_type * >(&temp3);
  try {
    std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(sword::SWModule *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.to_a

  call-seq:
    to_a -> VALUE

Convert ModuleMap to an Array.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ModuleMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::ModuleMap";
  std::map< sword::SWBuf,sword::SWModule * > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,sword::SWModule * > *)new std::map< sword::SWBuf,sword::SWModule * >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ModuleMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ModuleMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ModuleMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::ModuleMap";
  std::map< sword::SWBuf,sword::SWModule * > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *ptr = (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const &","std::map<(sword::SWBuf,p.sword::SWModule)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * > const &","std::map<(sword::SWBuf,p.sword::SWModule)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,sword::SWModule * > *)new std::map< sword::SWBuf,sword::SWModule * >((std::map< sword::SWBuf,sword::SWModule * > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ModuleMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ModuleMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModuleMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModuleMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ModuleMap.new", 
    "    ModuleMap.new(std::less< sword::SWBuf > const &)\n"
    "    ModuleMap.new()\n"
    "    ModuleMap.new(std::map< sword::SWBuf,sword::SWModule * > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.empty?

  call-seq:
    empty? -> bool

Check if the ModuleMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,sword::SWModule * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.size

  call-seq:
    size -> size_type

Size or Length of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::SWModule * > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.clear

  call-seq:
    clear

Clear ModuleMap contents.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::SWModule * > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::allocator_type(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.erase

  call-seq:
    erase(x) -> size_type
    erase(position)
    erase(first, last)

Delete a portion of the ModuleMap.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,sword::SWModule * >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,sword::SWModule * > const *)arg1)->count((std::map< sword::SWBuf,sword::SWModule * >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator arg2 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ModuleMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ModuleMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ModuleMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_ModuleMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "ModuleMap.erase", 
    "    void ModuleMap.erase(std::map< sword::SWBuf,sword::SWModule * >::key_type const &x)\n"
    "    void ModuleMap.erase(std::map< sword::SWBuf,sword::SWModule * >::iterator position)\n"
    "    void ModuleMap.erase(std::map< sword::SWBuf,sword::SWModule * >::iterator first, std::map< sword::SWBuf,sword::SWModule * >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::ModuleMap.find

  call-seq:
    find(x) -> iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_ModuleMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,sword::SWModule * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,sword::SWModule * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ModuleMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::SWModule * > *arg1 = (std::map< sword::SWBuf,sword::SWModule * > *) 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::SWModule * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::SWModule * >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::SWModule * >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,sword::SWModule * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::SWModule * >::iterator(static_cast< const std::map< sword::SWBuf,sword::SWModule * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg_(std::map< sword::SWBuf,sword::SWModule * > *arg1) {
    delete arg1;
}

swig_class SwigClassStringVector;


/*
  Document-method: Sword::StringVector.dup

  call-seq:
    dup -> StringVector

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_StringVector_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_StringVector_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.to_a

  call-seq:
    to_a -> VALUE

Convert StringVector to an Array.
*/
SWIGINTERN VALUE
_wrap_StringVector_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_StringVector_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  std::vector< sword::SWBuf >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","slice", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","slice", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","slice", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::SWBuf >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__slice(arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.each

  call-seq:
    each -> StringVector

Iterate thru each element in the StringVector.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringVector_each(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.select

  call-seq:
    select -> StringVector

Iterate thru each element in the StringVector and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringVector_select(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.reject!

  call-seq:
    reject! -> StringVector

Iterate thru each element in the StringVector and reject those that fail a condition.  A block must be provided.  StringVector is modified in place.
*/
SWIGINTERN VALUE
_wrap_StringVector_rejectN___(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","reject_bang", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE
_wrap_StringVector_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","delete_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","delete_at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__delete_at(arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector___delete2__(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","__delete2__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","__delete2__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","__delete2__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____delete2__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","pop", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__pop(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_push(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::vector< sword::SWBuf >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","push", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","push", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","push", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp2);
  result = std_vector_Sl_sword_SWBuf_Sg__push(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< sword::SWBuf >::value_type(static_cast< const std::vector< sword::SWBuf >::value_type& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.reject

  call-seq:
    reject -> StringVector

Iterate thru each element in the StringVector and reject those that fail a condition returning a new StringVector.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringVector_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","reject", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE
_wrap_StringVector_at(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__at((std::vector< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_StringVector___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  std::vector< sword::SWBuf >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__getitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::SWBuf >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_0((std::vector< sword::SWBuf > const *)arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_1((std::vector< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  VALUE arg2 = (VALUE) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  arg2 = argv[0];
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____getitem____SWIG_2((std::vector< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringVector___getitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_StringVector___getitem____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_StringVector___getitem____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_StringVector___getitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
    "    VALUE __getitem__(std::vector< sword::SWBuf >::difference_type i, std::vector< sword::SWBuf >::difference_type j)\n"
    "    VALUE __getitem__(std::vector< sword::SWBuf >::difference_type i)\n"
    "    VALUE __getitem__(VALUE i)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringVector.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_StringVector___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  std::vector< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","__setitem__", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","__setitem__", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____setitem____SWIG_0(arg1,arg2,(sword::SWBuf const &)*arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  std::vector< sword::SWBuf >::difference_type arg3 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::SWBuf >::difference_type >(val3);
  {
    std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > *ptr = (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > *)0;
    res4 = swig::asptr(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > const &","__setitem__", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > const &","__setitem__", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  try {
    result = (VALUE)std_vector_Sl_sword_SWBuf_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > const &)*arg4);
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringVector___setitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringVector___setitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = swig::asptr(argv[3], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_StringVector___setitem____SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
    "    VALUE __setitem__(std::vector< sword::SWBuf >::difference_type i, std::vector< sword::SWBuf >::value_type const &x)\n"
    "    VALUE __setitem__(std::vector< sword::SWBuf >::difference_type i, std::vector< sword::SWBuf >::difference_type j, std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > const &v)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringVector.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","shift", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_SWBuf_Sg__shift(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.insert

  call-seq:
    insert(pos, argc, ?) -> StringVector
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::difference_type arg2 ;
  int arg3 ;
  VALUE *arg4 = (VALUE *) 0 ;
  void *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::difference_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::difference_type >(val2);
  {
    arg3 = argc - 1;
    arg4 = argv + 1;
  }
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.unshift

  call-seq:
    unshift(argc, ?) -> StringVector

Add one or more elements at the beginning of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","unshift", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_vector_Sl_sword_SWBuf_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::StringVector";
  std::vector< sword::SWBuf > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector< sword::SWBuf > *)new std::vector< sword::SWBuf >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::StringVector";
  std::vector< sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > *ptr = (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const &","std::vector<(sword::SWBuf)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf > const &","std::vector<(sword::SWBuf)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::vector< sword::SWBuf > *)new std::vector< sword::SWBuf >((std::vector< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: Sword::StringVector.empty?

  call-seq:
    empty? -> bool

Check if the StringVector is empty or not.
*/
SWIGINTERN VALUE
_wrap_StringVector_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (bool)((std::vector< sword::SWBuf > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.size

  call-seq:
    size -> size_type

Size or Length of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_size(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = ((std::vector< sword::SWBuf > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.clear

  call-seq:
    clear

Clear StringVector contents.
*/
SWIGINTERN VALUE
_wrap_StringVector_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< sword::SWBuf > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = ((std::vector< sword::SWBuf > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< sword::SWBuf >::allocator_type(static_cast< const std::vector< sword::SWBuf >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_sword__SWBuf_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_end(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf >::size_type arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::StringVector";
  std::vector< sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","std::vector<(sword::SWBuf)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::vector< sword::SWBuf >::size_type >(val1);
  result = (std::vector< sword::SWBuf > *)new std::vector< sword::SWBuf >(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::size_type >(val2);
  (arg1)->resize(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  std::vector< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 2, argv[0] ));
    }
  }
  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::iterator arg2 ;
  std::vector< sword::SWBuf >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  std::vector< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","erase", 3, argv[1] ));
    }
  }
  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringVector_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_StringVector_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_StringVector_erase__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringVector.erase", 
    "    std::vector< sword::SWBuf >::iterator StringVector.erase(std::vector< sword::SWBuf >::iterator pos)\n"
    "    std::vector< sword::SWBuf >::iterator StringVector.erase(std::vector< sword::SWBuf >::iterator first, std::vector< sword::SWBuf >::iterator last)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_StringVector_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_StringVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_StringVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf >::size_type arg1 ;
  std::vector< sword::SWBuf >::value_type *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::StringVector";
  std::vector< sword::SWBuf > *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","std::vector<(sword::SWBuf)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::vector< sword::SWBuf >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","std::vector<(sword::SWBuf)>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","std::vector<(sword::SWBuf)>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp2);
  result = (std::vector< sword::SWBuf > *)new std::vector< sword::SWBuf >(arg1,(std::vector< sword::SWBuf >::value_type const &)*arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_StringVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_StringVector__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_StringVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StringVector__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_StringVector__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StringVector.new", 
    "    StringVector.new()\n"
    "    StringVector.new(std::vector< sword::SWBuf > const &)\n"
    "    StringVector.new(std::vector< sword::SWBuf >::size_type size)\n"
    "    StringVector.new(std::vector< sword::SWBuf >::size_type size, std::vector< sword::SWBuf >::value_type const &value)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringVector.front

  call-seq:
    front -> value_type

Return the first element in StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_front(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","front", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf >::value_type *) &((std::vector< sword::SWBuf > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.back

  call-seq:
    back -> value_type

Return the last element in StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_back(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","back", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = (std::vector< sword::SWBuf >::value_type *) &((std::vector< sword::SWBuf > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.assign

  call-seq:
    assign(n, x)

Assign a new StringVector or portion of it.
*/
SWIGINTERN VALUE
_wrap_StringVector_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::size_type arg2 ;
  std::vector< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","assign", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","assign", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","assign", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< sword::SWBuf >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::size_type arg2 ;
  std::vector< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","resize", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","resize", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< sword::SWBuf >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringVector_resize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_StringVector_resize__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringVector_resize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringVector.resize", 
    "    void StringVector.resize(std::vector< sword::SWBuf >::size_type new_size)\n"
    "    void StringVector.resize(std::vector< sword::SWBuf >::size_type new_size, std::vector< sword::SWBuf >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringVector.insert

  call-seq:
    insert(pos, argc, ?) -> StringVector
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::iterator arg2 ;
  std::vector< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  void *argp3 ;
  int res3 = 0 ;
  std::vector< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","insert", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< sword::SWBuf >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringVector_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::iterator arg2 ;
  std::vector< sword::SWBuf >::size_type arg3 ;
  std::vector< sword::SWBuf >::value_type *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::iterator","insert", 2, argv[0] ));
    }
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::SWBuf >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::value_type const &","insert", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::SWBuf >::value_type const &","insert", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< sword::SWBuf >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< sword::SWBuf >::value_type const &)*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringVector_insert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringVector_insert__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          if (argc <= 3) {
            return _wrap_StringVector_insert__SWIG_0(nargs, args, self);
          }
          return _wrap_StringVector_insert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_StringVector_insert__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "insert", 
    "    void insert(std::vector< sword::SWBuf >::difference_type pos, int argc, VALUE *argv, ...)\n"
    "    void insert(std::vector< sword::SWBuf >::iterator pos, std::vector< sword::SWBuf >::value_type const &x)\n"
    "    void insert(std::vector< sword::SWBuf >::iterator pos, std::vector< sword::SWBuf >::size_type n, std::vector< sword::SWBuf >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringVector.reserve

  call-seq:
    reserve(n)

Reserve memory in the StringVector for a number of elements.
*/
SWIGINTERN VALUE
_wrap_StringVector_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  std::vector< sword::SWBuf >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > *","reserve", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf >::size_type","reserve", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::SWBuf >::size_type >(val2);
  (arg1)->reserve(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringVector.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the StringVector.
*/
SWIGINTERN VALUE
_wrap_StringVector_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::SWBuf > *arg1 = (std::vector< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::SWBuf > const *","capacity", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::SWBuf > * >(argp1);
  result = ((std::vector< sword::SWBuf > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_sword_SWBuf_Sg_(std::vector< sword::SWBuf > *arg1) {
    delete arg1;
}

swig_class SwigClassStringList;


/*
  Document-method: Sword::StringList.dup

  call-seq:
    dup -> StringList

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_StringList_dup(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_list_Sl_sword_SWBuf_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_StringList_inspect(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.to_a

  call-seq:
    to_a -> VALUE

Convert StringList to an Array.
*/
SWIGINTERN VALUE
_wrap_StringList_to_a(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_StringList_to_s(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_slice(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  std::list< sword::SWBuf >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","slice", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","slice", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","slice", 3, argv[1] ));
  } 
  arg3 = static_cast< std::list< sword::SWBuf >::difference_type >(val3);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__slice(arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.each

  call-seq:
    each -> StringList

Iterate thru each element in the StringList.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringList_each(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_list_Sl_sword_SWBuf_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.select

  call-seq:
    select -> StringList

Iterate thru each element in the StringList and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringList_select(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_list_Sl_sword_SWBuf_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.reject!

  call-seq:
    reject! -> StringList

Iterate thru each element in the StringList and reject those that fail a condition.  A block must be provided.  StringList is modified in place.
*/
SWIGINTERN VALUE
_wrap_StringList_rejectN___(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","reject_bang", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_list_Sl_sword_SWBuf_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE
_wrap_StringList_delete_at(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","delete_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","delete_at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__delete_at(arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList___delete2__(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","__delete2__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","__delete2__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","__delete2__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp2);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg____delete2__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_pop(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","pop", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__pop(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_push(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::list< sword::SWBuf >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","push", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","push", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","push", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp2);
  result = std_list_Sl_sword_SWBuf_Sg__push(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::list< sword::SWBuf >::value_type(static_cast< const std::list< sword::SWBuf >::value_type& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.reject

  call-seq:
    reject -> StringList

Iterate thru each element in the StringList and reject those that fail a condition returning a new StringList.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_StringList_reject(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","reject", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *)std_list_Sl_sword_SWBuf_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE
_wrap_StringList_at(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg__at((std::list< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_StringList___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  std::list< sword::SWBuf >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__getitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::list< sword::SWBuf >::difference_type >(val3);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_0((std::list< sword::SWBuf > const *)arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_1((std::list< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  VALUE arg2 = (VALUE) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  arg2 = argv[0];
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg____getitem____SWIG_2((std::list< sword::SWBuf > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringList___getitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_StringList___getitem____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_StringList___getitem____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_StringList___getitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
    "    VALUE __getitem__(std::list< sword::SWBuf >::difference_type i, std::list< sword::SWBuf >::difference_type j)\n"
    "    VALUE __getitem__(std::list< sword::SWBuf >::difference_type i)\n"
    "    VALUE __getitem__(VALUE i)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringList.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_StringList___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  std::list< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","__setitem__", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","__setitem__", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp3);
  result = (VALUE)std_list_Sl_sword_SWBuf_Sg____setitem____SWIG_0(arg1,arg2,(sword::SWBuf const &)*arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::difference_type arg2 ;
  std::list< sword::SWBuf >::difference_type arg3 ;
  std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::difference_type","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::list< sword::SWBuf >::difference_type >(val3);
  {
    std::list<sword::SWBuf,std::allocator< sword::SWBuf > > *ptr = (std::list<sword::SWBuf,std::allocator< sword::SWBuf > > *)0;
    res4 = swig::asptr(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::list< sword::SWBuf,std::allocator< sword::SWBuf > > const &","__setitem__", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf,std::allocator< sword::SWBuf > > const &","__setitem__", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  try {
    result = (VALUE)std_list_Sl_sword_SWBuf_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::list< sword::SWBuf,std::allocator< sword::SWBuf > > const &)*arg4);
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringList___setitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringList___setitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = swig::asptr(argv[3], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_StringList___setitem____SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
    "    VALUE __setitem__(std::list< sword::SWBuf >::difference_type i, std::list< sword::SWBuf >::value_type const &x)\n"
    "    VALUE __setitem__(std::list< sword::SWBuf >::difference_type i, std::list< sword::SWBuf >::difference_type j, std::list< sword::SWBuf,std::allocator< sword::SWBuf > > const &v)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringList__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::StringList";
  std::list< sword::SWBuf > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::list< sword::SWBuf > *)new std::list< sword::SWBuf >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringList__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::StringList";
  std::list< sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::list<sword::SWBuf,std::allocator< sword::SWBuf > > *ptr = (std::list<sword::SWBuf,std::allocator< sword::SWBuf > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const &","std::list<(sword::SWBuf)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf > const &","std::list<(sword::SWBuf)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::list< sword::SWBuf > *)new std::list< sword::SWBuf >((std::list< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: Sword::StringList.empty?

  call-seq:
    empty? -> bool

Check if the StringList is empty or not.
*/
SWIGINTERN VALUE
_wrap_StringList_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (bool)((std::list< sword::SWBuf > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.size

  call-seq:
    size -> size_type

Size or Length of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_size(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = ((std::list< sword::SWBuf > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.clear

  call-seq:
    clear

Clear StringList contents.
*/
SWIGINTERN VALUE
_wrap_StringList_clear(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList_swap(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::list< sword::SWBuf > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< sword::SWBuf > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = ((std::list< sword::SWBuf > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::list< sword::SWBuf >::allocator_type(static_cast< const std::list< sword::SWBuf >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_sword__SWBuf_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_begin(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_end(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_rbegin(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_rend(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_StringList__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf >::size_type arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::StringList";
  std::list< sword::SWBuf > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","std::list<(sword::SWBuf)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::list< sword::SWBuf >::size_type >(val1);
  result = (std::list< sword::SWBuf > *)new std::list< sword::SWBuf >(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::size_type >(val2);
  (arg1)->resize(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  std::list< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::list< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 2, argv[0] ));
    }
  }
  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::iterator arg2 ;
  std::list< sword::SWBuf >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  std::list< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::list< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::list< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","erase", 3, argv[1] ));
    }
  }
  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringList_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_StringList_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_StringList_erase__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringList.erase", 
    "    std::list< sword::SWBuf >::iterator StringList.erase(std::list< sword::SWBuf >::iterator pos)\n"
    "    std::list< sword::SWBuf >::iterator StringList.erase(std::list< sword::SWBuf >::iterator first, std::list< sword::SWBuf >::iterator last)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_StringList_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_StringList_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_StringList__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf >::size_type arg1 ;
  std::list< sword::SWBuf >::value_type *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::StringList";
  std::list< sword::SWBuf > *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","std::list<(sword::SWBuf)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::list< sword::SWBuf >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","std::list<(sword::SWBuf)>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","std::list<(sword::SWBuf)>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp2);
  result = (std::list< sword::SWBuf > *)new std::list< sword::SWBuf >(arg1,(std::list< sword::SWBuf >::value_type const &)*arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_StringList(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_StringList__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_StringList__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StringList__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_StringList__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "StringList.new", 
    "    StringList.new()\n"
    "    StringList.new(std::list< sword::SWBuf > const &)\n"
    "    StringList.new(std::list< sword::SWBuf >::size_type size)\n"
    "    StringList.new(std::list< sword::SWBuf >::size_type size, std::list< sword::SWBuf >::value_type const &value)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringList.front

  call-seq:
    front -> value_type

Return the first element in StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_front(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","front", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf >::value_type *) &((std::list< sword::SWBuf > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.back

  call-seq:
    back -> value_type

Return the last element in StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_back(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::list< sword::SWBuf >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > const *","back", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  result = (std::list< sword::SWBuf >::value_type *) &((std::list< sword::SWBuf > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.assign

  call-seq:
    assign(n, x)

Assign a new StringList or portion of it.
*/
SWIGINTERN VALUE
_wrap_StringList_assign(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::size_type arg2 ;
  std::list< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","assign", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","assign", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","assign", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::list< sword::SWBuf >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::size_type arg2 ;
  std::list< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::list< sword::SWBuf >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","resize", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","resize", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::list< sword::SWBuf >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringList_resize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_StringList_resize__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringList_resize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringList.resize", 
    "    void StringList.resize(std::list< sword::SWBuf >::size_type new_size)\n"
    "    void StringList.resize(std::list< sword::SWBuf >::size_type new_size, std::list< sword::SWBuf >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringList.insert

  call-seq:
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::iterator arg2 ;
  std::list< sword::SWBuf >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  void *argp3 ;
  int res3 = 0 ;
  std::list< sword::SWBuf >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::list< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","insert", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::list< sword::SWBuf >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::list< sword::SWBuf >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::iterator arg2 ;
  std::list< sword::SWBuf >::size_type arg3 ;
  std::list< sword::SWBuf >::value_type *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::list< sword::SWBuf >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::iterator","insert", 2, argv[0] ));
    }
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::list< sword::SWBuf >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","insert", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","insert", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::list< sword::SWBuf >::value_type const &)*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringList_insert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_StringList_insert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::list<sword::SWBuf,std::allocator< sword::SWBuf > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::list< sword::SWBuf >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_StringList_insert__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "StringList.insert", 
    "    void StringList.insert(std::list< sword::SWBuf >::iterator pos, std::list< sword::SWBuf >::value_type const &x)\n"
    "    void StringList.insert(std::list< sword::SWBuf >::iterator pos, std::list< sword::SWBuf >::size_type n, std::list< sword::SWBuf >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::StringList.pop_front

  call-seq:
    pop_front

Remove and return element at the beginning of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_pop_front(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","pop_front", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  (arg1)->pop_front();
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::StringList.push_front

  call-seq:
    push_front(x)

Add an element at the beginning of the StringList.
*/
SWIGINTERN VALUE
_wrap_StringList_push_front(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  std::list< sword::SWBuf >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","push_front", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::list< sword::SWBuf >::value_type const &","push_front", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::list< sword::SWBuf >::value_type const &","push_front", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::list< sword::SWBuf >::value_type * >(argp2);
  (arg1)->push_front((std::list< sword::SWBuf >::value_type const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringList_reverse(int argc, VALUE *argv, VALUE self) {
  std::list< sword::SWBuf > *arg1 = (std::list< sword::SWBuf > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::list< sword::SWBuf > *","reverse", 1, self )); 
  }
  arg1 = reinterpret_cast< std::list< sword::SWBuf > * >(argp1);
  (arg1)->reverse();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_list_Sl_sword_SWBuf_Sg_(std::list< sword::SWBuf > *arg1) {
    delete arg1;
}

swig_class SwigClassInstallSourceMap;

SWIGINTERN VALUE
_wrap_new_InstallSourceMap__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::less< sword::SWBuf > *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallSourceMap";
  std::map< sword::SWBuf,sword::InstallSource * > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__lessT_sword__SWBuf_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,p.sword::InstallSource)>", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::less< sword::SWBuf > const &","std::map<(sword::SWBuf,p.sword::InstallSource)>", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< std::less< sword::SWBuf > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource * > *)new std::map< sword::SWBuf,sword::InstallSource * >((std::less< sword::SWBuf > const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.dup

  call-seq:
    dup -> InstallSourceMap

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_dup(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.delete

  call-seq:
    delete(key) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_delete(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","__delete__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__delete__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__delete__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____delete__(arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_has_keyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","has_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","has_key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","has_key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__has_key((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.keys

  call-seq:
    keys -> VALUE

Return an Array of key elements.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_keys(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","keys", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__keys(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.each

  call-seq:
    each -> InstallSourceMap

Iterate thru each element in the InstallSourceMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_each(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.select

  call-seq:
    select -> InstallSourceMap

Iterate thru each element in the InstallSourceMap and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_select(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.values_at

  call-seq:
    values_at(argc, ?) -> VALUE

Return an Array of value elements matching the conditions.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_values_at(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","values_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__values_at(arg1,arg2,arg3,arg4);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.each_key

  call-seq:
    each_key -> InstallSourceMap

Iterate thru each key element in the InstallSourceMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_each_key(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","each_key", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each_key(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.values

  call-seq:
    values -> VALUE

Return an Array of value elements.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_values(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","values", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__values(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.each_value

  call-seq:
    each_value -> InstallSourceMap

Iterate thru each key element in the InstallSourceMap.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_each_value(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","each_value", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__each_value(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_entries(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","entries", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__entries(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_includeq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","__contains__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__contains__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__contains__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (bool)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____contains__(arg1,(sword::SWBuf const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_key_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","key_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__key_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_value_iterator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  VALUE *arg2 = (VALUE *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil;
  
  arg2 = &self;
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","value_iterator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (swig::ConstIterator *)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__value_iterator(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.[]

  call-seq:
    [](key) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap___getitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__getitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__getitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____getitem__((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1,(sword::SWBuf const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.[]=

  call-seq:
    []=(key, x)

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap___setitem__(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::mapped_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::mapped_type temp3 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__setitem__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","__setitem__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::mapped_type","__setitem__", 3, argv[1] )); 
  }
  temp3 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::mapped_type >(argp3);
  arg3 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::mapped_type * >(&temp3);
  try {
    std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg____setitem__(arg1,(sword::SWBuf const &)*arg2,(sword::InstallSource *const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_inspect(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.to_a

  call-seq:
    to_a -> VALUE

Convert InstallSourceMap to an Array.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_to_a(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_to_s(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (VALUE)std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InstallSourceMap__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::InstallSourceMap";
  std::map< sword::SWBuf,sword::InstallSource * > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::map< sword::SWBuf,sword::InstallSource * > *)new std::map< sword::SWBuf,sword::InstallSource * >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InstallSourceMap_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InstallSourceMap_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InstallSourceMap__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::InstallSourceMap";
  std::map< sword::SWBuf,sword::InstallSource * > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *ptr = (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const &","std::map<(sword::SWBuf,p.sword::InstallSource)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * > const &","std::map<(sword::SWBuf,p.sword::InstallSource)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::map< sword::SWBuf,sword::InstallSource * > *)new std::map< sword::SWBuf,sword::InstallSource * >((std::map< sword::SWBuf,sword::InstallSource * > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InstallSourceMap(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InstallSourceMap__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__lessT_sword__SWBuf_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InstallSourceMap__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InstallSourceMap__SWIG_2(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "InstallSourceMap.new", 
    "    InstallSourceMap.new(std::less< sword::SWBuf > const &)\n"
    "    InstallSourceMap.new()\n"
    "    InstallSourceMap.new(std::map< sword::SWBuf,sword::InstallSource * > const &)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.empty?

  call-seq:
    empty? -> bool

Check if the InstallSourceMap is empty or not.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (bool)((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.size

  call-seq:
    size -> size_type

Size or Length of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_size(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.clear

  call-seq:
    clear

Clear InstallSourceMap contents.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_clear(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_swap(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = ((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::allocator_type(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_begin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_end(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_rbegin(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_rend(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.erase

  call-seq:
    erase(x) -> size_type
    erase(position)
    erase(first, last)

Delete a portion of the InstallSourceMap.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","erase", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","erase", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (arg1)->erase((std::map< sword::SWBuf,sword::InstallSource * >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_count(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > const *","count", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","count", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","count", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = ((std::map< sword::SWBuf,sword::InstallSource * > const *)arg1)->count((std::map< sword::SWBuf,sword::InstallSource * >::key_type const &)*arg2);
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::iterator * >(argp2));
    }
  }
  (arg1)->erase(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_erase__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator arg2 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::iterator * >(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::iterator","erase", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::iterator * >(argp3));
    }
  }
  (arg1)->erase(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_InstallSourceMap_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_InstallSourceMap_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_InstallSourceMap_erase__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::map<sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_InstallSourceMap_erase__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "InstallSourceMap.erase", 
    "    void InstallSourceMap.erase(std::map< sword::SWBuf,sword::InstallSource * >::key_type const &x)\n"
    "    void InstallSourceMap.erase(std::map< sword::SWBuf,sword::InstallSource * >::iterator position)\n"
    "    void InstallSourceMap.erase(std::map< sword::SWBuf,sword::InstallSource * >::iterator first, std::map< sword::SWBuf,sword::InstallSource * >::iterator last)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::InstallSourceMap.find

  call-seq:
    find(x) -> iterator

Find an element in the class.
*/
SWIGINTERN VALUE
_wrap_InstallSourceMap_find(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","find", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","find", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","find", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (arg1)->find((std::map< sword::SWBuf,sword::InstallSource * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_lower_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","lower_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","lower_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","lower_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (arg1)->lower_bound((std::map< sword::SWBuf,sword::InstallSource * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSourceMap_upper_bound(int argc, VALUE *argv, VALUE self) {
  std::map< sword::SWBuf,sword::InstallSource * > *arg1 = (std::map< sword::SWBuf,sword::InstallSource * > *) 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::key_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWBuf,sword::InstallSource * >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * > *","upper_bound", 1, self )); 
  }
  arg1 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","upper_bound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< sword::SWBuf,sword::InstallSource * >::key_type const &","upper_bound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::map< sword::SWBuf,sword::InstallSource * >::key_type * >(argp2);
  result = (arg1)->upper_bound((std::map< sword::SWBuf,sword::InstallSource * >::key_type const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::map< sword::SWBuf,sword::InstallSource * >::iterator(static_cast< const std::map< sword::SWBuf,sword::InstallSource * >::iterator& >(result))), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg_(std::map< sword::SWBuf,sword::InstallSource * > *arg1) {
    delete arg1;
}

swig_class SwigClassDirEntryVector;


/*
  Document-method: Sword::DirEntryVector.dup

  call-seq:
    dup -> DirEntryVector

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","dup", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","inspect", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__inspect(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.to_a

  call-seq:
    to_a -> VALUE

Convert DirEntryVector to an Array.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","to_a", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__to_a(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","to_s", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__to_s(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  std::vector< sword::DirEntry >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","slice", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","slice", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","slice", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::DirEntry >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__slice(arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.each

  call-seq:
    each -> DirEntryVector

Iterate thru each element in the DirEntryVector.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_each(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","each", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.select

  call-seq:
    select -> DirEntryVector

Iterate thru each element in the DirEntryVector and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_select(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","select", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.reject!

  call-seq:
    reject! -> DirEntryVector

Iterate thru each element in the DirEntryVector and reject those that fail a condition.  A block must be provided.  DirEntryVector is modified in place.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_rejectN___(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","reject_bang", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","delete_at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","delete_at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__delete_at(arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector___delete2__(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","__delete2__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","__delete2__", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","__delete2__", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____delete2__(arg1,(sword::DirEntry const &)*arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","pop", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__pop(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_push(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::vector< sword::DirEntry >::value_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","push", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","push", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","push", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp2);
  result = std_vector_Sl_sword_DirEntry_Sg__push(arg1,(sword::DirEntry const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< sword::DirEntry >::value_type(static_cast< const std::vector< sword::DirEntry >::value_type& >(result))), SWIGTYPE_p_sword__DirEntry, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.reject

  call-seq:
    reject -> DirEntryVector

Iterate thru each element in the DirEntryVector and reject those that fail a condition returning a new DirEntryVector.  A block must be provided.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","reject", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_at(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","at", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","at", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__at((std::vector< sword::DirEntry > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  std::vector< sword::DirEntry >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__getitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::DirEntry >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_0((std::vector< sword::DirEntry > const *)arg1,arg2,arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__getitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_1((std::vector< sword::DirEntry > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  VALUE arg2 = (VALUE) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","__getitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  arg2 = argv[0];
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____getitem____SWIG_2((std::vector< sword::DirEntry > const *)arg1,arg2);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DirEntryVector___getitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DirEntryVector___getitem____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_DirEntryVector___getitem____SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_DirEntryVector___getitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
    "    VALUE __getitem__(std::vector< sword::DirEntry >::difference_type i, std::vector< sword::DirEntry >::difference_type j)\n"
    "    VALUE __getitem__(std::vector< sword::DirEntry >::difference_type i)\n"
    "    VALUE __getitem__(VALUE i)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  std::vector< sword::DirEntry >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","__setitem__", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","__setitem__", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____setitem____SWIG_0(arg1,arg2,(sword::DirEntry const &)*arg3);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  std::vector< sword::DirEntry >::difference_type arg3 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","__setitem__", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__setitem__", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","__setitem__", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::DirEntry >::difference_type >(val3);
  {
    std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > *ptr = (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > *)0;
    res4 = swig::asptr(argv[2], &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > const &","__setitem__", 4, argv[2] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > const &","__setitem__", 4, argv[2])); 
    }
    arg4 = ptr;
  }
  try {
    result = (VALUE)std_vector_Sl_sword_DirEntry_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > const &)*arg4);
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return vresult;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_DirEntryVector___setitem__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__DirEntry, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DirEntryVector___setitem____SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = swig::asptr(argv[3], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DirEntryVector___setitem____SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
    "    VALUE __setitem__(std::vector< sword::DirEntry >::difference_type i, std::vector< sword::DirEntry >::value_type const &x)\n"
    "    VALUE __setitem__(std::vector< sword::DirEntry >::difference_type i, std::vector< sword::DirEntry >::difference_type j, std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > const &v)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VALUE result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","shift", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (VALUE)std_vector_Sl_sword_DirEntry_Sg__shift(arg1);
  vresult = result;
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.insert

  call-seq:
    insert(pos, argc, ?) -> DirEntryVector
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::difference_type arg2 ;
  int arg3 ;
  VALUE *arg4 = (VALUE *) 0 ;
  void *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::difference_type","insert", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::difference_type >(val2);
  {
    arg3 = argc - 1;
    arg4 = argv + 1;
  }
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.unshift

  call-seq:
    unshift(argc, ?) -> DirEntryVector

Add one or more elements at the beginning of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","unshift", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  {
    arg2 = argc;
    arg3 = argv;
  }
  result = (std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *)std_vector_Sl_sword_DirEntry_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DirEntryVector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::DirEntryVector";
  std::vector< sword::DirEntry > *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (std::vector< sword::DirEntry > *)new std::vector< sword::DirEntry >();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DirEntryVector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  const char *classname SWIGUNUSED = "Sword::DirEntryVector";
  std::vector< sword::DirEntry > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  {
    std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > *ptr = (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > *)0;
    res1 = swig::asptr(argv[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const &","std::vector<(sword::DirEntry)>", 1, argv[0] )); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry > const &","std::vector<(sword::DirEntry)>", 1, argv[0])); 
    }
    arg1 = ptr;
  }
  result = (std::vector< sword::DirEntry > *)new std::vector< sword::DirEntry >((std::vector< sword::DirEntry > const &)*arg1);
  DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1;
  return self;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.empty?

  call-seq:
    empty? -> bool

Check if the DirEntryVector is empty or not.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_emptyq___(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","empty", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (bool)((std::vector< sword::DirEntry > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.size

  call-seq:
    size -> size_type

Size or Length of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_size(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = ((std::vector< sword::DirEntry > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.clear

  call-seq:
    clear

Clear DirEntryVector contents.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","swap", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > &","swap", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry > &","swap", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp2);
  (arg1)->swap(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< std::allocator< sword::DirEntry > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","get_allocator", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = ((std::vector< sword::DirEntry > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< sword::DirEntry >::allocator_type(static_cast< const std::vector< sword::DirEntry >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_sword__DirEntry_t, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.begin

  call-seq:
    begin -> iterator

Return an iterator to the beginning of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","begin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.end

  call-seq:
    end -> iterator

Return an iterator to past the end of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_end(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","end", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.rbegin

  call-seq:
    rbegin -> reverse_iterator

Return a reverse iterator to the beginning (the end) of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","rbegin", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.rend

  call-seq:
    rend -> reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::reverse_iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","rend", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::reverse_iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_DirEntryVector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry >::size_type arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::DirEntryVector";
  std::vector< sword::DirEntry > *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","std::vector<(sword::DirEntry)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::vector< sword::DirEntry >::size_type >(val1);
  result = (std::vector< sword::DirEntry > *)new std::vector< sword::DirEntry >(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::size_type >(val2);
  (arg1)->resize(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  std::vector< sword::DirEntry >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 2, argv[0] ));
    }
  }
  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::iterator arg2 ;
  std::vector< sword::DirEntry >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  swig::Iterator *iter3 = 0 ;
  int res3 ;
  std::vector< sword::DirEntry >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","erase", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 3, argv[1] ));
  } else {
    swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","erase", 3, argv[1] ));
    }
  }
  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DirEntryVector_erase(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_DirEntryVector_erase__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter) != 0));
      if (_v) {
        swig::ConstIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), 
          swig::Iterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_DirEntryVector_erase__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DirEntryVector.erase", 
    "    std::vector< sword::DirEntry >::iterator DirEntryVector.erase(std::vector< sword::DirEntry >::iterator pos)\n"
    "    std::vector< sword::DirEntry >::iterator DirEntryVector.erase(std::vector< sword::DirEntry >::iterator first, std::vector< sword::DirEntry >::iterator last)\n");
  
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DirEntryVector_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DirEntryVector_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DirEntryVector__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry >::size_type arg1 ;
  std::vector< sword::DirEntry >::value_type *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::DirEntryVector";
  std::vector< sword::DirEntry > *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","std::vector<(sword::DirEntry)>", 1, argv[0] ));
  } 
  arg1 = static_cast< std::vector< sword::DirEntry >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","std::vector<(sword::DirEntry)>", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","std::vector<(sword::DirEntry)>", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp2);
  result = (std::vector< sword::DirEntry > *)new std::vector< sword::DirEntry >(arg1,(std::vector< sword::DirEntry >::value_type const &)*arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_DirEntryVector(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_DirEntryVector__SWIG_0(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_DirEntryVector__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DirEntryVector__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__DirEntry, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_DirEntryVector__SWIG_3(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "DirEntryVector.new", 
    "    DirEntryVector.new()\n"
    "    DirEntryVector.new(std::vector< sword::DirEntry > const &)\n"
    "    DirEntryVector.new(std::vector< sword::DirEntry >::size_type size)\n"
    "    DirEntryVector.new(std::vector< sword::DirEntry >::size_type size, std::vector< sword::DirEntry >::value_type const &value)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.front

  call-seq:
    front -> value_type

Return the first element in DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_front(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","front", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry >::value_type *) &((std::vector< sword::DirEntry > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.back

  call-seq:
    back -> value_type

Return the last element in DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_back(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::value_type *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","back", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = (std::vector< sword::DirEntry >::value_type *) &((std::vector< sword::DirEntry > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.assign

  call-seq:
    assign(n, x)

Assign a new DirEntryVector or portion of it.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::size_type arg2 ;
  std::vector< sword::DirEntry >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","assign", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","assign", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","assign", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","assign", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< sword::DirEntry >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::size_type arg2 ;
  std::vector< sword::DirEntry >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","resize", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","resize", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","resize", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","resize", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< sword::DirEntry >::value_type const &)*arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DirEntryVector_resize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_DirEntryVector_resize__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__DirEntry, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DirEntryVector_resize__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "DirEntryVector.resize", 
    "    void DirEntryVector.resize(std::vector< sword::DirEntry >::size_type new_size)\n"
    "    void DirEntryVector.resize(std::vector< sword::DirEntry >::size_type new_size, std::vector< sword::DirEntry >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.insert

  call-seq:
    insert(pos, argc, ?) -> DirEntryVector
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::iterator arg2 ;
  std::vector< sword::DirEntry >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  void *argp3 ;
  int res3 = 0 ;
  std::vector< sword::DirEntry >::iterator result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","insert", 2, argv[0] ));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","insert", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","insert", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< sword::DirEntry >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< sword::DirEntry >::iterator & >(result),
      self),
    swig::Iterator::descriptor(),SWIG_POINTER_OWN);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntryVector_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::iterator arg2 ;
  std::vector< sword::DirEntry >::size_type arg3 ;
  std::vector< sword::DirEntry >::value_type *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::Iterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","insert", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","insert", 2, argv[0] ));
  } else {
    swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::iterator","insert", 2, argv[0] ));
    }
  }
  ecode3 = SWIG_AsVal_size_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","insert", 3, argv[1] ));
  } 
  arg3 = static_cast< std::vector< sword::DirEntry >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_sword__DirEntry,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::value_type const &","insert", 4, argv[2] )); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< sword::DirEntry >::value_type const &","insert", 4, argv[2])); 
  }
  arg4 = reinterpret_cast< std::vector< sword::DirEntry >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< sword::DirEntry >::value_type const &)*arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_DirEntryVector_insert(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter) != 0));
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__DirEntry, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DirEntryVector_insert__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          if (argc <= 3) {
            return _wrap_DirEntryVector_insert__SWIG_0(nargs, args, self);
          }
          return _wrap_DirEntryVector_insert__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<sword::DirEntry,std::allocator< sword::DirEntry > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::ConstIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
        swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< sword::DirEntry >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__DirEntry, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_DirEntryVector_insert__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "insert", 
    "    void insert(std::vector< sword::DirEntry >::difference_type pos, int argc, VALUE *argv, ...)\n"
    "    void insert(std::vector< sword::DirEntry >::iterator pos, std::vector< sword::DirEntry >::value_type const &x)\n"
    "    void insert(std::vector< sword::DirEntry >::iterator pos, std::vector< sword::DirEntry >::size_type n, std::vector< sword::DirEntry >::value_type const &x)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.reserve

  call-seq:
    reserve(n)

Reserve memory in the DirEntryVector for a number of elements.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  std::vector< sword::DirEntry >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > *","reserve", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry >::size_type","reserve", 2, argv[0] ));
  } 
  arg2 = static_cast< std::vector< sword::DirEntry >::size_type >(val2);
  (arg1)->reserve(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntryVector.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the DirEntryVector.
*/
SWIGINTERN VALUE
_wrap_DirEntryVector_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< sword::DirEntry > *arg1 = (std::vector< sword::DirEntry > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::DirEntry >::size_type result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< sword::DirEntry > const *","capacity", 1, self )); 
  }
  arg1 = reinterpret_cast< std::vector< sword::DirEntry > * >(argp1);
  result = ((std::vector< sword::DirEntry > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_std_vector_Sl_sword_DirEntry_Sg_(std::vector< sword::DirEntry > *arg1) {
    delete arg1;
}

swig_class SwigClassSWClass;

SWIGINTERN VALUE
_wrap_SWClass_isAssignableFrom(int argc, VALUE *argv, VALUE self) {
  sword::SWClass *arg1 = (sword::SWClass *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWClass, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWClass const *","isAssignableFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWClass * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isAssignableFrom", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)((sword::SWClass const *)arg1)->isAssignableFrom((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN void
free_sword_SWClass(sword::SWClass *arg1) {
    delete arg1;
}

swig_class SwigClassSWObject;

SWIGINTERN VALUE
_wrap_SWObject_getClass(int argc, VALUE *argv, VALUE self) {
  sword::SWObject *arg1 = (sword::SWObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWClass *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWObject const *","getClass", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWObject * >(argp1);
  result = (sword::SWClass *)((sword::SWObject const *)arg1)->getClass();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWClass, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWObject_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWObject_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWObject);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWObject(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWObject";
  sword::SWObject *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWObject *)new sword::SWObject();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWObject(sword::SWObject *arg1) {
    delete arg1;
}

swig_class SwigClassSWConfig;

SWIGINTERN VALUE
_wrap_SWConfig_filename_set(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","filename", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","filename", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->filename = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_filename_get(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","filename", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->filename);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWConfig__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWConfig";
  sword::SWConfig *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWConfig", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWConfig *)new sword::SWConfig((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWConfig_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWConfig_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWConfig);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWConfig__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWConfig";
  sword::SWConfig *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWConfig *)new sword::SWConfig();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SWConfig(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SWConfig__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWConfig__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SWConfig.new", 
    "    SWConfig.new(char const *ifilename)\n"
    "    SWConfig.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_SWConfig(sword::SWConfig *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWConfig_Load(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","Load", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  (arg1)->Load();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_Save(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","Save", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  (arg1)->Save();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_augment(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWConfig *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","augment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWConfig,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig &","augment", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWConfig &","augment", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  (arg1)->augment(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_set(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","set", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","set", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","set", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","set", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  sword_SWConfig_set(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_get(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","get", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","get", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","get", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char *)sword_SWConfig_get(arg1,(char const *)arg2,(char const *)arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWConfig_getSections(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PySectionMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","getSections", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  result = (PySectionMap *)sword_SWConfig_getSections(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWVersion;

SWIGINTERN VALUE
_wrap_SWVersion_major_set(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","major", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","major", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->major = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_major_get(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","major", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  result = (int) ((arg1)->major);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor_set(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","minor", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->minor = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor_get(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  result = (int) ((arg1)->minor);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor2_set(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor2", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","minor2", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->minor2 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor2_get(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor2", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  result = (int) ((arg1)->minor2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor3_set(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor3", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","minor3", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->minor3 = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_minor3_get(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion *","minor3", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  result = (int) ((arg1)->minor3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWVersion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWVersion";
  sword::SWVersion *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWVersion", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWVersion *)new sword::SWVersion((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWVersion_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWVersion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWVersion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWVersion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWVersion";
  sword::SWVersion *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWVersion *)new sword::SWVersion();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SWVersion(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SWVersion__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWVersion__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SWVersion.new", 
    "    SWVersion.new(char const *version)\n"
    "    SWVersion.new()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_compare(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (int)((sword::SWVersion const *)arg1)->compare((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_getText(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  result = (char *)((sword::SWVersion const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWVersion.>

  call-seq:
    >(vi) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWVersion___gt__(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (bool)((sword::SWVersion const *)arg1)->operator >((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWVersion.<

  call-seq:
    <(vi) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWVersion___lt__(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (bool)((sword::SWVersion const *)arg1)->operator <((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWVersion.>=

  call-seq:
    >=(vi) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWVersion___ge__(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (bool)((sword::SWVersion const *)arg1)->operator >=((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWVersion.<=

  call-seq:
    <=(vi) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWVersion___le__(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (bool)((sword::SWVersion const *)arg1)->operator <=((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWVersion.==

  call-seq:
    ==(vi) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWVersion___eq__(int argc, VALUE *argv, VALUE self) {
  sword::SWVersion *arg1 = (sword::SWVersion *) 0 ;
  sword::SWVersion *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWVersion, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWVersion const *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWVersion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWVersion,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWVersion const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWVersion const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWVersion * >(argp2);
  result = (bool)((sword::SWVersion const *)arg1)->operator ==((sword::SWVersion const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWVersion_currentVersion_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&sword::SWVersion::currentVersion), SWIGTYPE_p_sword__SWVersion,  0 );
  return _val;
}


SWIGINTERN VALUE
_wrap_SWVersion_currentVersion_set(VALUE self, VALUE _val) {
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_sword__SWVersion,  0 );
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::SWVersion::currentVersion""' of type '""sword::SWVersion""'");
    }
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""sword::SWVersion::currentVersion""' of type '""sword::SWVersion""'");
    } else {
      sword::SWVersion::currentVersion = *(reinterpret_cast< sword::SWVersion * >(argp));
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWVersion(sword::SWVersion *arg1) {
    delete arg1;
}

swig_class SwigClassRawVerse;

SWIGINTERN VALUE
_wrap_RawVerse_nl_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(sword::RawVerse::nl);
  return _val;
}


SWIGINTERN VALUE
_wrap_new_RawVerse__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawVerse";
  sword::RawVerse *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::RawVerse", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::RawVerse *)new sword::RawVerse((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawVerse_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawVerse_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawVerse);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawVerse__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawVerse";
  sword::RawVerse *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawVerse *)new sword::RawVerse((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawVerse(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawVerse__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RawVerse__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RawVerse.new", 
    "    RawVerse.new(char const *ipath, int fileMode)\n"
    "    RawVerse.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawVerse(sword::RawVerse *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawVerse_findOffset(int argc, VALUE *argv, VALUE self) {
  sword::RawVerse *arg1 = (sword::RawVerse *) 0 ;
  char arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  unsigned short *arg5 = (unsigned short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawVerse const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawVerse * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","findOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","findOffset", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "long *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< long * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "unsigned short *","findOffset", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< unsigned short * >(argp5);
  ((sword::RawVerse const *)arg1)->findOffset(arg2,arg3,arg4,arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawVerse_readText(int argc, VALUE *argv, VALUE self) {
  sword::RawVerse *arg1 = (sword::RawVerse *) 0 ;
  char arg2 ;
  long arg3 ;
  unsigned short arg4 ;
  sword::SWBuf *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned short val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawVerse *","readText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawVerse * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","readText", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","readText", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_short(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned short","readText", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned short >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWBuf &","readText", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","readText", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< sword::SWBuf * >(argp5);
  (arg1)->readText(arg2,arg3,arg4,*arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawVerse_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawVerse::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawVerse::createModule", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char)sword::RawVerse::createModule((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawVerse_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawVerse::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawVerse::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawVerse_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawVerse_createModule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawVerse_createModule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RawVerse.createModule", 
    "    char RawVerse.createModule(char const *path, char const *v11n)\n"
    "    char RawVerse.createModule(char const *path)\n");
  
  return Qnil;
}


swig_class SwigClassZVerse;

SWIGINTERN VALUE
_wrap_zVerse_uniqueIndexID_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(sword::zVerse::uniqueIndexID);
  return _val;
}


SWIGINTERN VALUE
_wrap_zVerse_nl_set(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","nl", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  if (arg1) (arg1)->nl = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_nl_get(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  result = (char) ((arg1)->nl);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zVerse__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  sword::SWCompress *arg4 = (sword::SWCompress *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zVerse";
  sword::zVerse *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zVerse", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","sword::zVerse", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zVerse", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWCompress * >(argp4);
  result = (sword::zVerse *)new sword::zVerse((char const *)arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zVerse__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zVerse";
  sword::zVerse *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zVerse", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","sword::zVerse", 3, argv[2] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (sword::zVerse *)new sword::zVerse((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zVerse__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zVerse";
  sword::zVerse *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zVerse", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::zVerse *)new sword::zVerse((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_zVerse_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_zVerse_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__zVerse);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_zVerse__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zVerse";
  sword::zVerse *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::zVerse *)new sword::zVerse((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_zVerse(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_zVerse__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_zVerse__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_zVerse__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_zVerse__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zVerse.new", 
    "    zVerse.new(char const *ipath, int fileMode, int blockType, sword::SWCompress *icomp)\n"
    "    zVerse.new(char const *ipath, int fileMode, int blockType)\n"
    "    zVerse.new(char const *ipath, int fileMode)\n"
    "    zVerse.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_zVerse(sword::zVerse *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_zVerse_findOffset(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  char arg2 ;
  long arg3 ;
  long *arg4 = (long *) 0 ;
  unsigned short *arg5 = (unsigned short *) 0 ;
  unsigned long *arg6 = (unsigned long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","findOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","findOffset", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "long *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< long * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_unsigned_short, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "unsigned short *","findOffset", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< unsigned short * >(argp5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6,SWIGTYPE_p_unsigned_long, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "unsigned long *","findOffset", 6, argv[4] )); 
  }
  arg6 = reinterpret_cast< unsigned long * >(argp6);
  ((sword::zVerse const *)arg1)->findOffset(arg2,arg3,arg4,arg5,arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_zReadText(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  char arg2 ;
  long arg3 ;
  unsigned short arg4 ;
  unsigned long arg5 ;
  sword::SWBuf *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  unsigned short val4 ;
  int ecode4 = 0 ;
  unsigned long val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse *","zReadText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","zReadText", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","zReadText", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_short(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned short","zReadText", 4, argv[2] ));
  } 
  arg4 = static_cast< unsigned short >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "unsigned long","zReadText", 5, argv[3] ));
  } 
  arg5 = static_cast< unsigned long >(val5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWBuf &","zReadText", 6, argv[4] )); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","zReadText", 6, argv[4])); 
  }
  arg6 = reinterpret_cast< sword::SWBuf * >(argp6);
  (arg1)->zReadText(arg2,arg3,arg4,arg5,*arg6);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_rawZFilter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","rawZFilter", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->rawZFilter(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_rawZFilter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zVerse *arg1 = (sword::zVerse *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zVerse, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zVerse *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zVerse * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->rawZFilter(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zVerse_rawZFilter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zVerse, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zVerse_rawZFilter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zVerse, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zVerse_rawZFilter__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zVerse.rawZFilter", 
    "    void zVerse.rawZFilter(sword::SWBuf &buf, char direction)\n"
    "    void zVerse.rawZFilter(sword::SWBuf &buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zVerse::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zVerse::createModule", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char)sword::zVerse::createModule((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zVerse_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zVerse::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zVerse::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char)sword::zVerse::createModule((char const *)arg1,arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zVerse_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zVerse_createModule__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_zVerse_createModule__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zVerse.createModule", 
    "    char zVerse.createModule(char const *path, int blockBound, char const *v11n)\n"
    "    char zVerse.createModule(char const *path, int blockBound)\n");
  
  return Qnil;
}


swig_class SwigClassRawStr;

SWIGINTERN VALUE
_wrap_RawStr_nl_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_char(static_cast< char >(sword::RawStr::nl));
  return _val;
}


SWIGINTERN VALUE
_wrap_RawStr_nl_set(VALUE self, VALUE _val) {
  {
    char val;
    int res = SWIG_AsVal_char(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::RawStr::nl""' of type '""char""'");
    }
    sword::RawStr::nl = static_cast< char >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawStr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr";
  sword::RawStr *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::RawStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","sword::RawStr", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (sword::RawStr *)new sword::RawStr((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawStr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr";
  sword::RawStr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::RawStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::RawStr *)new sword::RawStr((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawStr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawStr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawStr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawStr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr";
  sword::RawStr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawStr *)new sword::RawStr((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawStr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawStr__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RawStr__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_RawStr__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawStr.new", 
    "    RawStr.new(char const *ipath, int fileMode, bool caseSensitive)\n"
    "    RawStr.new(char const *ipath, int fileMode)\n"
    "    RawStr.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawStr(sword::RawStr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawStr_getIDXBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  long arg2 ;
  char **arg3 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr const *","getIDXBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getIDXBuf", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char **","getIDXBuf", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< char ** >(argp3);
  ((sword::RawStr const *)arg1)->getIDXBuf(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_getIDXBufDat(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  long arg2 ;
  char **arg3 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr const *","getIDXBufDat", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getIDXBufDat", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char **","getIDXBufDat", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< char ** >(argp3);
  ((sword::RawStr const *)arg1)->getIDXBufDat(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_findOffset__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u16 *arg4 = (__u16 *) 0 ;
  long arg5 ;
  __u32 *arg6 = (__u32 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u16, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u16 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u16 * >(argp4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","findOffset", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "__u32 *","findOffset", 6, argv[4] )); 
  }
  arg6 = reinterpret_cast< __u32 * >(argp6);
  result = (signed char)((sword::RawStr const *)arg1)->findOffset((char const *)arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_findOffset__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u16 *arg4 = (__u16 *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u16, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u16 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u16 * >(argp4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","findOffset", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  result = (signed char)((sword::RawStr const *)arg1)->findOffset((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_findOffset__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u16 *arg4 = (__u16 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u16, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u16 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u16 * >(argp4);
  result = (signed char)((sword::RawStr const *)arg1)->findOffset((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawStr_findOffset(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u16, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_RawStr_findOffset__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u16, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_RawStr_findOffset__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u16, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p___u32, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_RawStr_findOffset__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "RawStr.findOffset", 
    "    signed char RawStr.findOffset(char const *key, __u32 *start, __u16 *size, long away, __u32 *idxoff)\n"
    "    signed char RawStr.findOffset(char const *key, __u32 *start, __u16 *size, long away)\n"
    "    signed char RawStr.findOffset(char const *key, __u32 *start, __u16 *size)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_readText(int argc, VALUE *argv, VALUE self) {
  sword::RawStr *arg1 = (sword::RawStr *) 0 ;
  __u32 arg2 ;
  __u16 *arg3 = (__u16 *) 0 ;
  char **arg4 = (char **) 0 ;
  sword::SWBuf *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr *","readText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p___u32,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "__u32","readText", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "__u32","readText", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< __u32 * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u16, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u16 *","readText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u16 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char **","readText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< char ** >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWBuf &","readText", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","readText", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< sword::SWBuf * >(argp5);
  (arg1)->readText(arg2,arg3,arg4,*arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::RawStr::createModule((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


swig_class SwigClassRawStr4;

SWIGINTERN VALUE
_wrap_RawStr4_nl_set(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","nl", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  if (arg1) (arg1)->nl = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_nl_get(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  result = (char) ((arg1)->nl);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawStr4__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr4";
  sword::RawStr4 *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::RawStr4", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","sword::RawStr4", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (sword::RawStr4 *)new sword::RawStr4((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawStr4__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr4";
  sword::RawStr4 *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::RawStr4", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::RawStr4 *)new sword::RawStr4((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawStr4_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawStr4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawStr4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawStr4__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawStr4";
  sword::RawStr4 *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawStr4 *)new sword::RawStr4((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawStr4(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawStr4__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RawStr4__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_RawStr4__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawStr4.new", 
    "    RawStr4.new(char const *ipath, int fileMode, bool caseSensitive)\n"
    "    RawStr4.new(char const *ipath, int fileMode)\n"
    "    RawStr4.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawStr4(sword::RawStr4 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawStr4_getIDXBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  long arg2 ;
  char **arg3 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 const *","getIDXBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getIDXBuf", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char **","getIDXBuf", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< char ** >(argp3);
  ((sword::RawStr4 const *)arg1)->getIDXBuf(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_getIDXBufDat(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  long arg2 ;
  char **arg3 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 const *","getIDXBufDat", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getIDXBufDat", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char **","getIDXBufDat", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< char ** >(argp3);
  ((sword::RawStr4 const *)arg1)->getIDXBufDat(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_findOffset__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u32 *arg4 = (__u32 *) 0 ;
  long arg5 ;
  __u32 *arg6 = (__u32 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u32 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u32 * >(argp4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","findOffset", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  res6 = SWIG_ConvertPtr(argv[4], &argp6,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "__u32 *","findOffset", 6, argv[4] )); 
  }
  arg6 = reinterpret_cast< __u32 * >(argp6);
  result = (signed char)((sword::RawStr4 const *)arg1)->findOffset((char const *)arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_findOffset__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u32 *arg4 = (__u32 *) 0 ;
  long arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u32 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u32 * >(argp4);
  ecode5 = SWIG_AsVal_long(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "long","findOffset", 5, argv[3] ));
  } 
  arg5 = static_cast< long >(val5);
  result = (signed char)((sword::RawStr4 const *)arg1)->findOffset((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_findOffset__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  char *arg2 = (char *) 0 ;
  __u32 *arg3 = (__u32 *) 0 ;
  __u32 *arg4 = (__u32 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 const *","findOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findOffset", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","findOffset", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "__u32 *","findOffset", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< __u32 * >(argp4);
  result = (signed char)((sword::RawStr4 const *)arg1)->findOffset((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawStr4_findOffset(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u32, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_RawStr4_findOffset__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u32, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_RawStr4_findOffset__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawStr4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p___u32, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p___u32, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_long(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p___u32, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_RawStr4_findOffset__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "RawStr4.findOffset", 
    "    signed char RawStr4.findOffset(char const *key, __u32 *start, __u32 *size, long away, __u32 *idxoff)\n"
    "    signed char RawStr4.findOffset(char const *key, __u32 *start, __u32 *size, long away)\n"
    "    signed char RawStr4.findOffset(char const *key, __u32 *start, __u32 *size)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_readText(int argc, VALUE *argv, VALUE self) {
  sword::RawStr4 *arg1 = (sword::RawStr4 *) 0 ;
  __u32 arg2 ;
  __u32 *arg3 = (__u32 *) 0 ;
  char **arg4 = (char **) 0 ;
  sword::SWBuf *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawStr4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawStr4 *","readText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawStr4 * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p___u32,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "__u32","readText", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "__u32","readText", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< __u32 * >(argp2));
    }
  }
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p___u32, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "__u32 *","readText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< __u32 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char **","readText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< char ** >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWBuf &","readText", 5, argv[3] )); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","readText", 5, argv[3])); 
  }
  arg5 = reinterpret_cast< sword::SWBuf * >(argp5);
  (arg1)->readText(arg2,arg3,arg4,*arg5);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawStr4_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawStr4::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::RawStr4::createModule((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


swig_class SwigClassZStr;

SWIGINTERN VALUE
_wrap_zStr_nl_set(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","nl", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  if (arg1) (arg1)->nl = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_nl_get(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","nl", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  result = (char) ((arg1)->nl);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zStr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  long arg3 ;
  sword::SWCompress *arg4 = (sword::SWCompress *) 0 ;
  bool arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zStr";
  sword::zStr *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","sword::zStr", 3, argv[2] ));
  } 
  arg3 = static_cast< long >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zStr", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWCompress * >(argp4);
  ecode5 = SWIG_AsVal_bool(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","sword::zStr", 5, argv[4] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (sword::zStr *)new sword::zStr((char const *)arg1,arg2,arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zStr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  long arg3 ;
  sword::SWCompress *arg4 = (sword::SWCompress *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zStr";
  sword::zStr *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","sword::zStr", 3, argv[2] ));
  } 
  arg3 = static_cast< long >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zStr", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWCompress * >(argp4);
  result = (sword::zStr *)new sword::zStr((char const *)arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zStr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  long arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zStr";
  sword::zStr *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_long(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","sword::zStr", 3, argv[2] ));
  } 
  arg3 = static_cast< long >(val3);
  result = (sword::zStr *)new sword::zStr((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zStr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zStr";
  sword::zStr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zStr", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::zStr *)new sword::zStr((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_zStr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_zStr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__zStr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_zStr__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zStr";
  sword::zStr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::zStr *)new sword::zStr((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_zStr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_zStr__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_zStr__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_zStr__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_zStr__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_zStr__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "zStr.new", 
    "    zStr.new(char const *ipath, int fileMode, long blockCount, sword::SWCompress *icomp, bool caseSensitive)\n"
    "    zStr.new(char const *ipath, int fileMode, long blockCount, sword::SWCompress *icomp)\n"
    "    zStr.new(char const *ipath, int fileMode, long blockCount)\n"
    "    zStr.new(char const *ipath, int fileMode)\n"
    "    zStr.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_zStr(sword::zStr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_zStr_findKeyIndex__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char *arg2 = (char *) 0 ;
  long *arg3 = (long *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr const *","findKeyIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findKeyIndex", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "long *","findKeyIndex", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< long * >(argp3);
  ecode4 = SWIG_AsVal_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","findKeyIndex", 4, argv[2] ));
  } 
  arg4 = static_cast< long >(val4);
  result = (signed char)((sword::zStr const *)arg1)->findKeyIndex((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_findKeyIndex__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char *arg2 = (char *) 0 ;
  long *arg3 = (long *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr const *","findKeyIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","findKeyIndex", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "long *","findKeyIndex", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< long * >(argp3);
  result = (signed char)((sword::zStr const *)arg1)->findKeyIndex((char const *)arg2,arg3);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zStr_findKeyIndex(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_long, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_zStr_findKeyIndex__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_long, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_zStr_findKeyIndex__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "zStr.findKeyIndex", 
    "    signed char zStr.findKeyIndex(char const *ikey, long *idxoff, long away)\n"
    "    signed char zStr.findKeyIndex(char const *ikey, long *idxoff)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_getText(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  long arg2 ;
  char **arg3 = (char **) 0 ;
  char **arg4 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getText", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char **","getText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< char ** >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_p_char, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char **","getText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< char ** >(argp4);
  (arg1)->getText(arg2,arg3,arg4);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_setText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setText", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","setText", 4, argv[2] ));
  } 
  arg4 = static_cast< long >(val4);
  (arg1)->setText((char const *)arg2,(char const *)arg3,arg4);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_setText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setText", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->setText((char const *)arg2,(char const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zStr_setText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_zStr_setText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_zStr_setText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "zStr.setText", 
    "    void zStr.setText(char const *ikey, char const *buf, long len)\n"
    "    void zStr.setText(char const *ikey, char const *buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","linkEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","linkEntry", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->linkEntry((char const *)arg2,(char const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_rawZFilter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","rawZFilter", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->rawZFilter(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_rawZFilter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zStr *arg1 = (sword::zStr *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zStr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zStr *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zStr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->rawZFilter(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zStr_rawZFilter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zStr_rawZFilter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zStr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zStr_rawZFilter__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zStr.rawZFilter", 
    "    void zStr.rawZFilter(sword::SWBuf &buf, char direction)\n"
    "    void zStr.rawZFilter(sword::SWBuf &buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zStr_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zStr::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::zStr::createModule((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


swig_class SwigClassSW_POSITION;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SW_POSITION_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SW_POSITION_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SW_POSITION);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SW_POSITION(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SW_POSITION";
  sword::SW_POSITION *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","sword::SW_POSITION", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  result = (sword::SW_POSITION *)new sword::SW_POSITION(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SW_POSITION_getPosition(int argc, VALUE *argv, VALUE self) {
  sword::SW_POSITION *arg1 = (sword::SW_POSITION *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SW_POSITION, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SW_POSITION *","operator char", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SW_POSITION * >(argp1);
  result = (char)(arg1)->operator char();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SW_POSITION(sword::SW_POSITION *arg1) {
    delete arg1;
}

swig_class SwigClassSWKey;

SWIGINTERN VALUE
_wrap_new_SWKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWKey";
  sword::SWKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWKey", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWKey *)new sword::SWKey((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWKey";
  sword::SWKey *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWKey *)new sword::SWKey();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWKey_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWKey_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWKey);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWKey__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWKey";
  sword::SWKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const &","sword::SWKey", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","sword::SWKey", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::SWKey *)new sword::SWKey((sword::SWKey const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SWKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SWKey__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWKey__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWKey__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "SWKey.new", 
    "    SWKey.new(char const *ikey)\n"
    "    SWKey.new()\n"
    "    SWKey.new(sword::SWKey const &k)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_SWKey(sword::SWKey *arg1) {
    delete arg1;
}


/*
  Document-method: Sword::SWKey.clone

  call-seq:
    clone -> SWKey

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_SWKey_clone(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::SWKey *)((sword::SWKey const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Persist__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","Persist", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char)((sword::SWKey const *)arg1)->Persist();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Persist__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  signed char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  signed char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","Persist", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_signed_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "signed char","Persist", 2, argv[0] ));
  } 
  arg2 = static_cast< signed char >(val2);
  result = (char)(arg1)->Persist(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWKey_Persist(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWKey_Persist__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_signed_SS_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWKey_Persist__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWKey.Persist", 
    "    char SWKey.Persist()\n"
    "    char SWKey.Persist(signed char ipersist)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Error(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","Error", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char)(arg1)->Error();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_setError(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","setError", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setError", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setError(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_setText(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_copyFrom(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->copyFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_positionFrom(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","positionFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","positionFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","positionFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->positionFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getText(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char *)((sword::SWKey const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getShortText(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getShortText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char *)((sword::SWKey const *)arg1)->getShortText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getRangeText(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char *)((sword::SWKey const *)arg1)->getRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getOSISRefRangeText(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getOSISRefRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char *)((sword::SWKey const *)arg1)->getOSISRefRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_isBoundSet(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","isBoundSet", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (bool)((sword::SWKey const *)arg1)->isBoundSet();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_clearBound(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","clearBound", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ((sword::SWKey const *)arg1)->clearBound();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_compare(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (int)(arg1)->compare((sword::SWKey const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_equals(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","equals", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","equals", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","equals", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->equals((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWKey_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWKey_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWKey_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWKey.decrement", 
    "    void SWKey.decrement(int steps)\n"
    "    void SWKey.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWKey_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWKey_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWKey_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWKey.increment", 
    "    void SWKey.increment(int steps)\n"
    "    void SWKey.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Traversable(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","Traversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char)(arg1)->Traversable();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (bool)((sword::SWKey const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getLocale(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getLocale", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (char *)((sword::SWKey const *)arg1)->getLocale();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_setLocale(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","setLocale", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setLocale", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setLocale((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (long)((sword::SWKey const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Index__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","Index", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (long)((sword::SWKey const *)arg1)->Index();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWKey_Index__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","Index", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","Index", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (long)(arg1)->Index(arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWKey_Index(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWKey_Index__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWKey_Index__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWKey.Index", 
    "    long SWKey.Index()\n"
    "    long SWKey.Index(long iindex)\n");
  
  return Qnil;
}



/*
  Document-method: Sword::SWKey.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWKey___eq__(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWKey.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWKey___gt__(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWKey.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWKey___lt__(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWKey.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWKey___ge__(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWKey.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_SWKey___le__(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassListKey;

SWIGINTERN VALUE
_wrap_new_ListKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::ListKey";
  sword::ListKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::ListKey", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::ListKey *)new sword::ListKey((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_ListKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::ListKey";
  sword::ListKey *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::ListKey *)new sword::ListKey();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ListKey_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ListKey_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__ListKey);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ListKey__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::ListKey";
  sword::ListKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__ListKey,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const &","sword::ListKey", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::ListKey const &","sword::ListKey", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (sword::ListKey *)new sword::ListKey((sword::ListKey const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ListKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ListKey__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListKey__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListKey__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "ListKey.new", 
    "    ListKey.new(char const *ikey)\n"
    "    ListKey.new()\n"
    "    ListKey.new(sword::ListKey const &k)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_ListKey(sword::ListKey *arg1) {
    delete arg1;
}


/*
  Document-method: Sword::ListKey.clone

  call-seq:
    clone -> SWKey

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_ListKey_clone(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (sword::SWKey *)((sword::ListKey const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.clear

  call-seq:
    clear

Clear ListKey contents.
*/
SWIGINTERN VALUE
_wrap_ListKey_clear(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","clear", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->clear();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_ClearList(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","ClearList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->ClearList();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_Count(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","Count", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (int)(arg1)->Count();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_Remove(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","Remove", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->Remove();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_SetToElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  SwigValueWrapper< sword::SW_POSITION > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","SetToElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetToElement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SW_POSITION","SetToElement", 3, argv[1] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","SetToElement", 3, argv[1]));
    } else {
      arg3 = *(reinterpret_cast< sword::SW_POSITION * >(argp3));
    }
  }
  result = (char)(arg1)->SetToElement(arg2,arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_SetToElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","SetToElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetToElement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char)(arg1)->SetToElement(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_SetToElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListKey_SetToElement__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SW_POSITION, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_ListKey_SetToElement__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "ListKey.SetToElement", 
    "    char ListKey.SetToElement(int ielement, sword::SW_POSITION)\n"
    "    char ListKey.SetToElement(int ielement)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","getElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getElement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::SWKey *)(arg1)->getElement(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","getElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (sword::SWKey *)(arg1)->getElement();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_getElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListKey_getElement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListKey_getElement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListKey.getElement", 
    "    sword::SWKey * ListKey.getElement(int pos)\n"
    "    sword::SWKey * ListKey.getElement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_GetElement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","GetElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetElement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::SWKey *)(arg1)->GetElement(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_GetElement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","GetElement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (sword::SWKey *)(arg1)->GetElement();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_GetElement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListKey_GetElement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListKey_GetElement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListKey.GetElement", 
    "    sword::SWKey * ListKey.GetElement(int pos)\n"
    "    sword::SWKey * ListKey.GetElement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_add(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","add", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","add", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","add", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->add((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_copyFrom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::ListKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__ListKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::ListKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::ListKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::ListKey * >(argp2);
  (arg1)->copyFrom((sword::ListKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_copyFrom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->copyFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_copyFrom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__ListKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListKey_copyFrom__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListKey_copyFrom__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListKey.copyFrom", 
    "    void ListKey.copyFrom(sword::ListKey const &ikey)\n"
    "    void ListKey.copyFrom(sword::SWKey const &ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListKey_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListKey_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListKey.decrement", 
    "    void ListKey.decrement(int step)\n"
    "    void ListKey.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_ListKey_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListKey_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__ListKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListKey_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "ListKey.increment", 
    "    void ListKey.increment(int step)\n"
    "    void ListKey.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (bool)((sword::ListKey const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (long)((sword::ListKey const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getRangeText(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","getRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (char *)((sword::ListKey const *)arg1)->getRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getOSISRefRangeText(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","getOSISRefRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (char *)((sword::ListKey const *)arg1)->getOSISRefRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_getText(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  result = (char *)((sword::ListKey const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_setText(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_sort(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","sort", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  (arg1)->sort();
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_ListKey___eq__(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_ListKey___gt__(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_ListKey___lt__(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_ListKey___ge__(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::ListKey.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_ListKey___le__(int argc, VALUE *argv, VALUE self) {
  sword::ListKey *arg1 = (sword::ListKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ListKey *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ListKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ListKey_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","sword_ListKey_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::ListKey *)sword_ListKey_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassVerseKey;

SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::VerseKey *)new sword::VerseKey((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::VerseKey *)new sword::VerseKey();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const *","sword::VerseKey", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::VerseKey *)new sword::VerseKey((sword::SWKey const *)arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::VerseKey *)new sword::VerseKey((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::VerseKey", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::VerseKey *)new sword::VerseKey((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_5(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey const &","sword::VerseKey", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","sword::VerseKey", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::VerseKey *)new sword::VerseKey((sword::SWKey const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_VerseKey_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_VerseKey_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__VerseKey);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_VerseKey__SWIG_6(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseKey";
  sword::VerseKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__VerseKey,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const &","sword::VerseKey", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseKey const &","sword::VerseKey", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (sword::VerseKey *)new sword::VerseKey((sword::VerseKey const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_VerseKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_VerseKey__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseKey__SWIG_6(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseKey__SWIG_5(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseKey__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseKey__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_VerseKey__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_VerseKey__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.new", 
    "    VerseKey.new(char const *ikey)\n"
    "    VerseKey.new()\n"
    "    VerseKey.new(sword::SWKey const *ikey)\n"
    "    VerseKey.new(char const *min, char const *max, char const *v11n)\n"
    "    VerseKey.new(char const *min, char const *max)\n"
    "    VerseKey.new(sword::SWKey const &k)\n"
    "    VerseKey.new(sword::VerseKey const &k)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_VerseKey(sword::VerseKey *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_VerseKey_LowerBound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::VerseKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  sword::VerseKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","LowerBound", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__VerseKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::VerseKey const &","LowerBound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseKey const &","LowerBound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::VerseKey * >(argp2);
  result = (sword::VerseKey *) &(arg1)->LowerBound((sword::VerseKey const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_UpperBound__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::VerseKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  sword::VerseKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","UpperBound", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__VerseKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::VerseKey const &","UpperBound", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseKey const &","UpperBound", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::VerseKey * >(argp2);
  result = (sword::VerseKey *) &(arg1)->UpperBound((sword::VerseKey const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_LowerBound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::VerseKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","LowerBound", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (sword::VerseKey *) &((sword::VerseKey const *)arg1)->LowerBound();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_LowerBound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_LowerBound__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_LowerBound__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.LowerBound", 
    "    sword::VerseKey & VerseKey.LowerBound(sword::VerseKey const &ub)\n"
    "    sword::VerseKey & VerseKey.LowerBound()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_UpperBound__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::VerseKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","UpperBound", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (sword::VerseKey *) &((sword::VerseKey const *)arg1)->UpperBound();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_UpperBound(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_UpperBound__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_UpperBound__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.UpperBound", 
    "    sword::VerseKey & VerseKey.UpperBound(sword::VerseKey const &ub)\n"
    "    sword::VerseKey & VerseKey.UpperBound()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_ClearBounds(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","ClearBounds", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  (arg1)->ClearBounds();
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.clone

  call-seq:
    clone -> SWKey

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_VerseKey_clone(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (sword::SWKey *)((sword::VerseKey const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getText(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getShortText(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getShortText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getShortText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","setText", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setText((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_setText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_setText__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_VerseKey_setText__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "VerseKey.setText", 
    "    void VerseKey.setText(char const *ikey, bool checkNormalize)\n"
    "    void VerseKey.setText(char const *ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_copyFrom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->copyFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_copyFrom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::VerseKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__VerseKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::VerseKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::VerseKey * >(argp2);
  (arg1)->copyFrom((sword::VerseKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_copyFrom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_copyFrom__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_copyFrom__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.copyFrom", 
    "    void VerseKey.copyFrom(sword::SWKey const &ikey)\n"
    "    void VerseKey.copyFrom(sword::VerseKey const &ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_positionFrom(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","positionFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","positionFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","positionFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->positionFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.decrement", 
    "    void VerseKey.decrement(int steps)\n"
    "    void VerseKey.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.increment", 
    "    void VerseKey.increment(int steps)\n"
    "    void VerseKey.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (bool)((sword::VerseKey const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBookName(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getBookName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getBookName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setBookName(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setBookName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setBookName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setBookName((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBookAbbrev(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getBookAbbrev", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getBookAbbrev();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Testament__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","Testament", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->Testament();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getTestament(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getTestament", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->getTestament();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getTestamentMax(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getTestamentMax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getTestamentMax();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Book__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","Book", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->Book();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBook(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getBook", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->getBook();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBookMax(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getBookMax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getBookMax();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Chapter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","Chapter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->Chapter();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getChapter(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getChapter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getChapter();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getChapterMax(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getChapterMax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getChapterMax();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Verse__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","Verse", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->Verse();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getVerse(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getVerse", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getVerse();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getVerseMax(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getVerseMax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)((sword::VerseKey const *)arg1)->getVerseMax();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getSuffix(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getSuffix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->getSuffix();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Testament__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Testament", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Testament", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->Testament(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Testament(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Testament__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Testament__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Testament", 
    "    char VerseKey.Testament()\n"
    "    char VerseKey.Testament(char itestament)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setTestament(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setTestament", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setTestament", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setTestament(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Book__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Book", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Book", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->Book(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Book(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Book__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Book__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Book", 
    "    char VerseKey.Book()\n"
    "    char VerseKey.Book(char ibook)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setBook(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setBook", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setBook", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setBook(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Chapter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Chapter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Chapter", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->Chapter(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Chapter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Chapter__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Chapter__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Chapter", 
    "    int VerseKey.Chapter()\n"
    "    int VerseKey.Chapter(int ichapter)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setChapter(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setChapter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setChapter", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setChapter(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Verse__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Verse", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Verse", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->Verse(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Verse(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Verse__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Verse__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Verse", 
    "    int VerseKey.Verse()\n"
    "    int VerseKey.Verse(int iverse)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setVerse(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setVerse", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","setVerse", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->setVerse(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setSuffix(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setSuffix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setSuffix", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setSuffix(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Normalize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Normalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Normalize", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->Normalize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Normalize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Normalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  (arg1)->Normalize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Normalize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Normalize__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Normalize__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Normalize", 
    "    void VerseKey.Normalize(char autocheck)\n"
    "    void VerseKey.Normalize()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_AutoNormalize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","AutoNormalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","AutoNormalize", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->AutoNormalize(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_AutoNormalize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","AutoNormalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)((sword::VerseKey const *)arg1)->AutoNormalize();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_AutoNormalize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_AutoNormalize__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_AutoNormalize__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.AutoNormalize", 
    "    char VerseKey.AutoNormalize(char iautonorm)\n"
    "    char VerseKey.AutoNormalize()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_isAutoNormalize(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","isAutoNormalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (bool)((sword::VerseKey const *)arg1)->isAutoNormalize();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setAutoNormalize(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setAutoNormalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setAutoNormalize", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setAutoNormalize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Headings__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Headings", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Headings", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->Headings(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_Headings__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","Headings", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char)(arg1)->Headings();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_Headings(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_Headings__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_Headings__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.Headings", 
    "    char VerseKey.Headings(char iheadings)\n"
    "    char VerseKey.Headings()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (long)((sword::VerseKey const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getTestamentIndex(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getTestamentIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (long)((sword::VerseKey const *)arg1)->getTestamentIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_TestamentIndex(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","TestamentIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (long)((sword::VerseKey const *)arg1)->TestamentIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getOSISRef(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getOSISRef", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getOSISRef();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getOSISBookName__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getOSISBookName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getOSISBookName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_convertToOSIS(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::VerseKey::convertToOSIS", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","sword::VerseKey::convertToOSIS", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char *)sword::VerseKey::convertToOSIS((char const *)arg1,(sword::SWKey const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_ParseVerseList__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  sword::ListKey result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","ParseVerseList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","ParseVerseList", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","ParseVerseList", 5, argv[3] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (arg1)->ParseVerseList((char const *)arg2,(char const *)arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj((new sword::ListKey(static_cast< const sword::ListKey& >(result))), SWIGTYPE_p_sword__ListKey, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_ParseVerseList__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  sword::ListKey result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","ParseVerseList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","ParseVerseList", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (arg1)->ParseVerseList((char const *)arg2,(char const *)arg3,arg4);
  vresult = SWIG_NewPointerObj((new sword::ListKey(static_cast< const sword::ListKey& >(result))), SWIGTYPE_p_sword__ListKey, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_ParseVerseList__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  sword::ListKey result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","ParseVerseList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (arg1)->ParseVerseList((char const *)arg2,(char const *)arg3);
  vresult = SWIG_NewPointerObj((new sword::ListKey(static_cast< const sword::ListKey& >(result))), SWIGTYPE_p_sword__ListKey, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_ParseVerseList__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::ListKey result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","ParseVerseList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","ParseVerseList", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (arg1)->ParseVerseList((char const *)arg2);
  vresult = SWIG_NewPointerObj((new sword::ListKey(static_cast< const sword::ListKey& >(result))), SWIGTYPE_p_sword__ListKey, SWIG_POINTER_OWN |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_ParseVerseList(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_VerseKey_ParseVerseList__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_VerseKey_ParseVerseList__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_VerseKey_ParseVerseList__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_VerseKey_ParseVerseList__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "VerseKey.ParseVerseList", 
    "    sword::ListKey VerseKey.ParseVerseList(char const *buf, char const *defaultKey, bool expandRange, bool useChapterAsVerse)\n"
    "    sword::ListKey VerseKey.ParseVerseList(char const *buf, char const *defaultKey, bool expandRange)\n"
    "    sword::ListKey VerseKey.ParseVerseList(char const *buf, char const *defaultKey)\n"
    "    sword::ListKey VerseKey.ParseVerseList(char const *buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getRangeText(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getOSISRefRangeText(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getOSISRefRangeText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getOSISRefRangeText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_compare(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (int)(arg1)->compare((sword::SWKey const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey__compare(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::VerseKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","_compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__VerseKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::VerseKey const &","_compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseKey const &","_compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::VerseKey * >(argp2);
  result = (int)(arg1)->_compare((sword::VerseKey const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_setVersificationSystem(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","setVersificationSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setVersificationSystem", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setVersificationSystem((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getVersificationSystem(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","getVersificationSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (char *)((sword::VerseKey const *)arg1)->getVersificationSystem();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_validateCurrentLocale(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey const *","validateCurrentLocale", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ((sword::VerseKey const *)arg1)->validateCurrentLocale();
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseKey___eq__(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseKey___gt__(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseKey___lt__(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseKey___ge__(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseKey.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseKey___le__(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::VerseKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","sword_VerseKey_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::VerseKey *)sword_VerseKey_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_bookCount(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","bookCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bookCount", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)sword_VerseKey_bookCount(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBookCount(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","getBookCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  result = (int)sword_VerseKey_getBookCount(arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_bookName(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","bookName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","bookName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","bookName", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (char *)sword_VerseKey_bookName(arg1,arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getBookNumberByOSISName(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","getBookNumberByOSISName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getBookNumberByOSISName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)sword_VerseKey_getBookNumberByOSISName(arg1,(char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_getOSISBookName__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","getOSISBookName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getOSISBookName", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char *)sword_VerseKey_getOSISBookName__SWIG_1(arg1,arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseKey_getOSISBookName(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseKey_getOSISBookName__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseKey_getOSISBookName__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseKey.getOSISBookName", 
    "    char const * VerseKey.getOSISBookName()\n"
    "    char const * VerseKey.getOSISBookName(int const book)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_chapterCount(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","chapterCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","chapterCount", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","chapterCount", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (int)sword_VerseKey_chapterCount(arg1,arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseKey_verseCount(int argc, VALUE *argv, VALUE self) {
  sword::VerseKey *arg1 = (sword::VerseKey *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseKey *","verseCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","verseCount", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","verseCount", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","verseCount", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (int)sword_VerseKey_verseCount(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassAbbrev;

SWIGINTERN VALUE
_wrap_abbrev_ab_get(int argc, VALUE *argv, VALUE self) {
  sword::abbrev *arg1 = (sword::abbrev *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__abbrev, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::abbrev *","ab", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::abbrev * >(argp1);
  result = (char *) ((arg1)->ab);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_abbrev_osis_set(int argc, VALUE *argv, VALUE self) {
  sword::abbrev *arg1 = (sword::abbrev *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__abbrev, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::abbrev *","osis", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::abbrev * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","osis", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >(arg2))) + 1;
    arg1->osis = (char const *)reinterpret_cast< char* >(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->osis = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_abbrev_osis_get(int argc, VALUE *argv, VALUE self) {
  sword::abbrev *arg1 = (sword::abbrev *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__abbrev, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::abbrev *","osis", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::abbrev * >(argp1);
  result = (char *) ((arg1)->osis);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_abbrev_getAbbrevCount(int argc, VALUE *argv, VALUE self) {
  sword::abbrev *arg1 = (sword::abbrev *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__abbrev, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::abbrev *","getAbbrevCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::abbrev * >(argp1);
  result = (int)sword_abbrev_getAbbrevCount(arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_abbrev_getAbbrevData(int argc, VALUE *argv, VALUE self) {
  sword::abbrev *arg1 = (sword::abbrev *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  sword::abbrev *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__abbrev, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::abbrev *","getAbbrevData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::abbrev * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getAbbrevData", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::abbrev *)sword_abbrev_getAbbrevData(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__abbrev, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_abbrev_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_abbrev_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__abbrev);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_abbrev(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::abbrev";
  sword::abbrev *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::abbrev *)new sword::abbrev();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_abbrev(sword::abbrev *arg1) {
    delete arg1;
}

swig_class SwigClassSbook;

SWIGINTERN VALUE
_wrap_sbook_name_get(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","name", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  result = (char *) ((arg1)->name);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_osis_set(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","osis", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","osis", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(reinterpret_cast< const char * >(arg2))) + 1;
    arg1->osis = (char const *)reinterpret_cast< char* >(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->osis = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_osis_get(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","osis", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  result = (char *) ((arg1)->osis);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_prefAbbrev_get(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","prefAbbrev", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  result = (char *) ((arg1)->prefAbbrev);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_chapmax_set(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  unsigned char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","chapmax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned char","chapmax", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned char >(val2);
  if (arg1) (arg1)->chapmax = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_chapmax_get(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","chapmax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  result = (unsigned char) ((arg1)->chapmax);
  vresult = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_sbook_verseMax(int argc, VALUE *argv, VALUE self) {
  sword::sbook *arg1 = (sword::sbook *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::sbook *","verseMax", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::sbook * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","verseMax", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (int)sword_sbook_verseMax(arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_sbook_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_sbook_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__sbook);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_sbook(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::sbook";
  sword::sbook *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::sbook *)new sword::sbook();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_sbook(sword::sbook *arg1) {
    delete arg1;
}

swig_class SwigClassVerseMgr;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_VerseMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_VerseMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__VerseMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_VerseMgr(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::VerseMgr";
  sword::VerseMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::VerseMgr *)new sword::VerseMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_VerseMgr(sword::VerseMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_VerseMgr_getSystemVerseMgr(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::VerseMgr *)sword::VerseMgr::getSystemVerseMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseMgr_setSystemVerseMgr(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *arg1 = (sword::VerseMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseMgr *","sword::VerseMgr::setSystemVerseMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::VerseMgr * >(argp1);
  sword::VerseMgr::setSystemVerseMgr(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseMgr_getVersificationSystems(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *arg1 = (sword::VerseMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::StringList result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseMgr const *","getVersificationSystems", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseMgr * >(argp1);
  result = ((sword::VerseMgr const *)arg1)->getVersificationSystems();
  vresult = swig::from(static_cast< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseMgr_getVersificationSystem(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *arg1 = (sword::VerseMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::VerseMgr::System *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseMgr const *","getVersificationSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getVersificationSystem", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::VerseMgr::System *)((sword::VerseMgr const *)arg1)->getVersificationSystem((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseMgr__System, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseMgr_registerVersificationSystem__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *arg1 = (sword::VerseMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::sbook *arg3 = (sword::sbook *) 0 ;
  sword::sbook *arg4 = (sword::sbook *) 0 ;
  int *arg5 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseMgr *","registerVersificationSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","registerVersificationSystem", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::sbook const *","registerVersificationSystem", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::sbook * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__sbook, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::sbook const *","registerVersificationSystem", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::sbook * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "int *","registerVersificationSystem", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< int * >(argp5);
  (arg1)->registerVersificationSystem((char const *)arg2,(sword::sbook const *)arg3,(sword::sbook const *)arg4,arg5);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseMgr_registerVersificationSystem__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseMgr *arg1 = (sword::VerseMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::TreeKey *arg3 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseMgr *","registerVersificationSystem", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","registerVersificationSystem", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::TreeKey const *","registerVersificationSystem", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::TreeKey * >(argp3);
  (arg1)->registerVersificationSystem((char const *)arg2,(sword::TreeKey const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseMgr_registerVersificationSystem(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_VerseMgr_registerVersificationSystem__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__sbook, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__sbook, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_int, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_VerseMgr_registerVersificationSystem__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "VerseMgr.registerVersificationSystem", 
    "    void VerseMgr.registerVersificationSystem(char const *name, sword::sbook const *ot, sword::sbook const *nt, int *chMax)\n"
    "    void VerseMgr.registerVersificationSystem(char const *name, sword::TreeKey const *)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_builtin_abbrevs_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(sword::builtin_abbrevs), SWIGTYPE_p_sword__abbrev,  0 );
  return _val;
}


swig_class SwigClassTreeKey;

SWIGINTERN VALUE
_wrap_TreeKey_posChangeListener_set(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::TreeKey::PositionChangeListener *arg2 = (sword::TreeKey::PositionChangeListener *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","posChangeListener", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__TreeKey__PositionChangeListener, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::TreeKey::PositionChangeListener *","posChangeListener", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::TreeKey::PositionChangeListener * >(argp2);
  if (arg1) (arg1)->posChangeListener = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_posChangeListener_get(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::TreeKey::PositionChangeListener *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","posChangeListener", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (sword::TreeKey::PositionChangeListener *) ((arg1)->posChangeListener);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__TreeKey__PositionChangeListener, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setPositionChangeListener(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::TreeKey::PositionChangeListener *arg2 = (sword::TreeKey::PositionChangeListener *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setPositionChangeListener", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__TreeKey__PositionChangeListener, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::TreeKey::PositionChangeListener *","setPositionChangeListener", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::TreeKey::PositionChangeListener * >(argp2);
  (arg1)->setPositionChangeListener(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_TreeKey(sword::TreeKey *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_TreeKey_getLocalName(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","getLocalName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (char *)(arg1)->getLocalName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setLocalName(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setLocalName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setLocalName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->setLocalName((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getLevel(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (int)(arg1)->getLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getUserData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","getUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int *","getUserData", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< int * >(argp2);
  result = (char *)((sword::TreeKey const *)arg1)->getUserData(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getUserData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","getUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (char *)((sword::TreeKey const *)arg1)->getUserData();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKey_getUserData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKey_getUserData__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_TreeKey_getUserData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKey.getUserData", 
    "    char const * TreeKey.getUserData(int *size)\n"
    "    char const * TreeKey.getUserData()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setUserData(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setUserData", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setUserData((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_root(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","root", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->root();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_parent(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","parent", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)(arg1)->parent();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_firstChild(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","firstChild", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)(arg1)->firstChild();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_nextSibling(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","nextSibling", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)(arg1)->nextSibling();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_previousSibling(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","previousSibling", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)(arg1)->previousSibling();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_hasChildren(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","hasChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)(arg1)->hasChildren();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_append(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->append();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_appendChild(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","appendChild", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->appendChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_insertBefore(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","insertBefore", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->insertBefore();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_remove(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->remove();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setOffset(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","setOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  (arg1)->setOffset(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getOffset(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","getOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (unsigned long)((sword::TreeKey const *)arg1)->getOffset();
  vresult = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setText(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getText(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (char *)((sword::TreeKey const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_compare(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (int)(arg1)->compare((sword::SWKey const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKey_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKey_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_TreeKey_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKey.decrement", 
    "    void TreeKey.decrement(int steps)\n"
    "    void TreeKey.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKey_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKey_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_TreeKey_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKey.increment", 
    "    void TreeKey.increment(int steps)\n"
    "    void TreeKey.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (bool)((sword::TreeKey const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (long)((sword::TreeKey const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_assureKeyPath__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","assureKeyPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","assureKeyPath", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->assureKeyPath((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_assureKeyPath__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","assureKeyPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->assureKeyPath();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKey_assureKeyPath(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKey_assureKeyPath__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_TreeKey_assureKeyPath__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKey.assureKeyPath", 
    "    void TreeKey.assureKeyPath(char const *keyPath)\n"
    "    void TreeKey.assureKeyPath()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_save(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","save", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  (arg1)->save();
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKey.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKey___eq__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKey.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKey___gt__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKey.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKey___lt__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKey.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKey___ge__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKey.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKey___le__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKey_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::TreeKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","sword_TreeKey_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::TreeKey *)sword_TreeKey_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassTreeKeyIdx;

SWIGINTERN VALUE
_wrap_new_TreeKeyIdx__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::TreeKeyIdx";
  sword::TreeKeyIdx *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__TreeKeyIdx,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const &","sword::TreeKeyIdx", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::TreeKeyIdx const &","sword::TreeKeyIdx", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (sword::TreeKeyIdx *)new sword::TreeKeyIdx((sword::TreeKeyIdx const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_TreeKeyIdx__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::TreeKeyIdx";
  sword::TreeKeyIdx *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::TreeKeyIdx", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::TreeKeyIdx", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::TreeKeyIdx *)new sword::TreeKeyIdx((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_TreeKeyIdx_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_TreeKeyIdx_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__TreeKeyIdx);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_TreeKeyIdx__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::TreeKeyIdx";
  sword::TreeKeyIdx *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::TreeKeyIdx", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::TreeKeyIdx *)new sword::TreeKeyIdx((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_TreeKeyIdx(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TreeKeyIdx__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_TreeKeyIdx__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_TreeKeyIdx__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "TreeKeyIdx.new", 
    "    TreeKeyIdx.new(sword::TreeKeyIdx const &ikey)\n"
    "    TreeKeyIdx.new(char const *idxPath, int fileMode)\n"
    "    TreeKeyIdx.new(char const *idxPath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_TreeKeyIdx(sword::TreeKeyIdx *arg1) {
    delete arg1;
}


/*
  Document-method: Sword::TreeKeyIdx.clone

  call-seq:
    clone -> SWKey

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx_clone(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (sword::SWKey *)((sword::TreeKeyIdx const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getLocalName(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","getLocalName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (char *)(arg1)->getLocalName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_setLocalName(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","setLocalName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setLocalName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->setLocalName((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getUserData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","getUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int *","getUserData", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< int * >(argp2);
  result = (char *)((sword::TreeKeyIdx const *)arg1)->getUserData(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getUserData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","getUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (char *)((sword::TreeKeyIdx const *)arg1)->getUserData();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKeyIdx_getUserData(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKeyIdx_getUserData__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_int, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_TreeKeyIdx_getUserData__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKeyIdx.getUserData", 
    "    char const * TreeKeyIdx.getUserData(int *size)\n"
    "    char const * TreeKeyIdx.getUserData()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_setUserData(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","setUserData", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setUserData", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setUserData((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_root(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","root", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->root();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_parent(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","parent", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)(arg1)->parent();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_firstChild(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","firstChild", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)(arg1)->firstChild();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_nextSibling(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","nextSibling", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)(arg1)->nextSibling();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_previousSibling(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","previousSibling", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)(arg1)->previousSibling();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_hasChildren(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","hasChildren", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)(arg1)->hasChildren();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_append(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","append", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->append();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_appendChild(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","appendChild", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->appendChild();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_insertBefore(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","insertBefore", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->insertBefore();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_remove(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","remove", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->remove();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_save(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","save", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->save();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_copyFrom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::TreeKeyIdx *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__TreeKeyIdx,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::TreeKeyIdx const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::TreeKeyIdx * >(argp2);
  (arg1)->copyFrom((sword::TreeKeyIdx const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_copyFrom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","copyFrom", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","copyFrom", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","copyFrom", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->copyFrom((sword::SWKey const &)*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKeyIdx_copyFrom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_TreeKeyIdx_copyFrom__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_TreeKeyIdx_copyFrom__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKeyIdx.copyFrom", 
    "    void TreeKeyIdx.copyFrom(sword::TreeKeyIdx const &ikey)\n"
    "    void TreeKeyIdx.copyFrom(sword::SWKey const &ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_setOffset(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","setOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","setOffset", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  (arg1)->setOffset(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getOffset(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","getOffset", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (unsigned long)((sword::TreeKeyIdx const *)arg1)->getOffset();
  vresult = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getLevel(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","getLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (int)(arg1)->getLevel();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKeyIdx.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx___eq__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKeyIdx.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx___gt__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKeyIdx.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx___lt__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKeyIdx.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx___ge__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::TreeKeyIdx.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_TreeKeyIdx___le__(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_setText(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_getText(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","getText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (char *)((sword::TreeKeyIdx const *)arg1)->getText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx__compare(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::TreeKeyIdx *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","_compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__TreeKeyIdx,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const &","_compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::TreeKeyIdx const &","_compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::TreeKeyIdx * >(argp2);
  result = (int)(arg1)->_compare((sword::TreeKeyIdx const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_compare(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","compare", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","compare", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","compare", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (int)(arg1)->compare((sword::SWKey const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKeyIdx_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKeyIdx_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_TreeKeyIdx_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKeyIdx.decrement", 
    "    void TreeKeyIdx.decrement(int steps)\n"
    "    void TreeKeyIdx.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_TreeKeyIdx_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_TreeKeyIdx_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKeyIdx, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_TreeKeyIdx_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "TreeKeyIdx.increment", 
    "    void TreeKeyIdx.increment(int steps)\n"
    "    void TreeKeyIdx.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::TreeKeyIdx *arg1 = (sword::TreeKeyIdx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKeyIdx const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::TreeKeyIdx * >(argp1);
  result = (bool)((sword::TreeKeyIdx const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_create(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::TreeKeyIdx::create", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::TreeKeyIdx::create((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_TreeKeyIdx_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::TreeKeyIdx *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","sword_TreeKeyIdx_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::TreeKeyIdx *)sword_TreeKeyIdx_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__TreeKeyIdx, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassVerseTreeKey;

SWIGINTERN VALUE
_wrap_new_VerseTreeKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseTreeKey";
  sword::VerseTreeKey *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","sword::VerseTreeKey", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::VerseTreeKey", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::VerseTreeKey *)new sword::VerseTreeKey(arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseTreeKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseTreeKey";
  sword::VerseTreeKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","sword::VerseTreeKey", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  result = (sword::VerseTreeKey *)new sword::VerseTreeKey(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseTreeKey__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseTreeKey";
  sword::VerseTreeKey *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","sword::VerseTreeKey", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","sword::VerseTreeKey", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::VerseTreeKey *)new sword::VerseTreeKey(arg1,(sword::SWKey const *)arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_VerseTreeKey__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::TreeKey *arg1 = (sword::TreeKey *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseTreeKey";
  sword::VerseTreeKey *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::TreeKey *","sword::VerseTreeKey", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::TreeKey * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::VerseTreeKey", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::VerseTreeKey", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::VerseTreeKey *)new sword::VerseTreeKey(arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_VerseTreeKey_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_VerseTreeKey_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__VerseTreeKey);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_VerseTreeKey__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::VerseTreeKey";
  sword::VerseTreeKey *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__VerseTreeKey,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey const &","sword::VerseTreeKey", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::VerseTreeKey const &","sword::VerseTreeKey", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (sword::VerseTreeKey *)new sword::VerseTreeKey((sword::VerseTreeKey const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_VerseTreeKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseTreeKey__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_VerseTreeKey__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_VerseTreeKey__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_VerseTreeKey__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__TreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_VerseTreeKey__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseTreeKey.new", 
    "    VerseTreeKey.new(sword::TreeKey *treeKey, char const *ikey)\n"
    "    VerseTreeKey.new(sword::TreeKey *treeKey)\n"
    "    VerseTreeKey.new(sword::TreeKey *treeKey, sword::SWKey const *ikey)\n"
    "    VerseTreeKey.new(sword::TreeKey *treeKey, char const *min, char const *max)\n"
    "    VerseTreeKey.new(sword::VerseTreeKey const &k)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_VerseTreeKey(sword::VerseTreeKey *arg1) {
    delete arg1;
}


/*
  Document-method: Sword::VerseTreeKey.clone

  call-seq:
    clone -> SWKey

Create a duplicate of the class.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey_clone(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey const *","clone", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (sword::SWKey *)((sword::VerseTreeKey const *)arg1)->clone();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_isTraversable(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey const *","isTraversable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (bool)((sword::VerseTreeKey const *)arg1)->isTraversable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_getTreeKey(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::TreeKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","getTreeKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (sword::TreeKey *)(arg1)->getTreeKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__TreeKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_positionChanged(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","positionChanged", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  (arg1)->positionChanged();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_internalPosChange_set(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","internalPosChange", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","internalPosChange", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->internalPosChange = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_internalPosChange_get(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","internalPosChange", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (bool) ((arg1)->internalPosChange);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseTreeKey_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseTreeKey_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseTreeKey_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseTreeKey.decrement", 
    "    void VerseTreeKey.decrement(int steps)\n"
    "    void VerseTreeKey.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseTreeKey_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseTreeKey_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseTreeKey_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseTreeKey.increment", 
    "    void VerseTreeKey.increment(int steps)\n"
    "    void VerseTreeKey.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_Normalize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","Normalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Normalize", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->Normalize(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_Normalize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","Normalize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  (arg1)->Normalize();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_VerseTreeKey_Normalize(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_VerseTreeKey_Normalize__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__VerseTreeKey, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_VerseTreeKey_Normalize__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "VerseTreeKey.Normalize", 
    "    void VerseTreeKey.Normalize(char autocheck)\n"
    "    void VerseTreeKey.Normalize()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_NewIndex(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey const *","NewIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  result = (long)((sword::VerseTreeKey const *)arg1)->NewIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseTreeKey.==

  call-seq:
    ==(ikey) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey___eq__(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","operator ==", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator ==", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator ==", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator ==((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseTreeKey.>

  call-seq:
    >(ikey) -> bool

Higher than comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey___gt__(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","operator >", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseTreeKey.<

  call-seq:
    <(ikey) -> bool

Lower than comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey___lt__(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","operator <", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseTreeKey.>=

  call-seq:
    >=(ikey) -> bool

Higher or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey___ge__(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","operator >=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator >=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator >=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator >=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::VerseTreeKey.<=

  call-seq:
    <=(ikey) -> bool

Lower or equal comparison operator.
*/
SWIGINTERN VALUE
_wrap_VerseTreeKey___le__(int argc, VALUE *argv, VALUE self) {
  sword::VerseTreeKey *arg1 = (sword::VerseTreeKey *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::VerseTreeKey *","operator <=", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::VerseTreeKey * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","operator <=", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","operator <=", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)(arg1)->operator <=((sword::SWKey const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_VerseTreeKey_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWKey *arg1 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::VerseTreeKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWKey *","sword_VerseTreeKey_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWKey * >(argp1);
  result = (sword::VerseTreeKey *)sword_VerseTreeKey_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__VerseTreeKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWDisplay;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWDisplay_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWDisplay_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWDisplay);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWDisplay(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWDisplay";
  sword::SWDisplay *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWDisplay *)new sword::SWDisplay();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWDisplay(sword::SWDisplay *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWDisplay_Display(int argc, VALUE *argv, VALUE self) {
  sword::SWDisplay *arg1 = (sword::SWDisplay *) 0 ;
  sword::SWModule *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWDisplay *","Display", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWDisplay * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWModule,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWModule &","Display", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWModule &","Display", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWModule * >(argp2);
  result = (char)(arg1)->Display(*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWFilter;

SWIGINTERN void
free_sword_SWFilter(sword::SWFilter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWFilter_processText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWFilter *arg1 = (sword::SWFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  sword::SWModule *arg4 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWModule const *","processText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWModule * >(argp4);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3,(sword::SWModule const *)arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWFilter_processText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWFilter *arg1 = (sword::SWFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWFilter_processText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWFilter *arg1 = (sword::SWFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (char)(arg1)->processText(*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWFilter_processText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWFilter_processText__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SWFilter_processText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWModule, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_SWFilter_processText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SWFilter.processText", 
    "    char SWFilter.processText(sword::SWBuf &text, sword::SWKey const *key, sword::SWModule const *module)\n"
    "    char SWFilter.processText(sword::SWBuf &text, sword::SWKey const *key)\n"
    "    char SWFilter.processText(sword::SWBuf &text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWFilter_getHeader(int argc, VALUE *argv, VALUE self) {
  sword::SWFilter *arg1 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilter const *","getHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilter * >(argp1);
  result = (char *)((sword::SWFilter const *)arg1)->getHeader();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWOptionFilter;

SWIGINTERN void
free_sword_SWOptionFilter(sword::SWOptionFilter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWOptionFilter_getOptionName(int argc, VALUE *argv, VALUE self) {
  sword::SWOptionFilter *arg1 = (sword::SWOptionFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWOptionFilter *","getOptionName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWOptionFilter * >(argp1);
  result = (char *)(arg1)->getOptionName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWOptionFilter_getOptionTip(int argc, VALUE *argv, VALUE self) {
  sword::SWOptionFilter *arg1 = (sword::SWOptionFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWOptionFilter *","getOptionTip", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWOptionFilter * >(argp1);
  result = (char *)(arg1)->getOptionTip();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWOptionFilter_getOptionValue(int argc, VALUE *argv, VALUE self) {
  sword::SWOptionFilter *arg1 = (sword::SWOptionFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWOptionFilter *","getOptionValue", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWOptionFilter * >(argp1);
  result = (char *)(arg1)->getOptionValue();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWOptionFilter_setOptionValue(int argc, VALUE *argv, VALUE self) {
  sword::SWOptionFilter *arg1 = (sword::SWOptionFilter *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWOptionFilter *","setOptionValue", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWOptionFilter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setOptionValue", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setOptionValue((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWOptionFilter_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWFilter *arg1 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWOptionFilter *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilter *","sword_SWOptionFilter_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWFilter * >(argp1);
  result = (sword::SWOptionFilter *)sword_SWOptionFilter_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWFilterMgr;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWFilterMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWFilterMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWFilterMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWFilterMgr(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWFilterMgr";
  sword::SWFilterMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWFilterMgr *)new sword::SWFilterMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWFilterMgr(sword::SWFilterMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWFilterMgr_setParentMgr(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  sword::SWMgr *arg2 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","setParentMgr", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWMgr *","setParentMgr", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWMgr * >(argp2);
  (arg1)->setParentMgr(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWFilterMgr_getParentMgr(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","getParentMgr", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  result = (sword::SWMgr *)(arg1)->getParentMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassStringMgr;

SWIGINTERN VALUE
_wrap_StringMgr_setSystemStringMgr(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *arg1 = (sword::StringMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StringMgr *","sword::StringMgr::setSystemStringMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::StringMgr * >(argp1);
  sword::StringMgr::setSystemStringMgr(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_getSystemStringMgr(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::StringMgr *)sword::StringMgr::getSystemStringMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_hasUTF8Support(int argc, VALUE *argv, VALUE self) {
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (bool)sword::StringMgr::hasUTF8Support();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_upperUTF8__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *arg1 = (sword::StringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StringMgr const *","upperUTF8", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperUTF8", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","upperUTF8", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (char *)((sword::StringMgr const *)arg1)->upperUTF8(arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_upperUTF8__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *arg1 = (sword::StringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StringMgr const *","upperUTF8", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperUTF8", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((sword::StringMgr const *)arg1)->upperUTF8(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringMgr_upperUTF8(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__StringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_StringMgr_upperUTF8__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__StringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_StringMgr_upperUTF8__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringMgr.upperUTF8", 
    "    char * StringMgr.upperUTF8(char *text, unsigned int max)\n"
    "    char * StringMgr.upperUTF8(char *text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_upperLatin1__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *arg1 = (sword::StringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StringMgr const *","upperLatin1", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperLatin1", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","upperLatin1", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (char *)((sword::StringMgr const *)arg1)->upperLatin1(arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StringMgr_upperLatin1__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::StringMgr *arg1 = (sword::StringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StringMgr const *","upperLatin1", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperLatin1", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((sword::StringMgr const *)arg1)->upperLatin1(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_StringMgr_upperLatin1(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__StringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_StringMgr_upperLatin1__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__StringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_StringMgr_upperLatin1__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "StringMgr.upperLatin1", 
    "    char * StringMgr.upperLatin1(char *text, unsigned int max)\n"
    "    char * StringMgr.upperLatin1(char *text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_toupperstr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  unsigned int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","sword::toupperstr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","sword::toupperstr", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (char *)sword::toupperstr(arg1,arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_toupperstr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","sword::toupperstr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char *)sword::toupperstr(arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_toupperstr_utf8__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  unsigned int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","sword::toupperstr_utf8", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","sword::toupperstr_utf8", 2, argv[1] ));
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (char *)sword::toupperstr_utf8(arg1,arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_toupperstr_utf8__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","sword::toupperstr_utf8", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char *)sword::toupperstr_utf8(arg1);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_toupperstr_utf8(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_toupperstr_utf8__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_toupperstr_utf8__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "toupperstr_utf8", 
    "    char * toupperstr_utf8(char *t, unsigned int max)\n"
    "    char * toupperstr_utf8(char *t)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_toupperstr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBuf &","sword::toupperstr", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","sword::toupperstr", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWBuf * >(argp1);
  result = (sword::SWBuf *) &sword::toupperstr(*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_toupperstr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_toupperstr__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_toupperstr__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_toupperstr__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "toupperstr", 
    "    sword::SWBuf & toupperstr(char *t, unsigned int max)\n"
    "    sword::SWBuf & toupperstr(char *t)\n"
    "    sword::SWBuf & toupperstr(sword::SWBuf &b)\n");
  
  return Qnil;
}


swig_class SwigClassPyStringMgr;

SWIGINTERN VALUE
_wrap_PyStringMgr_upperUTF8__SWIG_0(int argc, VALUE *argv, VALUE self) {
  PyStringMgr *arg1 = (PyStringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyStringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyStringMgr const *","upperUTF8", 1, self )); 
  }
  arg1 = reinterpret_cast< PyStringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperUTF8", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","upperUTF8", 3, argv[1] ));
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (char *)((PyStringMgr const *)arg1)->upperUTF8(arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyStringMgr_upperUTF8__SWIG_1(int argc, VALUE *argv, VALUE self) {
  PyStringMgr *arg1 = (PyStringMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyStringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyStringMgr const *","upperUTF8", 1, self )); 
  }
  arg1 = reinterpret_cast< PyStringMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","upperUTF8", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((PyStringMgr const *)arg1)->upperUTF8(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_PyStringMgr_upperUTF8(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_PyStringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_PyStringMgr_upperUTF8__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_PyStringMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_PyStringMgr_upperUTF8__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "PyStringMgr.upperUTF8", 
    "    char * PyStringMgr.upperUTF8(char *text, unsigned int max)\n"
    "    char * PyStringMgr.upperUTF8(char *text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyStringMgr_getUpper(int argc, VALUE *argv, VALUE self) {
  PyStringMgr *arg1 = (PyStringMgr *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyStringMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyStringMgr const *","getUpper", 1, self )); 
  }
  arg1 = reinterpret_cast< PyStringMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","getUpper", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ((PyStringMgr const *)arg1)->getUpper(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN void
free_PyStringMgr(PyStringMgr *arg1) {
    delete arg1;
}

swig_class SwigClassSWSearchable;

SWIGINTERN void
free_sword_SWSearchable(sword::SWSearchable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWSearchable_deleteSearchFramework(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","deleteSearchFramework", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  (arg1)->deleteSearchFramework();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_hasSearchFramework(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","hasSearchFramework", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  result = (bool)(arg1)->hasSearchFramework();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_isSearchOptimallySupported(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  sword::SWKey *arg5 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","isSearchOptimallySupported", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchOptimallySupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchOptimallySupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","isSearchOptimallySupported", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWKey *","isSearchOptimallySupported", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWKey * >(argp5);
  result = (bool)(arg1)->isSearchOptimallySupported((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_isSearchSupported__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  sword::SWKey *arg5 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","isSearchSupported", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWKey *","isSearchSupported", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWKey * >(argp5);
  result = (bool)sword_SWSearchable_isSearchSupported__SWIG_0(arg1,(char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_isSearchSupported__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","isSearchSupported", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)sword_SWSearchable_isSearchSupported__SWIG_0(arg1,(char const *)arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_isSearchSupported__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)sword_SWSearchable_isSearchSupported__SWIG_0(arg1,(char const *)arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_isSearchSupported__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)sword_SWSearchable_isSearchSupported__SWIG_0(arg1,(char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWSearchable_isSearchSupported(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWSearchable_isSearchSupported__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWSearchable_isSearchSupported__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWSearchable_isSearchSupported__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWKey, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_SWSearchable_isSearchSupported__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "isSearchSupported", 
    "    bool isSearchSupported(char const *istr, int searchType, int flags, sword::SWKey *scope)\n"
    "    bool isSearchSupported(char const *istr, int searchType, int flags)\n"
    "    bool isSearchSupported(char const *istr, int searchType)\n"
    "    bool isSearchSupported(char const *istr)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_doSearch__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  sword::SWKey *arg5 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","doSearch", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWKey *","doSearch", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWKey * >(argp5);
  result = (sword::ListKey *) &sword_SWSearchable_doSearch__SWIG_0(arg1,(char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_doSearch__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","doSearch", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (sword::ListKey *) &sword_SWSearchable_doSearch__SWIG_0(arg1,(char const *)arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_doSearch__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (sword::ListKey *) &sword_SWSearchable_doSearch__SWIG_0(arg1,(char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearchable_doSearch__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::ListKey *) &sword_SWSearchable_doSearch__SWIG_0(arg1,(char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWSearchable_doSearch(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWSearchable_doSearch__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWSearchable_doSearch__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWSearchable_doSearch__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWSearchable, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWKey, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_SWSearchable_doSearch__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "doSearch", 
    "    sword::ListKey & doSearch(char const *istr, int searchType, int flags, sword::SWKey *scope)\n"
    "    sword::ListKey & doSearch(char const *istr, int searchType, int flags)\n"
    "    sword::ListKey & doSearch(char const *istr, int searchType)\n"
    "    sword::ListKey & doSearch(char const *istr)\n");
  
  return Qnil;
}


swig_class SwigClassSWModule;

SWIGINTERN VALUE
_wrap_SWModule_terminateSearch_set(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","terminateSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","terminateSearch", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->terminateSearch = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_terminateSearch_get(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","terminateSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool) ((arg1)->terminateSearch);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWModule(sword::SWModule *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWModule_Error(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Error", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char)(arg1)->Error();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_isUnicode(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","isUnicode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool)((sword::SWModule const *)arg1)->isUnicode();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getConfigEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getConfigEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getConfigEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((sword::SWModule const *)arg1)->getConfigEntry((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getEntrySize(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getEntrySize", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (int)((sword::SWModule const *)arg1)->getEntrySize();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","setKey", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char)(arg1)->setKey((sword::SWKey const *)arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","setKey", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","setKey", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char)(arg1)->setKey((sword::SWKey const &)*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_setKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_setKey__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_setKey__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.setKey", 
    "    char SWModule.setKey(sword::SWKey const *ikey)\n"
    "    char SWModule.setKey(sword::SWKey const &ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_SetKey__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","SetKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","SetKey", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char)(arg1)->SetKey((sword::SWKey const *)arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_SetKey__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","SetKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","SetKey", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","SetKey", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char)(arg1)->SetKey((sword::SWKey const &)*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_SetKey(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_SetKey__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_SetKey__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.SetKey", 
    "    char SWModule.SetKey(sword::SWKey const *ikey)\n"
    "    char SWModule.SetKey(sword::SWKey const &ikey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Key__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Key", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWKey,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const &","Key", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWKey const &","Key", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char)(arg1)->Key((sword::SWKey const &)*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getKey(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWKey *)((sword::SWModule const *)arg1)->getKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Key__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","Key", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWKey *) &((sword::SWModule const *)arg1)->Key();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Key(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Key__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Key__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Key", 
    "    sword::SWKey & SWModule.Key(sword::SWKey const &ikey)\n"
    "    sword::SWKey & SWModule.Key()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_KeyText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","KeyText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","KeyText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->KeyText((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_KeyText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","KeyText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)(arg1)->KeyText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_KeyText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_KeyText__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_KeyText__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.KeyText", 
    "    char const * SWModule.KeyText(char const *ikeytext)\n"
    "    char const * SWModule.KeyText()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getKeyText(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getKeyText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)((sword::SWModule const *)arg1)->getKeyText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (long)((sword::SWModule const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Index__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","Index", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (long)((sword::SWModule const *)arg1)->Index();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Index__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Index", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","Index", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (long)(arg1)->Index(arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Index(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Index__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_Index__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Index", 
    "    long SWModule.Index()\n"
    "    long SWModule.Index(long iindex)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Display(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Display", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char)(arg1)->Display();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getDisplay(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWDisplay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getDisplay", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWDisplay *)((sword::SWModule const *)arg1)->getDisplay();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setDisplay(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWDisplay *arg2 = (sword::SWDisplay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setDisplay", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWDisplay *","setDisplay", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWDisplay * >(argp2);
  (arg1)->setDisplay(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Disp__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWDisplay *arg2 = (sword::SWDisplay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWDisplay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Disp", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWDisplay *","Disp", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWDisplay * >(argp2);
  result = (sword::SWDisplay *)(arg1)->Disp(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Disp__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWDisplay *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Disp", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWDisplay *)(arg1)->Disp();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Disp(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Disp__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Disp__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Disp", 
    "    sword::SWDisplay * SWModule.Disp(sword::SWDisplay *idisp)\n"
    "    sword::SWDisplay * SWModule.Disp()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Name__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","Name", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)((sword::SWModule const *)arg1)->Name();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Name__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Name", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","Name", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->Name((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Name(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Name__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Name__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Name", 
    "    char * SWModule.Name()\n"
    "    char * SWModule.Name(char const *imodname)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Description__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","Description", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)((sword::SWModule const *)arg1)->Description();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Description__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Description", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","Description", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->Description((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Description(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Description__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Description__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Description", 
    "    char * SWModule.Description()\n"
    "    char * SWModule.Description(char const *imoddesc)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","Type", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)((sword::SWModule const *)arg1)->Type();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Type", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","Type", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->Type((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Type(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Type__SWIG_0(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Type__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Type", 
    "    char * SWModule.Type()\n"
    "    char * SWModule.Type(char const *imodtype)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Direction__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  signed char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  signed char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Direction", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_signed_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "signed char","Direction", 2, argv[0] ));
  } 
  arg2 = static_cast< signed char >(val2);
  result = (char)(arg1)->Direction(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Direction__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Direction", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char)(arg1)->Direction();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Direction(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Direction__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_signed_SS_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_Direction__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Direction", 
    "    char SWModule.Direction(signed char newdir)\n"
    "    char SWModule.Direction()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Encoding__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  signed char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  signed char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Encoding", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_signed_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "signed char","Encoding", 2, argv[0] ));
  } 
  arg2 = static_cast< signed char >(val2);
  result = (char)(arg1)->Encoding(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Encoding__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Encoding", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char)(arg1)->Encoding();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Encoding(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Encoding__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_signed_SS_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_Encoding__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Encoding", 
    "    char SWModule.Encoding(signed char enc)\n"
    "    char SWModule.Encoding()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Markup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  signed char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  signed char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Markup", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_signed_SS_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "signed char","Markup", 2, argv[0] ));
  } 
  arg2 = static_cast< signed char >(val2);
  result = (char)(arg1)->Markup(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Markup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Markup", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char)(arg1)->Markup();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Markup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Markup__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_signed_SS_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_Markup__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Markup", 
    "    char SWModule.Markup(signed char markup)\n"
    "    char SWModule.Markup()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Lang__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Lang", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","Lang", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->Lang((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_Lang__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","Lang", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)(arg1)->Lang();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_Lang(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_Lang__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_Lang__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.Lang", 
    "    char * SWModule.Lang(char const *imodlang)\n"
    "    char * SWModule.Lang()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWKey *)((sword::SWModule const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getRawEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","getRawEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)(arg1)->getRawEntry();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWModule::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::SWModule::createModule((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWModule_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SWModule.setEntry", 
    "    void SWModule.setEntry(char const *inbuf, long len)\n"
    "    void SWModule.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.decrement", 
    "    void SWModule.decrement(int steps)\n"
    "    void SWModule.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SWModule_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.increment", 
    "    void SWModule.increment(int steps)\n"
    "    void SWModule.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_AddRenderFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","AddRenderFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","AddRenderFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->AddRenderFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getRenderFilters(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::FilterList *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getRenderFilters", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::FilterList *) &((sword::SWModule const *)arg1)->getRenderFilters();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RemoveRenderFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RemoveRenderFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","RemoveRenderFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->RemoveRenderFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_ReplaceRenderFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  sword::SWFilter *arg3 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","ReplaceRenderFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","ReplaceRenderFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWFilter *","ReplaceRenderFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWFilter * >(argp3);
  result = (sword::SWModule *) &(arg1)->ReplaceRenderFilter(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_renderFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","renderFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","renderFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","renderFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","renderFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  (arg1)->renderFilter(*arg2,(sword::SWKey const *)arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_AddEncodingFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","AddEncodingFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","AddEncodingFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->AddEncodingFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RemoveEncodingFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RemoveEncodingFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","RemoveEncodingFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->RemoveEncodingFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_ReplaceEncodingFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  sword::SWFilter *arg3 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","ReplaceEncodingFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","ReplaceEncodingFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWFilter *","ReplaceEncodingFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWFilter * >(argp3);
  result = (sword::SWModule *) &(arg1)->ReplaceEncodingFilter(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_encodingFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","encodingFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","encodingFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","encodingFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","encodingFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  (arg1)->encodingFilter(*arg2,(sword::SWKey const *)arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_AddStripFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","AddStripFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","AddStripFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->AddStripFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_AddRawFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWFilter *arg2 = (sword::SWFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","AddRawFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWFilter *","AddRawFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->AddRawFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_stripFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","stripFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","stripFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","stripFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","stripFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  (arg1)->stripFilter(*arg2,(sword::SWKey const *)arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_rawFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","rawFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","rawFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  (arg1)->rawFilter(*arg2,(sword::SWKey const *)arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_AddOptionFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWOptionFilter *arg2 = (sword::SWOptionFilter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","AddOptionFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWOptionFilter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWOptionFilter *","AddOptionFilter", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWOptionFilter * >(argp2);
  result = (sword::SWModule *) &(arg1)->AddOptionFilter(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_optionFilter(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","optionFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","optionFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","optionFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","optionFilter", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  (arg1)->optionFilter(*arg2,(sword::SWKey const *)arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_StripText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","StripText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","StripText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","StripText", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (char *)(arg1)->StripText((char const *)arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_StripText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","StripText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","StripText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->StripText((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_StripText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","StripText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)(arg1)->StripText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RenderText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RenderText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RenderText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","RenderText", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","RenderText", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (char *)(arg1)->RenderText((char const *)arg2,arg3,arg4);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RenderText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RenderText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RenderText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","RenderText", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (char *)(arg1)->RenderText((char const *)arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RenderText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RenderText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RenderText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->RenderText((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RenderText__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RenderText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)(arg1)->RenderText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getRenderHeader(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","getRenderHeader", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (char *)((sword::SWModule const *)arg1)->getRenderHeader();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_StripText__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","StripText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","StripText", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char *)(arg1)->StripText((sword::SWKey const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_StripText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_StripText__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_StripText__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_StripText__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWModule_StripText__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SWModule.StripText", 
    "    char const * SWModule.StripText(char const *buf, int len)\n"
    "    char const * SWModule.StripText(char const *buf)\n"
    "    char const * SWModule.StripText()\n"
    "    char const * SWModule.StripText(sword::SWKey const *tmpKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_RenderText__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","RenderText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","RenderText", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (char *)(arg1)->RenderText((sword::SWKey const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule_RenderText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWModule_RenderText__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_RenderText__SWIG_4(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule_RenderText__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWModule_RenderText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWModule_RenderText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SWModule.RenderText", 
    "    char const * SWModule.RenderText(char const *buf, int len, bool render)\n"
    "    char const * SWModule.RenderText(char const *buf, int len)\n"
    "    char const * SWModule.RenderText(char const *buf)\n"
    "    char const * SWModule.RenderText()\n"
    "    char const * SWModule.RenderText(sword::SWKey const *tmpKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_setSkipConsecutiveLinks(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","setSkipConsecutiveLinks", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setSkipConsecutiveLinks", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setSkipConsecutiveLinks(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getSkipConsecutiveLinks(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","getSkipConsecutiveLinks", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool)(arg1)->getSkipConsecutiveLinks();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_isLinked(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","isLinked", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (bool)((sword::SWModule const *)arg1)->isLinked((sword::SWKey const *)arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::SWModule const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_processEntryAttributes(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","processEntryAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","processEntryAttributes", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  ((sword::SWModule const *)arg1)->processEntryAttributes(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_isProcessEntryAttributes(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","isProcessEntryAttributes", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool)((sword::SWModule const *)arg1)->isProcessEntryAttributes();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_deleteSearchFramework(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","deleteSearchFramework", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  (arg1)->deleteSearchFramework();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_hasSearchFramework(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","hasSearchFramework", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (bool)(arg1)->hasSearchFramework();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWModule.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_SWModule___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWModule___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWModule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWModule___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWModule.__lshift__", 
    "    sword::SWModule & SWModule.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & SWModule.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWSearchable *arg1 = (sword::SWSearchable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWSearchable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWSearchable *","sword_SWModule_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWSearchable * >(argp1);
  result = (sword::SWModule *)sword_SWModule_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getEntryAttributesMap(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","getEntryAttributesMap", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *) &sword_SWModule_getEntryAttributesMap(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWModule_getConfigMap(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","getConfigMap", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *)sword_SWModule_getConfigMap(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWMgr;

SWIGINTERN VALUE
_wrap_SWMgr_isICU_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_bool(static_cast< bool >(sword::SWMgr::isICU));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWMgr_isICU_set(VALUE self, VALUE _val) {
  {
    bool val;
    int res = SWIG_AsVal_bool(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::SWMgr::isICU""' of type '""bool""'");
    }
    sword::SWMgr::isICU = static_cast< bool >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_globalConfPath_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(sword::SWMgr::globalConfPath);
  return _val;
}


SWIGINTERN VALUE
_wrap_SWMgr_globalConfPath_set(VALUE self, VALUE _val) {
  {
    char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
    int res = SWIG_AsCharPtrAndSize(_val, &cptr, &csize, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::SWMgr::globalConfPath""' of type '""char const *""'");
    }
    if (alloc == SWIG_NEWOBJ) {
      sword::SWMgr::globalConfPath = cptr;
    } else {
      sword::SWMgr::globalConfPath = csize ? (char const *)reinterpret_cast< char* >(memcpy((new char[csize]), cptr, sizeof(char)*(csize))) : 0;
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getHomeDir(int argc, VALUE *argv, VALUE self) {
  sword::SWBuf result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = sword::SWMgr::getHomeDir();
  vresult = SWIG_NewPointerObj((new sword::SWBuf(static_cast< const sword::SWBuf& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_config_set(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","config", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWConfig, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","config", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  if (arg1) (arg1)->config = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_config_get(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWConfig *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","config", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (sword::SWConfig *) ((arg1)->config);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_sysConfig_set(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","sysConfig", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWConfig, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","sysConfig", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  if (arg1) (arg1)->sysConfig = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_sysConfig_get(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWConfig *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","sysConfig", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (sword::SWConfig *) ((arg1)->sysConfig);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_prefixPath_set(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","prefixPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","prefixPath", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg1->prefixPath) delete[] arg1->prefixPath;
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(arg2)) + 1;
    arg1->prefixPath = (char *)reinterpret_cast< char* >(memcpy((new char[size]), reinterpret_cast< const char * >(arg2), sizeof(char)*(size)));
  } else {
    arg1->prefixPath = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_prefixPath_get(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","prefixPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (char *) ((arg1)->prefixPath);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_configPath_set(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","configPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","configPath", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg1->configPath) delete[] arg1->configPath;
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(arg2)) + 1;
    arg1->configPath = (char *)reinterpret_cast< char* >(memcpy((new char[size]), reinterpret_cast< const char * >(arg2), sizeof(char)*(size)));
  } else {
    arg1->configPath = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_configPath_get(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","configPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (char *) ((arg1)->configPath);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getModule", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *)(arg1)->getModule((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr const *","getModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getModule", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *)((sword::SWMgr const *)arg1)->getModule((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWMgr_getModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWMgr_getModule__SWIG_0(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWMgr_getModule__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWMgr.getModule", 
    "    sword::SWModule const * SWMgr.getModule(char const *modName)\n"
    "    sword::SWModule const * SWMgr.getModule(char const *modName)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  bool arg3 ;
  sword::SWFilterMgr *arg4 = (sword::SWFilterMgr *) 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWFilterMgr * >(argp4);
  ecode5 = SWIG_AsVal_bool(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 5, argv[4] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (sword::SWMgr *)new sword::SWMgr(arg1,arg2,arg3,arg4,arg5);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  bool arg3 ;
  sword::SWFilterMgr *arg4 = (sword::SWFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWFilterMgr * >(argp4);
  result = (sword::SWMgr *)new sword::SWMgr(arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  ecode3 = SWIG_AsVal_bool(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 3, argv[2] ));
  } 
  arg3 = static_cast< bool >(val3);
  result = (sword::SWMgr *)new sword::SWMgr(arg1,arg2,arg3);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  result = (sword::SWMgr *)new sword::SWMgr(arg1,arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_4(int argc, VALUE *argv, VALUE self) {
  sword::SWConfig *arg1 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWConfig *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWConfig * >(argp1);
  result = (sword::SWMgr *)new sword::SWMgr(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_5(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWMgr *)new sword::SWMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_6(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (sword::SWMgr *)new sword::SWMgr(arg1,arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_7(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  result = (sword::SWMgr *)new sword::SWMgr(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  sword::SWFilterMgr *arg3 = (sword::SWFilterMgr *) 0 ;
  bool arg4 ;
  bool arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< sword::SWFilterMgr * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 4, argv[3] ));
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 5, argv[4] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (sword::SWMgr *)new sword::SWMgr((char const *)arg1,arg2,arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_9(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  sword::SWFilterMgr *arg3 = (sword::SWFilterMgr *) 0 ;
  bool arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< sword::SWFilterMgr * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 4, argv[3] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (sword::SWMgr *)new sword::SWMgr((char const *)arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_10(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  sword::SWFilterMgr *arg3 = (sword::SWFilterMgr *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword::SWMgr", 3, argv[2] )); 
  }
  arg3 = reinterpret_cast< sword::SWFilterMgr * >(argp3);
  result = (sword::SWMgr *)new sword::SWMgr((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_11(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","sword::SWMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< bool >(val2);
  result = (sword::SWMgr *)new sword::SWMgr((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWMgr__SWIG_12(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWMgr";
  sword::SWMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWMgr *)new sword::SWMgr((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_SWMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs;
  if (argc > 5) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_SWMgr__SWIG_5(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWMgr__SWIG_4(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWMgr__SWIG_7(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SWMgr__SWIG_12(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_SWMgr__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SWMgr__SWIG_6(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SWMgr__SWIG_11(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_SWMgr__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_SWMgr__SWIG_10(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SWMgr__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_SWMgr__SWIG_9(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWConfig, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_SWMgr__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWFilterMgr, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_SWMgr__SWIG_8(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SWMgr.new", 
    "    SWMgr.new(sword::SWConfig *iconfig, sword::SWConfig *isysconfig, bool autoload, sword::SWFilterMgr *filterMgr, bool multiMod)\n"
    "    SWMgr.new(sword::SWConfig *iconfig, sword::SWConfig *isysconfig, bool autoload, sword::SWFilterMgr *filterMgr)\n"
    "    SWMgr.new(sword::SWConfig *iconfig, sword::SWConfig *isysconfig, bool autoload)\n"
    "    SWMgr.new(sword::SWConfig *iconfig, sword::SWConfig *isysconfig)\n"
    "    SWMgr.new(sword::SWConfig *iconfig)\n"
    "    SWMgr.new()\n"
    "    SWMgr.new(sword::SWFilterMgr *filterMgr, bool multiMod)\n"
    "    SWMgr.new(sword::SWFilterMgr *filterMgr)\n"
    "    SWMgr.new(char const *iConfigPath, bool autoload, sword::SWFilterMgr *filterMgr, bool multiMod, bool augmentHome)\n"
    "    SWMgr.new(char const *iConfigPath, bool autoload, sword::SWFilterMgr *filterMgr, bool multiMod)\n"
    "    SWMgr.new(char const *iConfigPath, bool autoload, sword::SWFilterMgr *filterMgr)\n"
    "    SWMgr.new(char const *iConfigPath, bool autoload)\n"
    "    SWMgr.new(char const *iConfigPath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_SWMgr(sword::SWMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWMgr_augmentModules__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","augmentModules", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","augmentModules", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","augmentModules", 3, argv[1] ));
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->augmentModules((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_augmentModules__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","augmentModules", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","augmentModules", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->augmentModules((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWMgr_augmentModules(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWMgr_augmentModules__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWMgr_augmentModules__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "SWMgr.augmentModules", 
    "    void SWMgr.augmentModules(char const *path, bool multiMod)\n"
    "    void SWMgr.augmentModules(char const *path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_deleteModule(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","deleteModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","deleteModule", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->deleteModule((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_InstallScan(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","InstallScan", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","InstallScan", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->InstallScan((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_Load(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","Load", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (signed char)(arg1)->Load();
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_setGlobalOption(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","setGlobalOption", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setGlobalOption", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setGlobalOption", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->setGlobalOption((char const *)arg2,(char const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOption(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOption", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getGlobalOption", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->getGlobalOption((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOptionTip(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOptionTip", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getGlobalOptionTip", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->getGlobalOptionTip((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOptions(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::StringList result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOptions", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (arg1)->getGlobalOptions();
  vresult = swig::from(static_cast< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOptionValues(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::StringList result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOptionValues", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getGlobalOptionValues", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (arg1)->getGlobalOptionValues((char const *)arg2);
  vresult = swig::from(static_cast< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_filterText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::SWBuf *arg3 = 0 ;
  sword::SWKey *arg4 = (sword::SWKey *) 0 ;
  sword::SWModule *arg5 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","filterText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","filterText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf &","filterText", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","filterText", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWKey const *","filterText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWKey * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWModule const *","filterText", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWModule * >(argp5);
  result = (char)(arg1)->filterText((char const *)arg2,*arg3,(sword::SWKey const *)arg4,(sword::SWModule const *)arg5);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_filterText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::SWBuf *arg3 = 0 ;
  sword::SWKey *arg4 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","filterText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","filterText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf &","filterText", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","filterText", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWKey const *","filterText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWKey * >(argp4);
  result = (char)(arg1)->filterText((char const *)arg2,*arg3,(sword::SWKey const *)arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_filterText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::SWBuf *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","filterText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","filterText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf &","filterText", 3, argv[1] )); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","filterText", 3, argv[1])); 
  }
  arg3 = reinterpret_cast< sword::SWBuf * >(argp3);
  result = (char)(arg1)->filterText((char const *)arg2,*arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWMgr_filterText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SWMgr_filterText__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWKey, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_SWMgr_filterText__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWKey, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWModule, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_SWMgr_filterText__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "SWMgr.filterText", 
    "    char SWMgr.filterText(char const *filterName, sword::SWBuf &text, sword::SWKey const *key, sword::SWModule const *module)\n"
    "    char SWMgr.filterText(char const *filterName, sword::SWBuf &text, sword::SWKey const *key)\n"
    "    char SWMgr.filterText(char const *filterName, sword::SWBuf &text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_setCipherKey(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","setCipherKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setCipherKey", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setCipherKey", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (signed char)(arg1)->setCipherKey((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOptionsVector(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOptionsVector", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = sword_SWMgr_getGlobalOptionsVector(arg1);
  vresult = swig::from(static_cast< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getGlobalOptionValuesVector(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getGlobalOptionValuesVector", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getGlobalOptionValuesVector", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = sword_SWMgr_getGlobalOptionValuesVector(arg1,(char const *)arg2);
  vresult = swig::from(static_cast< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getModules(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getModules", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  result = (std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *) &sword_SWMgr_getModules(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWMgr_getModuleAt(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = (sword::SWMgr *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr *","getModuleAt", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","getModuleAt", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (sword::SWModule *)sword_SWMgr_getModuleAt(arg1,arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassDirEntry;

SWIGINTERN VALUE
_wrap_DirEntry_name_set(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","name", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","name", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->name = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntry_name_get(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","name", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->name);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::DirEntry.size

  call-seq:
    size -> unsigned long

Size or Length of the DirEntry.
*/

/*
  Document-method: Sword::DirEntry.size=

  call-seq:
    size=(x) -> unsigned long

Size or Length of the DirEntry.
*/
SWIGINTERN VALUE
_wrap_DirEntry_size_set(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned long","size", 2, argv[0] ));
  } 
  arg2 = static_cast< unsigned long >(val2);
  if (arg1) (arg1)->size = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntry_size_get(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","size", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  result = (unsigned long) ((arg1)->size);
  vresult = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntry_isDirectory_set(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","isDirectory", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","isDirectory", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->isDirectory = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_DirEntry_isDirectory_get(int argc, VALUE *argv, VALUE self) {
  sword::DirEntry *arg1 = (sword::DirEntry *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__DirEntry, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::DirEntry *","isDirectory", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::DirEntry * >(argp1);
  result = (bool) ((arg1)->isDirectory);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_DirEntry_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_DirEntry_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__DirEntry);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_DirEntry(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::DirEntry";
  sword::DirEntry *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::DirEntry *)new sword::DirEntry();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_DirEntry(sword::DirEntry *arg1) {
    delete arg1;
}

swig_class SwigClassFileDesc;

SWIGINTERN VALUE
_wrap_FileDesc_getFd(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","getFd", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  result = (int)(arg1)->getFd();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_seek(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  long arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","seek", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","seek", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","seek", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (long)(arg1)->seek(arg2,arg3);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_read(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *arg2 = (void *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  long val3 ;
  int ecode3 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","read", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "void *","read", 2, argv[0] )); 
  }
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","read", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  result = (long)(arg1)->read(arg2,arg3);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_write(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *arg2 = (void *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  long val3 ;
  int ecode3 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","write", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "void const *","write", 2, argv[0] )); 
  }
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","write", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  result = (long)(arg1)->write((void const *)arg2,arg3);
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_path_set(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","path", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","path", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg1->path) delete[] arg1->path;
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(arg2)) + 1;
    arg1->path = (char *)reinterpret_cast< char* >(memcpy((new char[size]), reinterpret_cast< const char * >(arg2), sizeof(char)*(size)));
  } else {
    arg1->path = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_path_get(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","path", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  result = (char *) ((arg1)->path);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_mode_set(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","mode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","mode", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->mode = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_mode_get(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","mode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  result = (int) ((arg1)->mode);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_perms_set(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","perms", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","perms", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->perms = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_perms_get(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","perms", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  result = (int) ((arg1)->perms);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_tryDowngrade_set(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","tryDowngrade", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","tryDowngrade", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->tryDowngrade = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileDesc_tryDowngrade_get(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","tryDowngrade", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  result = (bool) ((arg1)->tryDowngrade);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassFileMgr;

SWIGINTERN VALUE
_wrap_FileMgr_CREAT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::CREAT));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_CREAT_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::CREAT""' of type '""int""'");
    }
    sword::FileMgr::CREAT = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_APPEND_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::APPEND));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_APPEND_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::APPEND""' of type '""int""'");
    }
    sword::FileMgr::APPEND = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_TRUNC_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::TRUNC));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_TRUNC_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::TRUNC""' of type '""int""'");
    }
    sword::FileMgr::TRUNC = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_RDONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::RDONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_RDONLY_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::RDONLY""' of type '""int""'");
    }
    sword::FileMgr::RDONLY = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_RDWR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::RDWR));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_RDWR_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::RDWR""' of type '""int""'");
    }
    sword::FileMgr::RDWR = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_WRONLY_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::WRONLY));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_WRONLY_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::WRONLY""' of type '""int""'");
    }
    sword::FileMgr::WRONLY = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_IREAD_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::IREAD));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_IREAD_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::IREAD""' of type '""int""'");
    }
    sword::FileMgr::IREAD = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_IWRITE_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::FileMgr::IWRITE));
  return _val;
}


SWIGINTERN VALUE
_wrap_FileMgr_IWRITE_set(VALUE self, VALUE _val) {
  {
    int val;
    int res = SWIG_AsVal_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::FileMgr::IWRITE""' of type '""int""'");
    }
    sword::FileMgr::IWRITE = static_cast< int >(val);
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_maxFiles_set(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","maxFiles", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","maxFiles", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->maxFiles = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_maxFiles_get(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","maxFiles", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  result = (int) ((arg1)->maxFiles);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_getSystemFileMgr(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::FileMgr *)sword::FileMgr::getSystemFileMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_setSystemFileMgr(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","sword::FileMgr::setSystemFileMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  sword::FileMgr::setSystemFileMgr(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_FileMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::FileMgr";
  sword::FileMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","sword::FileMgr", 1, argv[0] ));
  } 
  arg1 = static_cast< int >(val1);
  result = (sword::FileMgr *)new sword::FileMgr(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FileMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FileMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__FileMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FileMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::FileMgr";
  sword::FileMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::FileMgr *)new sword::FileMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FileMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_FileMgr__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_FileMgr__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "FileMgr.new", 
    "    FileMgr.new(int maxFiles)\n"
    "    FileMgr.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_FileMgr(sword::FileMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FileMgr_open__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  sword::FileDesc *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","open", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","open", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","open", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","open", 4, argv[2] ));
  } 
  arg4 = static_cast< bool >(val4);
  result = (sword::FileDesc *)(arg1)->open((char const *)arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_open__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  sword::FileDesc *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","open", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","open", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","open", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","open", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_bool(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","open", 5, argv[3] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (sword::FileDesc *)(arg1)->open((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_open__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  sword::FileDesc *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","open", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","open", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","open", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","open", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (sword::FileDesc *)(arg1)->open((char const *)arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_open__SWIG_3(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  sword::FileDesc *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","open", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","open", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","open", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (sword::FileDesc *)(arg1)->open((char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FileMgr_open(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FileMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FileMgr_open__SWIG_3(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FileMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FileMgr_open__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FileMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FileMgr_open__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FileMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_FileMgr_open__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "FileMgr.open", 
    "    sword::FileDesc * FileMgr.open(char const *path, int mode, bool tryDowngrade)\n"
    "    sword::FileDesc * FileMgr.open(char const *path, int mode, int perms, bool tryDowngrade)\n"
    "    sword::FileDesc * FileMgr.open(char const *path, int mode, int perms)\n"
    "    sword::FileDesc * FileMgr.open(char const *path, int mode)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_close(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  sword::FileDesc *arg2 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","close", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::FileDesc *","close", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::FileDesc * >(argp2);
  (arg1)->close(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_flush(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","flush", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  (arg1)->flush();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_resourceConsumption(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","resourceConsumption", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  result = (long)(arg1)->resourceConsumption();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_existsFile__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsFile", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (signed char)sword::FileMgr::existsFile((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_existsFile__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::FileMgr::existsFile((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FileMgr_existsFile(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FileMgr_existsFile__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FileMgr_existsFile__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FileMgr.existsFile", 
    "    signed char FileMgr.existsFile(char const *ipath, char const *ifileName)\n"
    "    signed char FileMgr.existsFile(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_existsDir__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsDir", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsDir", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (signed char)sword::FileMgr::existsDir((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_existsDir__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::existsDir", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (signed char)sword::FileMgr::existsDir((char const *)arg1);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FileMgr_existsDir(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FileMgr_existsDir__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FileMgr_existsDir__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FileMgr.existsDir", 
    "    signed char FileMgr.existsDir(char const *ipath, char const *idirName)\n"
    "    signed char FileMgr.existsDir(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_trunc(int argc, VALUE *argv, VALUE self) {
  sword::FileMgr *arg1 = (sword::FileMgr *) 0 ;
  sword::FileDesc *arg2 = (sword::FileDesc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  signed char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FileMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileMgr *","trunc", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FileMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::FileDesc *","trunc", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::FileDesc * >(argp2);
  result = (signed char)(arg1)->trunc(arg2);
  vresult = SWIG_From_signed_SS_char(static_cast< signed char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_isDirectory(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::isDirectory", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::FileMgr::isDirectory((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_createParent(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::createParent", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (int)sword::FileMgr::createParent((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_createPathAndFile(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::createPathAndFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (int)sword::FileMgr::createPathAndFile((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_openFileReadOnly(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::openFileReadOnly", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (int)sword::FileMgr::openFileReadOnly((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_copyFile(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::copyFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::copyFile", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)sword::FileMgr::copyFile((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_copyDir(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::copyDir", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::copyDir", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)sword::FileMgr::copyDir((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_removeDir(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::removeDir", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (int)sword::FileMgr::removeDir((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_removeFile(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FileMgr::removeFile", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (int)sword::FileMgr::removeFile((char const *)arg1);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FileMgr_getLine(int argc, VALUE *argv, VALUE self) {
  sword::FileDesc *arg1 = (sword::FileDesc *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__FileDesc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FileDesc *","sword::FileMgr::getLine", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::FileDesc * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","sword::FileMgr::getLine", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","sword::FileMgr::getLine", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (char)sword::FileMgr::getLine(arg1,*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassEncodingFilterMgr;

SWIGINTERN VALUE
_wrap_new_EncodingFilterMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::EncodingFilterMgr";
  sword::EncodingFilterMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","sword::EncodingFilterMgr", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  result = (sword::EncodingFilterMgr *)new sword::EncodingFilterMgr(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_EncodingFilterMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_EncodingFilterMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__EncodingFilterMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_EncodingFilterMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::EncodingFilterMgr";
  sword::EncodingFilterMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::EncodingFilterMgr *)new sword::EncodingFilterMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_EncodingFilterMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_EncodingFilterMgr__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_char(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_EncodingFilterMgr__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "EncodingFilterMgr.new", 
    "    EncodingFilterMgr.new(char encoding)\n"
    "    EncodingFilterMgr.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_EncodingFilterMgr(sword::EncodingFilterMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_EncodingFilterMgr_Encoding(int argc, VALUE *argv, VALUE self) {
  sword::EncodingFilterMgr *arg1 = (sword::EncodingFilterMgr *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__EncodingFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::EncodingFilterMgr *","Encoding", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::EncodingFilterMgr * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Encoding", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->Encoding(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_EncodingFilterMgr_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::EncodingFilterMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword_EncodingFilterMgr_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  result = (sword::EncodingFilterMgr *)sword_EncodingFilterMgr_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__EncodingFilterMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassMarkupFilterMgr;

SWIGINTERN VALUE
_wrap_new_MarkupFilterMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  char arg2 ;
  char val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::MarkupFilterMgr";
  sword::MarkupFilterMgr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","sword::MarkupFilterMgr", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","sword::MarkupFilterMgr", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (sword::MarkupFilterMgr *)new sword::MarkupFilterMgr(arg1,arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MarkupFilterMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::MarkupFilterMgr";
  sword::MarkupFilterMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","sword::MarkupFilterMgr", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  result = (sword::MarkupFilterMgr *)new sword::MarkupFilterMgr(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MarkupFilterMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MarkupFilterMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__MarkupFilterMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MarkupFilterMgr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::MarkupFilterMgr";
  sword::MarkupFilterMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::MarkupFilterMgr *)new sword::MarkupFilterMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MarkupFilterMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_MarkupFilterMgr__SWIG_2(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_char(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_MarkupFilterMgr__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_char(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_MarkupFilterMgr__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "MarkupFilterMgr.new", 
    "    MarkupFilterMgr.new(char markup, char encoding)\n"
    "    MarkupFilterMgr.new(char markup)\n"
    "    MarkupFilterMgr.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_MarkupFilterMgr(sword::MarkupFilterMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MarkupFilterMgr_Markup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::MarkupFilterMgr *arg1 = (sword::MarkupFilterMgr *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__MarkupFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::MarkupFilterMgr *","Markup", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::MarkupFilterMgr * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","Markup", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (char)(arg1)->Markup(arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MarkupFilterMgr_Markup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::MarkupFilterMgr *arg1 = (sword::MarkupFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__MarkupFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::MarkupFilterMgr *","Markup", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::MarkupFilterMgr * >(argp1);
  result = (char)(arg1)->Markup();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_MarkupFilterMgr_Markup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__MarkupFilterMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_MarkupFilterMgr_Markup__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__MarkupFilterMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_MarkupFilterMgr_Markup__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "MarkupFilterMgr.Markup", 
    "    char MarkupFilterMgr.Markup(char m)\n"
    "    char MarkupFilterMgr.Markup()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MarkupFilterMgr_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWFilterMgr *arg1 = (sword::SWFilterMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::MarkupFilterMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWFilterMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWFilterMgr *","sword_MarkupFilterMgr_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWFilterMgr * >(argp1);
  result = (sword::MarkupFilterMgr *)sword_MarkupFilterMgr_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__MarkupFilterMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ENDOFABBREVS_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::ENDOFABBREVS));
  return _val;
}


swig_class SwigClassSWLocale;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWLocale_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWLocale_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWLocale);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWLocale(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWLocale";
  sword::SWLocale *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::SWLocale", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::SWLocale *)new sword::SWLocale((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN void
free_sword_SWLocale(sword::SWLocale *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWLocale_getName(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  result = (char *)(arg1)->getName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_getDescription(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","getDescription", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  result = (char *)(arg1)->getDescription();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_getEncoding(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","getEncoding", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  result = (char *)(arg1)->getEncoding();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_translate(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","translate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","translate", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->translate((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_augment(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  sword::SWLocale *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","augment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWLocale,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWLocale &","augment", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWLocale &","augment", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWLocale * >(argp2);
  (arg1)->augment(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_DEFAULT_LOCALE_NAME_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_FromCharPtr(sword::SWLocale::DEFAULT_LOCALE_NAME);
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLocale_DEFAULT_LOCALE_NAME_set(VALUE self, VALUE _val) {
  {
    char *cptr = 0; size_t csize = 0; int alloc = SWIG_NEWOBJ;
    int res = SWIG_AsCharPtrAndSize(_val, &cptr, &csize, &alloc);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""sword::SWLocale::DEFAULT_LOCALE_NAME""' of type '""char const *""'");
    }
    if (alloc == SWIG_NEWOBJ) {
      sword::SWLocale::DEFAULT_LOCALE_NAME = cptr;
    } else {
      sword::SWLocale::DEFAULT_LOCALE_NAME = csize ? (char const *)reinterpret_cast< char* >(memcpy((new char[csize]), cptr, sizeof(char)*(csize))) : 0;
    }
  }
  return _val;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLocale_getBookAbbrevs(int argc, VALUE *argv, VALUE self) {
  sword::SWLocale *arg1 = (sword::SWLocale *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::abbrev *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLocale *","getBookAbbrevs", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLocale * >(argp1);
  result = (sword::abbrev *)sword_SWLocale_getBookAbbrevs(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__abbrev, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWCompress;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWCompress_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWCompress_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWCompress);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWCompress(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWCompress";
  sword::SWCompress *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWCompress *)new sword::SWCompress();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWCompress(sword::SWCompress *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWCompress_Encode(int argc, VALUE *argv, VALUE self) {
  sword::SWCompress *arg1 = (sword::SWCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCompress *","Encode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCompress * >(argp1);
  (arg1)->Encode();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWCompress_Decode(int argc, VALUE *argv, VALUE self) {
  sword::SWCompress *arg1 = (sword::SWCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCompress *","Decode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCompress * >(argp1);
  (arg1)->Decode();
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassLZSSCompress;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LZSSCompress_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LZSSCompress_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__LZSSCompress);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LZSSCompress(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::LZSSCompress";
  sword::LZSSCompress *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::LZSSCompress *)new sword::LZSSCompress();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_LZSSCompress(sword::LZSSCompress *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_LZSSCompress_Encode(int argc, VALUE *argv, VALUE self) {
  sword::LZSSCompress *arg1 = (sword::LZSSCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LZSSCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LZSSCompress *","Encode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LZSSCompress * >(argp1);
  (arg1)->Encode();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LZSSCompress_Decode(int argc, VALUE *argv, VALUE self) {
  sword::LZSSCompress *arg1 = (sword::LZSSCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LZSSCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LZSSCompress *","Decode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LZSSCompress * >(argp1);
  (arg1)->Decode();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LZSSCompress_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWCompress *arg1 = (sword::SWCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::LZSSCompress *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCompress *","sword_LZSSCompress_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWCompress * >(argp1);
  result = (sword::LZSSCompress *)sword_LZSSCompress_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__LZSSCompress, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassZipCompress;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ZipCompress_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ZipCompress_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__ZipCompress);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ZipCompress(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::ZipCompress";
  sword::ZipCompress *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::ZipCompress *)new sword::ZipCompress();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_ZipCompress(sword::ZipCompress *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ZipCompress_Encode(int argc, VALUE *argv, VALUE self) {
  sword::ZipCompress *arg1 = (sword::ZipCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ZipCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ZipCompress *","Encode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ZipCompress * >(argp1);
  (arg1)->Encode();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ZipCompress_Decode(int argc, VALUE *argv, VALUE self) {
  sword::ZipCompress *arg1 = (sword::ZipCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ZipCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ZipCompress *","Decode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ZipCompress * >(argp1);
  (arg1)->Decode();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ZipCompress_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWCompress *arg1 = (sword::SWCompress *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::ZipCompress *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCompress *","sword_ZipCompress_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWCompress * >(argp1);
  result = (sword::ZipCompress *)sword_ZipCompress_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ZipCompress, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWCom;

SWIGINTERN void
free_sword_SWCom(sword::SWCom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWCom_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::SWCom *arg1 = (sword::SWCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCom const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCom * >(argp1);
  result = (sword::SWKey *)((sword::SWCom const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWCom_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWCom *arg1 = (sword::SWCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCom const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCom * >(argp1);
  result = (long)((sword::SWCom const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWCom_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWCom *arg1 = (sword::SWCom *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCom *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCom * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWCom.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_SWCom___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWCom *arg1 = (sword::SWCom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWCom___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWCom *arg1 = (sword::SWCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWCom___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWCom___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWCom___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWCom.__lshift__", 
    "    sword::SWModule & SWCom.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & SWCom.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWCom_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWCom *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_SWCom_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWCom *)sword_SWCom_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWCom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRawCom;

SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  char *arg9 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawCom", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawCom", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  res9 = SWIG_AsCharPtrAndSize(argv[8], &buf9, NULL, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 9, argv[8] ));
  }
  arg9 = reinterpret_cast< char * >(buf9);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,(char const *)arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawCom", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawCom", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawCom", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawCom", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawCom", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawCom", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawCom", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawCom", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawCom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawCom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawCom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawCom__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawCom";
  sword::RawCom *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawCom *)new sword::RawCom((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawCom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawCom__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RawCom__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_RawCom__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_RawCom__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_RawCom__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_RawCom__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_RawCom__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    return _wrap_new_RawCom__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    int res = SWIG_AsCharPtrAndSize(argv[8], 0, NULL, 0);
                    _v = SWIG_CheckState(res);
                    if (_v) {
                      return _wrap_new_RawCom__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "RawCom.new", 
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, char const *versification)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp)\n"
    "    RawCom.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    RawCom.new(char const *ipath, char const *iname)\n"
    "    RawCom.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawCom(sword::RawCom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawCom_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawCom_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawCom_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawCom_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawCom.increment", 
    "    void RawCom.increment(int steps)\n"
    "    void RawCom.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawCom_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawCom_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawCom_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawCom.decrement", 
    "    void RawCom.decrement(int steps)\n"
    "    void RawCom.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawCom::createModule", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char)sword::RawCom::createModule((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawCom::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawCom::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawCom_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawCom_createModule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawCom_createModule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RawCom.createModule", 
    "    char RawCom.createModule(char const *path, char const *v11n)\n"
    "    char RawCom.createModule(char const *path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawCom_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawCom_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_RawCom_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "RawCom.setEntry", 
    "    void RawCom.setEntry(char const *inbuf, long len)\n"
    "    void RawCom.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_isLinked(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom const *","isLinked", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (bool)((sword::RawCom const *)arg1)->isLinked((sword::SWKey const *)arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::RawCom const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::RawCom.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_RawCom___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawCom *arg1 = (sword::RawCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawCom___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawCom___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawCom___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawCom.__lshift__", 
    "    sword::SWModule & RawCom.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & RawCom.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawCom_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::RawCom *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_RawCom_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::RawCom *)sword_RawCom_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__RawCom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassZCom;

SWIGINTERN VALUE
_wrap_new_zCom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  char *arg11 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  int res11 ;
  char *buf11 = 0 ;
  int alloc11 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 11) || (argc > 11)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 11)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zCom", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zCom", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zCom", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  res11 = SWIG_AsCharPtrAndSize(argv[10], &buf11, NULL, &alloc11);
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), Ruby_Format_TypeError( "", "char const *","sword::zCom", 11, argv[10] ));
  }
  arg11 = reinterpret_cast< char * >(buf11);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10,(char const *)arg11);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  if (alloc11 == SWIG_NEWOBJ) delete[] buf11;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  if (alloc11 == SWIG_NEWOBJ) delete[] buf11;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 10) || (argc > 10)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 10)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zCom", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zCom", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zCom", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zCom", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zCom", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zCom", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zCom", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zCom", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zCom", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zCom", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zCom__SWIG_9(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zCom", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::zCom *)new sword::zCom((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_zCom_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_zCom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__zCom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_zCom__SWIG_10(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zCom";
  sword::zCom *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::zCom *)new sword::zCom((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_zCom(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[11];
  int ii;
  
  argc = nargs;
  if (argc > 11) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_zCom__SWIG_10(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_zCom__SWIG_9(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_zCom__SWIG_8(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_zCom__SWIG_7(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_zCom__SWIG_6(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_new_zCom__SWIG_5(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_zCom__SWIG_4(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_zCom__SWIG_3(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_zCom__SWIG_2(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 10) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        return _wrap_new_zCom__SWIG_1(nargs, args, self);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 11) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        int res = SWIG_AsCharPtrAndSize(argv[10], 0, NULL, 0);
                        _v = SWIG_CheckState(res);
                        if (_v) {
                          return _wrap_new_zCom__SWIG_0(nargs, args, self);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 11, "zCom.new", 
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, char const *versification)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc, int blockType)\n"
    "    zCom.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    zCom.new(char const *ipath, char const *iname)\n"
    "    zCom.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_zCom(sword::zCom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_zCom_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zCom_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zCom_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zCom.increment", 
    "    void zCom.increment(int steps)\n"
    "    void zCom.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zCom_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zCom_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zCom.decrement", 
    "    void zCom.decrement(int steps)\n"
    "    void zCom.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zCom::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zCom::createModule", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char)sword::zCom::createModule((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zCom::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zCom::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char)sword::zCom::createModule((char const *)arg1,arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zCom_createModule__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_zCom_createModule__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zCom.createModule", 
    "    char zCom.createModule(char const *path, int blockBound, char const *v11n)\n"
    "    char zCom.createModule(char const *path, int blockBound)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zCom_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zCom_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zCom.setEntry", 
    "    void zCom.setEntry(char const *inbuf, long len)\n"
    "    void zCom.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_rawZFilter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","rawZFilter", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->rawZFilter(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_rawZFilter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->rawZFilter(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom_rawZFilter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zCom_rawZFilter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zCom_rawZFilter__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zCom.rawZFilter", 
    "    void zCom.rawZFilter(sword::SWBuf &buf, char direction)\n"
    "    void zCom.rawZFilter(sword::SWBuf &buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_flush(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","flush", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  (arg1)->flush();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_isLinked(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom const *","isLinked", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (bool)((sword::zCom const *)arg1)->isLinked((sword::SWKey const *)arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::zCom const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::zCom.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_zCom___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zCom *arg1 = (sword::zCom *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zCom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zCom *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zCom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zCom___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zCom___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zCom, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zCom___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zCom.__lshift__", 
    "    sword::SWModule & zCom.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & zCom.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zCom_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::zCom *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_zCom_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::zCom *)sword_zCom_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__zCom, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWGenBook;

SWIGINTERN void
free_sword_SWGenBook(sword::SWGenBook *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWGenBook_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::SWGenBook *arg1 = (sword::SWGenBook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWGenBook const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWGenBook * >(argp1);
  result = (sword::SWKey *)((sword::SWGenBook const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWGenBook.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_SWGenBook___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWGenBook *arg1 = (sword::SWGenBook *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWGenBook *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWGenBook * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWGenBook___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWGenBook *arg1 = (sword::SWGenBook *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWGenBook *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWGenBook * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWGenBook___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWGenBook___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWGenBook___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWGenBook.__lshift__", 
    "    sword::SWModule & SWGenBook.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & SWGenBook.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWGenBook_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWGenBook *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_SWGenBook_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWGenBook *)sword_SWGenBook_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWGenBook, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRawGenBook;

SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  char *arg9 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  res9 = SWIG_AsCharPtrAndSize(argv[8], &buf9, NULL, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 9, argv[8] ));
  }
  arg9 = reinterpret_cast< char * >(buf9);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,(char const *)arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawGenBook", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawGenBook", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawGenBook_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawGenBook_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawGenBook);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawGenBook__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawGenBook";
  sword::RawGenBook *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawGenBook *)new sword::RawGenBook((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawGenBook(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawGenBook__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RawGenBook__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_RawGenBook__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_RawGenBook__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_RawGenBook__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_RawGenBook__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_RawGenBook__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    return _wrap_new_RawGenBook__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    int res = SWIG_AsCharPtrAndSize(argv[8], 0, NULL, 0);
                    _v = SWIG_CheckState(res);
                    if (_v) {
                      return _wrap_new_RawGenBook__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "RawGenBook.new", 
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, char const *keyType)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp)\n"
    "    RawGenBook.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    RawGenBook.new(char const *ipath, char const *iname)\n"
    "    RawGenBook.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawGenBook(sword::RawGenBook *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawGenBook_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawGenBook::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawGenBook::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawGenBook_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawGenBook_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_RawGenBook_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "RawGenBook.setEntry", 
    "    void RawGenBook.setEntry(char const *inbuf, long len)\n"
    "    void RawGenBook.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  result = (sword::SWKey *)((sword::RawGenBook const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::RawGenBook const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::RawGenBook.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_RawGenBook___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawGenBook *arg1 = (sword::RawGenBook *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawGenBook *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawGenBook * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawGenBook___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawGenBook___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawGenBook, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawGenBook___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawGenBook.__lshift__", 
    "    sword::SWModule & RawGenBook.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & RawGenBook.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawGenBook_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::RawGenBook *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_RawGenBook_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::RawGenBook *)sword_RawGenBook_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__RawGenBook, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWLD;

SWIGINTERN void
free_sword_SWLD(sword::SWLD *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWLD_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  result = (sword::SWKey *)((sword::SWLD const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_KeyText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD *","KeyText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","KeyText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->KeyText((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_KeyText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD *","KeyText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  result = (char *)(arg1)->KeyText();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWLD_KeyText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SWLD_KeyText__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWLD_KeyText__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWLD.KeyText", 
    "    char const * SWLD.KeyText(char const *ikeytext)\n"
    "    char const * SWLD.KeyText()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_setPosition(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  SwigValueWrapper< sword::SW_POSITION > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD *","setPosition", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SW_POSITION,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SW_POSITION","setPosition", 2, argv[0] )); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SW_POSITION","setPosition", 2, argv[0]));
    } else {
      arg2 = *(reinterpret_cast< sword::SW_POSITION * >(argp2));
    }
  }
  (arg1)->setPosition(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_getEntryCount(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD const *","getEntryCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  result = (long)((sword::SWLD const *)arg1)->getEntryCount();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_getEntryForKey(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD const *","getEntryForKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getEntryForKey", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (long)((sword::SWLD const *)arg1)->getEntryForKey((char const *)arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_getKeyForEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD const *","getKeyForEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getKeyForEntry", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (char *)((sword::SWLD const *)arg1)->getKeyForEntry(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::SWLD const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWLD.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_SWLD___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWLD *arg1 = (sword::SWLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWLD___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWLD___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWLD___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWLD.__lshift__", 
    "    sword::SWModule & SWLD.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & SWLD.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLD_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWLD *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_SWLD_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWLD *)sword_SWLD_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWLD, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRawLD;

SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  bool arg9 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  ecode9 = SWIG_AsVal_bool(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "bool","sword::RawLD", 9, argv[8] ));
  } 
  arg9 = static_cast< bool >(val9);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawLD_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawLD_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawLD);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawLD__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD";
  sword::RawLD *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawLD *)new sword::RawLD((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawLD(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawLD__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RawLD__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_RawLD__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_RawLD__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_RawLD__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_RawLD__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_RawLD__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    return _wrap_new_RawLD__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    {
                      int res = SWIG_AsVal_bool(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_RawLD__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "RawLD.new", 
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, bool caseSensitive)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp)\n"
    "    RawLD.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    RawLD.new(char const *ipath, char const *iname)\n"
    "    RawLD.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawLD(sword::RawLD *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawLD_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawLD_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawLD_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD.increment", 
    "    void RawLD.increment(int steps)\n"
    "    void RawLD.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawLD_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawLD_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD.decrement", 
    "    void RawLD.decrement(int steps)\n"
    "    void RawLD.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawLD::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_RawLD_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "RawLD.setEntry", 
    "    void RawLD.setEntry(char const *inbuf, long len)\n"
    "    void RawLD.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_getEntryCount(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD const *","getEntryCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  result = (long)((sword::RawLD const *)arg1)->getEntryCount();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_getEntryForKey(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD const *","getEntryForKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getEntryForKey", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (long)((sword::RawLD const *)arg1)->getEntryForKey((char const *)arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_getKeyForEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD const *","getKeyForEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getKeyForEntry", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (char *)((sword::RawLD const *)arg1)->getKeyForEntry(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::RawLD.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_RawLD___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD *arg1 = (sword::RawLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD.__lshift__", 
    "    sword::SWModule & RawLD.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & RawLD.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::RawLD *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_RawLD_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::RawLD *)sword_RawLD_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__RawLD, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRawLD4;

SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  bool arg9 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD4", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD4", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD4", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  ecode9 = SWIG_AsVal_bool(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "bool","sword::RawLD4", 9, argv[8] ));
  } 
  arg9 = static_cast< bool >(val9);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD4", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD4", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD4", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD4", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD4", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawLD4", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD4", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawLD4", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawLD4", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawLD4", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawLD4_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawLD4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawLD4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawLD4__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawLD4";
  sword::RawLD4 *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawLD4 *)new sword::RawLD4((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawLD4(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawLD4__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RawLD4__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_RawLD4__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_RawLD4__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_RawLD4__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_RawLD4__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_RawLD4__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    return _wrap_new_RawLD4__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    {
                      int res = SWIG_AsVal_bool(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_RawLD4__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "RawLD4.new", 
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, bool caseSensitive)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp)\n"
    "    RawLD4.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    RawLD4.new(char const *ipath, char const *iname)\n"
    "    RawLD4.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawLD4(sword::RawLD4 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawLD4_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD4_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawLD4_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawLD4_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD4.increment", 
    "    void RawLD4.increment(int steps)\n"
    "    void RawLD4.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD4_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawLD4_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawLD4_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD4.decrement", 
    "    void RawLD4.decrement(int steps)\n"
    "    void RawLD4.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawLD4::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawLD4::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD4_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD4_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_RawLD4_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "RawLD4.setEntry", 
    "    void RawLD4.setEntry(char const *inbuf, long len)\n"
    "    void RawLD4.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_getEntryCount(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 const *","getEntryCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  result = (long)((sword::RawLD4 const *)arg1)->getEntryCount();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_getEntryForKey(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 const *","getEntryForKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getEntryForKey", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (long)((sword::RawLD4 const *)arg1)->getEntryForKey((char const *)arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_getKeyForEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 const *","getKeyForEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getKeyForEntry", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (char *)((sword::RawLD4 const *)arg1)->getKeyForEntry(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::RawLD4.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_RawLD4___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawLD4 *arg1 = (sword::RawLD4 *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawLD4 *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawLD4 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawLD4___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD4___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawLD4, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawLD4___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawLD4.__lshift__", 
    "    sword::SWModule & RawLD4.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & RawLD4.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawLD4_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::RawLD4 *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_RawLD4_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::RawLD4 *)sword_RawLD4_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__RawLD4, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassZLD;

SWIGINTERN VALUE
_wrap_new_zLD__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  bool arg11 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  bool val11 ;
  int ecode11 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 11) || (argc > 11)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 11)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zLD", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zLD", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zLD", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  ecode11 = SWIG_AsVal_bool(argv[10], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), Ruby_Format_TypeError( "", "bool","sword::zLD", 11, argv[10] ));
  } 
  arg11 = static_cast< bool >(val11);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10,arg11);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 10) || (argc > 10)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 10)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zLD", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zLD", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zLD", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zLD", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zLD", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zLD", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zLD", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zLD", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zLD", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  long arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_long(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "long","sword::zLD", 4, argv[3] ));
  } 
  arg4 = static_cast< long >(val4);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zLD", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zLD__SWIG_9(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zLD", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::zLD *)new sword::zLD((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_zLD_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_zLD_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__zLD);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_zLD__SWIG_10(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zLD";
  sword::zLD *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::zLD *)new sword::zLD((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_zLD(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[11];
  int ii;
  
  argc = nargs;
  if (argc > 11) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_zLD__SWIG_10(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_zLD__SWIG_9(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_zLD__SWIG_8(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_zLD__SWIG_7(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_zLD__SWIG_6(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_new_zLD__SWIG_5(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_zLD__SWIG_4(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_zLD__SWIG_3(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_zLD__SWIG_2(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 10) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        return _wrap_new_zLD__SWIG_1(nargs, args, self);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 11) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_long(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        {
                          int res = SWIG_AsVal_bool(argv[10], NULL);
                          _v = SWIG_CheckState(res);
                        }
                        if (_v) {
                          return _wrap_new_zLD__SWIG_0(nargs, args, self);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 11, "zLD.new", 
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, bool caseSensitive)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp, sword::SWDisplay *idisp)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount, sword::SWCompress *icomp)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc, long blockCount)\n"
    "    zLD.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    zLD.new(char const *ipath, char const *iname)\n"
    "    zLD.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_zLD(sword::zLD *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_zLD_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zLD_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zLD_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zLD_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zLD.increment", 
    "    void zLD.increment(int steps)\n"
    "    void zLD.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zLD_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zLD_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zLD_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zLD.decrement", 
    "    void zLD.decrement(int steps)\n"
    "    void zLD.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_createModule(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zLD::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::zLD::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zLD_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zLD_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zLD_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zLD.setEntry", 
    "    void zLD.setEntry(char const *inbuf, long len)\n"
    "    void zLD.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_rawZFilter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","rawZFilter", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->rawZFilter(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_rawZFilter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->rawZFilter(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zLD_rawZFilter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zLD_rawZFilter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zLD_rawZFilter__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zLD.rawZFilter", 
    "    void zLD.rawZFilter(sword::SWBuf &buf, char direction)\n"
    "    void zLD.rawZFilter(sword::SWBuf &buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_flush(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","flush", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  (arg1)->flush();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_getEntryCount(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD const *","getEntryCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  result = (long)((sword::zLD const *)arg1)->getEntryCount();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_getEntryForKey(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD const *","getEntryForKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getEntryForKey", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (long)((sword::zLD const *)arg1)->getEntryForKey((char const *)arg2);
  vresult = SWIG_From_long(static_cast< long >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_getKeyForEntry(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD const *","getKeyForEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","getKeyForEntry", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  result = (char *)((sword::zLD const *)arg1)->getKeyForEntry(arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::zLD.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_zLD___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zLD *arg1 = (sword::zLD *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zLD, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zLD *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zLD * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zLD___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zLD___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zLD, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zLD___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zLD.__lshift__", 
    "    sword::SWModule & zLD.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & zLD.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zLD_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::zLD *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_zLD_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::zLD *)sword_zLD_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__zLD, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWText;

SWIGINTERN void
free_sword_SWText(sword::SWText *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWText_CreateKey(int argc, VALUE *argv, VALUE self) {
  sword::SWText *arg1 = (sword::SWText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWText const *","CreateKey", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWText * >(argp1);
  result = (sword::SWKey *)((sword::SWText const *)arg1)->CreateKey();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWText_getIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWText *arg1 = (sword::SWText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWText const *","getIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWText * >(argp1);
  result = (long)((sword::SWText const *)arg1)->getIndex();
  vresult = SWIG_From_long(static_cast< long >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWText_setIndex(int argc, VALUE *argv, VALUE self) {
  sword::SWText *arg1 = (sword::SWText *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWText *","setIndex", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWText * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","setIndex", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  (arg1)->setIndex(arg2);
  return Qnil;
fail:
  return Qnil;
}



/*
  Document-method: Sword::SWText.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_SWText___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWText *arg1 = (sword::SWText *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWText___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWText *arg1 = (sword::SWText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWText___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWText___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWText___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "SWText.__lshift__", 
    "    sword::SWModule & SWText.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & SWText.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWText_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWText *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_SWText_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::SWText *)sword_SWText_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWText, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRawText;

SWIGINTERN VALUE
_wrap_new_RawText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  char *arg9 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawText", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawText", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawText", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  res9 = SWIG_AsCharPtrAndSize(argv[8], &buf9, NULL, &alloc9);
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), Ruby_Format_TypeError( "", "char const *","sword::RawText", 9, argv[8] ));
  }
  arg9 = reinterpret_cast< char * >(buf9);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8,(char const *)arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  if (alloc9 == SWIG_NEWOBJ) delete[] buf9;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  char *arg8 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  int res8 ;
  char *buf8 = 0 ;
  int alloc8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawText", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawText", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  res8 = SWIG_AsCharPtrAndSize(argv[7], &buf8, NULL, &alloc8);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "char const *","sword::RawText", 8, argv[7] ));
  }
  arg8 = reinterpret_cast< char * >(buf8);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc8 == SWIG_NEWOBJ) delete[] buf8;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawText", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawText", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::RawText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  char arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char val6 ;
  int ecode6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawText", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  ecode6 = SWIG_AsVal_char(argv[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "char","sword::RawText", 6, argv[5] ));
  } 
  arg6 = static_cast< char >(val6);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  char arg5 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  ecode5 = SWIG_AsVal_char(argv[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","sword::RawText", 5, argv[4] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWDisplay *arg4 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::RawText", 4, argv[3] )); 
  }
  arg4 = reinterpret_cast< sword::SWDisplay * >(argp4);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::RawText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_RawText__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::RawText *)new sword::RawText((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RawText_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RawText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__RawText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RawText__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::RawText";
  sword::RawText *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::RawText *)new sword::RawText((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_RawText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[9];
  int ii;
  
  argc = nargs;
  if (argc > 9) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RawText__SWIG_8(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_RawText__SWIG_7(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_RawText__SWIG_6(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_RawText__SWIG_5(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_RawText__SWIG_4(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_RawText__SWIG_3(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_RawText__SWIG_2(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    return _wrap_new_RawText__SWIG_1(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_char(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  int res = SWIG_AsCharPtrAndSize(argv[7], 0, NULL, 0);
                  _v = SWIG_CheckState(res);
                  if (_v) {
                    int res = SWIG_AsCharPtrAndSize(argv[8], 0, NULL, 0);
                    _v = SWIG_CheckState(res);
                    if (_v) {
                      return _wrap_new_RawText__SWIG_0(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 9, "RawText.new", 
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, char const *versification)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp, char encoding)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc, sword::SWDisplay *idisp)\n"
    "    RawText.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    RawText.new(char const *ipath, char const *iname)\n"
    "    RawText.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_RawText(sword::RawText *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RawText_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawText_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawText_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawText_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawText.increment", 
    "    void RawText.increment(int steps)\n"
    "    void RawText.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawText_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawText_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_RawText_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawText.decrement", 
    "    void RawText.decrement(int steps)\n"
    "    void RawText.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::RawText::createModule", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char)sword::RawText::createModule((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::RawText::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (char)sword::RawText::createModule((char const *)arg1);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawText_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RawText_createModule__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawText_createModule__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "RawText.createModule", 
    "    char RawText.createModule(char const *path, char const *v11n)\n"
    "    char RawText.createModule(char const *path)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawText_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawText_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_RawText_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "RawText.setEntry", 
    "    void RawText.setEntry(char const *inbuf, long len)\n"
    "    void RawText.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_isLinked(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText const *","isLinked", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (bool)((sword::RawText const *)arg1)->isLinked((sword::SWKey const *)arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::RawText const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::RawText.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_RawText___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::RawText *arg1 = (sword::RawText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__RawText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::RawText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::RawText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_RawText___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawText___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__RawText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RawText___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "RawText.__lshift__", 
    "    sword::SWModule & RawText.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & RawText.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_RawText_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::RawText *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_RawText_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::RawText *)sword_RawText_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__RawText, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassZText;

SWIGINTERN VALUE
_wrap_new_zText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  char *arg11 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  int res11 ;
  char *buf11 = 0 ;
  int alloc11 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 11) || (argc > 11)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 11)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zText", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zText", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zText", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  res11 = SWIG_AsCharPtrAndSize(argv[10], &buf11, NULL, &alloc11);
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), Ruby_Format_TypeError( "", "char const *","sword::zText", 11, argv[10] ));
  }
  arg11 = reinterpret_cast< char * >(buf11);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10,(char const *)arg11);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  if (alloc11 == SWIG_NEWOBJ) delete[] buf11;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  if (alloc11 == SWIG_NEWOBJ) delete[] buf11;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  char *arg10 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  int res10 ;
  char *buf10 = 0 ;
  int alloc10 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 10) || (argc > 10)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 10)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zText", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zText", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  res10 = SWIG_AsCharPtrAndSize(argv[9], &buf10, NULL, &alloc10);
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), Ruby_Format_TypeError( "", "char const *","sword::zText", 10, argv[9] ));
  }
  arg10 = reinterpret_cast< char * >(buf10);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc10 == SWIG_NEWOBJ) delete[] buf10;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  char arg9 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  char val9 ;
  int ecode9 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 9) || (argc > 9)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 9)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zText", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  ecode9 = SWIG_AsVal_char(argv[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "char","sword::zText", 9, argv[8] ));
  } 
  arg9 = static_cast< char >(val9);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  char arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  char val8 ;
  int ecode8 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  ecode8 = SWIG_AsVal_char(argv[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "char","sword::zText", 8, argv[7] ));
  } 
  arg8 = static_cast< char >(val8);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_4(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  char arg7 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  char val7 ;
  int ecode7 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 7) || (argc > 7)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 7)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  ecode7 = SWIG_AsVal_char(argv[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "char","sword::zText", 7, argv[6] ));
  } 
  arg7 = static_cast< char >(val7);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_5(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  sword::SWDisplay *arg6 = (sword::SWDisplay *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_sword__SWDisplay, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "sword::SWDisplay *","sword::zText", 6, argv[5] )); 
  }
  arg6 = reinterpret_cast< sword::SWDisplay * >(argp6);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_6(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  sword::SWCompress *arg5 = (sword::SWCompress *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_sword__SWCompress, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWCompress *","sword::zText", 5, argv[4] )); 
  }
  arg5 = reinterpret_cast< sword::SWCompress * >(argp5);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_7(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","sword::zText", 4, argv[3] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_8(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2,(char const *)arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_zText__SWIG_9(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::zText", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::zText *)new sword::zText((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_zText_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_zText_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__zText);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_zText__SWIG_10(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::zText";
  sword::zText *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::zText *)new sword::zText((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_zText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[11];
  int ii;
  
  argc = nargs;
  if (argc > 11) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_zText__SWIG_10(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_zText__SWIG_9(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_zText__SWIG_8(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_zText__SWIG_7(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_zText__SWIG_6(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_new_zText__SWIG_5(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_zText__SWIG_4(nargs, args, self);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_zText__SWIG_3(nargs, args, self);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_zText__SWIG_2(nargs, args, self);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 10) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        return _wrap_new_zText__SWIG_1(nargs, args, self);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 11) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWCompress, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_sword__SWDisplay, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                {
                  int res = SWIG_AsVal_char(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_char(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_char(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      int res = SWIG_AsCharPtrAndSize(argv[9], 0, NULL, 0);
                      _v = SWIG_CheckState(res);
                      if (_v) {
                        int res = SWIG_AsCharPtrAndSize(argv[10], 0, NULL, 0);
                        _v = SWIG_CheckState(res);
                        if (_v) {
                          return _wrap_new_zText__SWIG_0(nargs, args, self);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 11, "zText.new", 
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang, char const *versification)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup, char const *ilang)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir, char markup)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding, char dir)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp, char encoding)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp, sword::SWDisplay *idisp)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType, sword::SWCompress *icomp)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc, int blockType)\n"
    "    zText.new(char const *ipath, char const *iname, char const *idesc)\n"
    "    zText.new(char const *ipath, char const *iname)\n"
    "    zText.new(char const *ipath)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_zText(sword::zText *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_zText_getRawEntryBuf(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","getRawEntryBuf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  result = (sword::SWBuf *) &(arg1)->getRawEntryBuf();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_increment__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","increment", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->increment(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_increment__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","increment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  (arg1)->increment();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText_increment(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zText_increment__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zText_increment__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zText.increment", 
    "    void zText.increment(int steps)\n"
    "    void zText.increment()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_decrement__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","decrement", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->decrement(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_decrement__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","decrement", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  (arg1)->decrement();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText_decrement(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_zText_decrement__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zText_decrement__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zText.decrement", 
    "    void zText.decrement(int steps)\n"
    "    void zText.decrement()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_isWritable(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","isWritable", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  result = (bool)(arg1)->isWritable();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_createModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zText::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","sword::zText::createModule", 3, argv[2] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char)sword::zText::createModule((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_createModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::zText::createModule", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","sword::zText::createModule", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (char)sword::zText::createModule((char const *)arg1,arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText_createModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_zText_createModule__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_zText_createModule__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zText.createModule", 
    "    char zText.createModule(char const *path, int blockBound, char const *v11n)\n"
    "    char zText.createModule(char const *path, int blockBound)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_setEntry__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  char *arg2 = (char *) 0 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","setEntry", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  (arg1)->setEntry((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_setEntry__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","setEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setEntry", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setEntry((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText_setEntry(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zText_setEntry__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zText_setEntry__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zText.setEntry", 
    "    void zText.setEntry(char const *inbuf, long len)\n"
    "    void zText.setEntry(char const *inbuf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_linkEntry(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","linkEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","linkEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  (arg1)->linkEntry((sword::SWKey const *)arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_deleteEntry(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","deleteEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  (arg1)->deleteEntry();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_rawZFilter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","rawZFilter", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  (arg1)->rawZFilter(*arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_rawZFilter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","rawZFilter", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","rawZFilter", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","rawZFilter", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  (arg1)->rawZFilter(*arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText_rawZFilter(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zText_rawZFilter__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_zText_rawZFilter__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "zText.rawZFilter", 
    "    void zText.rawZFilter(sword::SWBuf &buf, char direction)\n"
    "    void zText.rawZFilter(sword::SWBuf &buf)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_flush(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","flush", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  (arg1)->flush();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_isLinked(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText const *","isLinked", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","isLinked", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (bool)((sword::zText const *)arg1)->isLinked((sword::SWKey const *)arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_hasEntry(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText const *","hasEntry", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","hasEntry", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (bool)((sword::zText const *)arg1)->hasEntry((sword::SWKey const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}



/*
  Document-method: Sword::zText.<<

  call-seq:
    <<(inbuf) -> SWModule
    <<(sourceKey) -> SWModule

Left shifting or appending operator.
*/
SWIGINTERN VALUE
_wrap_zText___lshift____SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator <<", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWModule *) &(arg1)->operator <<((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText___lshift____SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::zText *arg1 = (sword::zText *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__zText, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::zText *","operator <<", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::zText * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","operator <<", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::SWModule *) &(arg1)->operator <<((sword::SWKey const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_zText___lshift__(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWKey, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zText___lshift____SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__zText, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_zText___lshift____SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "zText.__lshift__", 
    "    sword::SWModule & zText.__lshift__(char const *inbuf)\n"
    "    sword::SWModule & zText.__lshift__(sword::SWKey const *sourceKey)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_zText_castTo(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::zText *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","sword_zText_castTo", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (sword::zText *)sword_zText_castTo(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__zText, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassLocaleMgr;

SWIGINTERN VALUE
_wrap_new_LocaleMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::LocaleMgr";
  sword::LocaleMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::LocaleMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::LocaleMgr *)new sword::LocaleMgr((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_LocaleMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_LocaleMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__LocaleMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_LocaleMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::LocaleMgr";
  sword::LocaleMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::LocaleMgr *)new sword::LocaleMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_LocaleMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_LocaleMgr__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocaleMgr__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "LocaleMgr.new", 
    "    LocaleMgr.new(char const *iConfigPath)\n"
    "    LocaleMgr.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_LocaleMgr(sword::LocaleMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_LocaleMgr_getLocale(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::SWLocale *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","getLocale", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getLocale", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::SWLocale *)(arg1)->getLocale((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWLocale, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_getAvailableLocales(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::StringList result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","getAvailableLocales", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  result = (arg1)->getAvailableLocales();
  vresult = swig::from(static_cast< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","translate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","translate", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","translate", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char *)(arg1)->translate((char const *)arg2,(char const *)arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","translate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","translate", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)(arg1)->translate((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_LocaleMgr_translate(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__LocaleMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_LocaleMgr_translate__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__LocaleMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_LocaleMgr_translate__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "LocaleMgr.translate", 
    "    char const * LocaleMgr.translate(char const *text, char const *localeName)\n"
    "    char const * LocaleMgr.translate(char const *text)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_getDefaultLocaleName(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","getDefaultLocaleName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  result = (char *)(arg1)->getDefaultLocaleName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_setDefaultLocaleName(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","setDefaultLocaleName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setDefaultLocaleName", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setDefaultLocaleName((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_getSystemLocaleMgr(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::LocaleMgr *)sword::LocaleMgr::getSystemLocaleMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_setSystemLocaleMgr(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","sword::LocaleMgr::setSystemLocaleMgr", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  sword::LocaleMgr::setSystemLocaleMgr(arg1);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_loadConfigDir(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","loadConfigDir", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","loadConfigDir", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->loadConfigDir((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_LocaleMgr_getAvailableLocalesVector(int argc, VALUE *argv, VALUE self) {
  sword::LocaleMgr *arg1 = (sword::LocaleMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__LocaleMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::LocaleMgr *","getAvailableLocalesVector", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::LocaleMgr * >(argp1);
  result = sword_LocaleMgr_getAvailableLocalesVector(arg1);
  vresult = swig::from(static_cast< std::vector<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassURL;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_URL_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_URL_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__URL);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_URL(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::URL";
  sword::URL *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::URL", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::URL *)new sword::URL((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_getProtocol(int argc, VALUE *argv, VALUE self) {
  sword::URL *arg1 = (sword::URL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__URL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::URL const *","getProtocol", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::URL * >(argp1);
  result = (char *)((sword::URL const *)arg1)->getProtocol();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_getHostName(int argc, VALUE *argv, VALUE self) {
  sword::URL *arg1 = (sword::URL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__URL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::URL const *","getHostName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::URL * >(argp1);
  result = (char *)((sword::URL const *)arg1)->getHostName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_getPath(int argc, VALUE *argv, VALUE self) {
  sword::URL *arg1 = (sword::URL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__URL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::URL const *","getPath", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::URL * >(argp1);
  result = (char *)((sword::URL const *)arg1)->getPath();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_getParameters(int argc, VALUE *argv, VALUE self) {
  sword::URL *arg1 = (sword::URL *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::URL::ParameterMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__URL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::URL const *","getParameters", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::URL * >(argp1);
  result = (sword::URL::ParameterMap *) &((sword::URL const *)arg1)->getParameters();
  vresult = swig::from(static_cast< std::map<sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >(*result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_getParameterValue(int argc, VALUE *argv, VALUE self) {
  sword::URL *arg1 = (sword::URL *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__URL, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::URL const *","getParameterValue", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::URL * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getParameterValue", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((sword::URL const *)arg1)->getParameterValue((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_encode(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  sword::SWBuf result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::URL::encode", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = sword::URL::encode((char const *)arg1);
  vresult = SWIG_NewPointerObj((new sword::SWBuf(static_cast< const sword::SWBuf& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_URL_decode(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  sword::SWBuf result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::URL::decode", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = sword::URL::decode((char const *)arg1);
  vresult = SWIG_NewPointerObj((new sword::SWBuf(static_cast< const sword::SWBuf& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return vresult;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN void
free_sword_URL(sword::URL *arg1) {
    delete arg1;
}

swig_class SwigClassXMLTag;

SWIGINTERN VALUE
_wrap_new_XMLTag__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::XMLTag";
  sword::XMLTag *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::XMLTag", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::XMLTag *)new sword::XMLTag((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_XMLTag__SWIG_1(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::XMLTag";
  sword::XMLTag *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::XMLTag *)new sword::XMLTag();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_XMLTag_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_XMLTag_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__XMLTag);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_XMLTag__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::XMLTag";
  sword::XMLTag *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__XMLTag,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const &","sword::XMLTag", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::XMLTag const &","sword::XMLTag", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = (sword::XMLTag *)new sword::XMLTag((sword::XMLTag const &)*arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_XMLTag(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[1];
  int ii;
  
  argc = nargs;
  if (argc > 1) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_XMLTag__SWIG_1(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTag__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTag__SWIG_0(nargs, args, self);
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 1, "XMLTag.new", 
    "    XMLTag.new(char const *tagString)\n"
    "    XMLTag.new()\n"
    "    XMLTag.new(sword::XMLTag const &tag)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_XMLTag(sword::XMLTag *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_XMLTag_setText(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag *","setText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setText", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setText((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getName(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getName", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = (char *)((sword::XMLTag const *)arg1)->getName();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_isEmpty(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","isEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = (bool)((sword::XMLTag const *)arg1)->isEmpty();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_setEmpty(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag *","setEmpty", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setEmpty", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setEmpty(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_isEndTag__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","isEndTag", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isEndTag", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)((sword::XMLTag const *)arg1)->isEndTag((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_isEndTag__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","isEndTag", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = (bool)((sword::XMLTag const *)arg1)->isEndTag();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLTag_isEndTag(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLTag_isEndTag__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLTag_isEndTag__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "XMLTag.isEndTag", 
    "    bool XMLTag.isEndTag(char const *eID)\n"
    "    bool XMLTag.isEndTag()\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttributeNames(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::StringList result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttributeNames", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = ((sword::XMLTag const *)arg1)->getAttributeNames();
  vresult = swig::from(static_cast< std::list<sword::SWBuf,std::allocator< sword::SWBuf > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttributePartCount__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttributePartCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getAttributePartCount", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_char(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","getAttributePartCount", 3, argv[1] ));
  } 
  arg3 = static_cast< char >(val3);
  result = (int)((sword::XMLTag const *)arg1)->getAttributePartCount((char const *)arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttributePartCount__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttributePartCount", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getAttributePartCount", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)((sword::XMLTag const *)arg1)->getAttributePartCount((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLTag_getAttributePartCount(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 4) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLTag_getAttributePartCount__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLTag_getAttributePartCount__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "XMLTag.getAttributePartCount", 
    "    int XMLTag.getAttributePartCount(char const *attribName, char partSplit)\n"
    "    int XMLTag.getAttributePartCount(char const *attribName)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttribute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getAttribute", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_char(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "char","getAttribute", 4, argv[2] ));
  } 
  arg4 = static_cast< char >(val4);
  result = (char *)((sword::XMLTag const *)arg1)->getAttribute((char const *)arg2,arg3,arg4);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttribute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","getAttribute", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (char *)((sword::XMLTag const *)arg1)->getAttribute((char const *)arg2,arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_getAttribute__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","getAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (char *)((sword::XMLTag const *)arg1)->getAttribute((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLTag_getAttribute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLTag_getAttribute__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLTag_getAttribute__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLTag_getAttribute__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "XMLTag.getAttribute", 
    "    char const * XMLTag.getAttribute(char const *attribName, int partNum, char partSplit)\n"
    "    char const * XMLTag.getAttribute(char const *attribName, int partNum)\n"
    "    char const * XMLTag.getAttribute(char const *attribName)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_setAttribute__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag *","setAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setAttribute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","setAttribute", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_char(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "char","setAttribute", 5, argv[3] ));
  } 
  arg5 = static_cast< char >(val5);
  result = (char *)(arg1)->setAttribute((char const *)arg2,(char const *)arg3,arg4,arg5);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_setAttribute__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag *","setAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setAttribute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","setAttribute", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (char *)(arg1)->setAttribute((char const *)arg2,(char const *)arg3,arg4);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_setAttribute__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag *","setAttribute", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setAttribute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","setAttribute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char *)(arg1)->setAttribute((char const *)arg2,(char const *)arg3);
  vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_XMLTag_setAttribute(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLTag_setAttribute__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_XMLTag_setAttribute__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__XMLTag, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_XMLTag_setAttribute__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "XMLTag.setAttribute", 
    "    char const * XMLTag.setAttribute(char const *attribName, char const *attribValue, int partNum, char partSplit)\n"
    "    char const * XMLTag.setAttribute(char const *attribName, char const *attribValue, int partNum)\n"
    "    char const * XMLTag.setAttribute(char const *attribName, char const *attribValue)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_XMLTag_toString(int argc, VALUE *argv, VALUE self) {
  sword::XMLTag *arg1 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::XMLTag const *","toString", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::XMLTag * >(argp1);
  result = (char *)((sword::XMLTag const *)arg1)->toString();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassBasicFilterUserData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_BasicFilterUserData_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_BasicFilterUserData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__BasicFilterUserData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_BasicFilterUserData(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::BasicFilterUserData";
  sword::BasicFilterUserData *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule const *","sword::BasicFilterUserData", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","sword::BasicFilterUserData", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  result = (sword::BasicFilterUserData *)new sword::BasicFilterUserData((sword::SWModule const *)arg1,(sword::SWKey const *)arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_BasicFilterUserData(sword::BasicFilterUserData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_BasicFilterUserData_module_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  sword::SWModule *arg2 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","module", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWModule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWModule const *","module", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWModule * >(argp2);
  if (arg1) (arg1)->module = (sword::SWModule const *)arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_module_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","module", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (sword::SWModule *) ((arg1)->module);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_key_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  sword::SWKey *arg2 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","key", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWKey, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWKey const *","key", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWKey * >(argp2);
  if (arg1) (arg1)->key = (sword::SWKey const *)arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_key_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","key", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (sword::SWKey *) ((arg1)->key);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWKey, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_lastTextNode_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","lastTextNode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","lastTextNode", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->lastTextNode = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_lastTextNode_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","lastTextNode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->lastTextNode);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_lastSuspendSegment_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","lastSuspendSegment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","lastSuspendSegment", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->lastSuspendSegment = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_lastSuspendSegment_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","lastSuspendSegment", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->lastSuspendSegment);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_suspendTextPassThru_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","suspendTextPassThru", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","suspendTextPassThru", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->suspendTextPassThru = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_suspendTextPassThru_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","suspendTextPassThru", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (bool) ((arg1)->suspendTextPassThru);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_supressAdjacentWhitespace_set(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","supressAdjacentWhitespace", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","supressAdjacentWhitespace", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->supressAdjacentWhitespace = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_BasicFilterUserData_supressAdjacentWhitespace_get(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","supressAdjacentWhitespace", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (bool) ((arg1)->supressAdjacentWhitespace);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassSWBasicFilter;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWBasicFilter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWBasicFilter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWBasicFilter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWBasicFilter(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWBasicFilter";
  sword::SWBasicFilter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWBasicFilter *)new sword::SWBasicFilter();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBasicFilter_processText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::SWBasicFilter *arg1 = (sword::SWBasicFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  sword::SWModule *arg4 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBasicFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBasicFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBasicFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWModule const *","processText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWModule * >(argp4);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3,(sword::SWModule const *)arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBasicFilter_processText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::SWBasicFilter *arg1 = (sword::SWBasicFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBasicFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBasicFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBasicFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWBasicFilter_processText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::SWBasicFilter *arg1 = (sword::SWBasicFilter *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWBasicFilter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWBasicFilter *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWBasicFilter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (char)(arg1)->processText(*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWBasicFilter_processText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBasicFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWBasicFilter_processText__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBasicFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SWBasicFilter_processText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__SWBasicFilter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWModule, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_SWBasicFilter_processText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "SWBasicFilter.processText", 
    "    char SWBasicFilter.processText(sword::SWBuf &text, sword::SWKey const *key, sword::SWModule const *module)\n"
    "    char SWBasicFilter.processText(sword::SWBuf &text, sword::SWKey const *key)\n"
    "    char SWBasicFilter.processText(sword::SWBuf &text)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_SWBasicFilter(sword::SWBasicFilter *arg1) {
    delete arg1;
}

swig_class SwigClassOSISHTMLHREF;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_OSISHTMLHREF_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_OSISHTMLHREF_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__OSISHTMLHREF);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_OSISHTMLHREF(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::OSISHTMLHREF";
  sword::OSISHTMLHREF *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::OSISHTMLHREF *)new sword::OSISHTMLHREF();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISHTMLHREF_setMorphFirst__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::OSISHTMLHREF *arg1 = (sword::OSISHTMLHREF *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__OSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::OSISHTMLHREF *","setMorphFirst", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::OSISHTMLHREF * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setMorphFirst", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setMorphFirst(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISHTMLHREF_setMorphFirst__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::OSISHTMLHREF *arg1 = (sword::OSISHTMLHREF *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__OSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::OSISHTMLHREF *","setMorphFirst", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::OSISHTMLHREF * >(argp1);
  (arg1)->setMorphFirst();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_OSISHTMLHREF_setMorphFirst(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 3) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__OSISHTMLHREF, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OSISHTMLHREF_setMorphFirst__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__OSISHTMLHREF, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OSISHTMLHREF_setMorphFirst__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "OSISHTMLHREF.setMorphFirst", 
    "    void OSISHTMLHREF.setMorphFirst(bool val)\n"
    "    void OSISHTMLHREF.setMorphFirst()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_OSISHTMLHREF(sword::OSISHTMLHREF *arg1) {
    delete arg1;
}

swig_class SwigClassPLAINHTML;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PLAINHTML_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PLAINHTML_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__PLAINHTML);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PLAINHTML(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::PLAINHTML";
  sword::PLAINHTML *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::PLAINHTML *)new sword::PLAINHTML();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PLAINHTML_processText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::PLAINHTML *arg1 = (sword::PLAINHTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  sword::SWModule *arg4 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__PLAINHTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::PLAINHTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::PLAINHTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWModule const *","processText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWModule * >(argp4);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3,(sword::SWModule const *)arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PLAINHTML_processText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::PLAINHTML *arg1 = (sword::PLAINHTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__PLAINHTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::PLAINHTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::PLAINHTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PLAINHTML_processText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::PLAINHTML *arg1 = (sword::PLAINHTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__PLAINHTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::PLAINHTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::PLAINHTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (char)(arg1)->processText(*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_PLAINHTML_processText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__PLAINHTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_PLAINHTML_processText__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__PLAINHTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_PLAINHTML_processText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__PLAINHTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWModule, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_PLAINHTML_processText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "PLAINHTML.processText", 
    "    char PLAINHTML.processText(sword::SWBuf &text, sword::SWKey const *key, sword::SWModule const *module)\n"
    "    char PLAINHTML.processText(sword::SWBuf &text, sword::SWKey const *key)\n"
    "    char PLAINHTML.processText(sword::SWBuf &text)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_PLAINHTML(sword::PLAINHTML *arg1) {
    delete arg1;
}

swig_class SwigClassThMLHTMLHREF;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ThMLHTMLHREF_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ThMLHTMLHREF_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__ThMLHTMLHREF);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ThMLHTMLHREF(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::ThMLHTMLHREF";
  sword::ThMLHTMLHREF *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::ThMLHTMLHREF *)new sword::ThMLHTMLHREF();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLHTMLHREF_getImagePrefix(int argc, VALUE *argv, VALUE self) {
  sword::ThMLHTMLHREF *arg1 = (sword::ThMLHTMLHREF *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ThMLHTMLHREF *","getImagePrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ThMLHTMLHREF * >(argp1);
  result = (char *)(arg1)->getImagePrefix();
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLHTMLHREF_setImagePrefix(int argc, VALUE *argv, VALUE self) {
  sword::ThMLHTMLHREF *arg1 = (sword::ThMLHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__ThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::ThMLHTMLHREF *","setImagePrefix", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::ThMLHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setImagePrefix", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setImagePrefix((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN void
free_sword_ThMLHTMLHREF(sword::ThMLHTMLHREF *arg1) {
    delete arg1;
}

swig_class SwigClassGBFHTMLHREF;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_GBFHTMLHREF_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_GBFHTMLHREF_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__GBFHTMLHREF);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_GBFHTMLHREF(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::GBFHTMLHREF";
  sword::GBFHTMLHREF *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::GBFHTMLHREF *)new sword::GBFHTMLHREF();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_GBFHTMLHREF(sword::GBFHTMLHREF *arg1) {
    delete arg1;
}

swig_class SwigClassUTF8HTML;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_UTF8HTML_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_UTF8HTML_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__UTF8HTML);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_UTF8HTML(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::UTF8HTML";
  sword::UTF8HTML *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::UTF8HTML *)new sword::UTF8HTML();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UTF8HTML_processText__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::UTF8HTML *arg1 = (sword::UTF8HTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  sword::SWModule *arg4 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__UTF8HTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::UTF8HTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::UTF8HTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWModule const *","processText", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWModule * >(argp4);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3,(sword::SWModule const *)arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UTF8HTML_processText__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::UTF8HTML *arg1 = (sword::UTF8HTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  sword::SWKey *arg3 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__UTF8HTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::UTF8HTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::UTF8HTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWKey const *","processText", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWKey * >(argp3);
  result = (char)(arg1)->processText(*arg2,(sword::SWKey const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_UTF8HTML_processText__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::UTF8HTML *arg1 = (sword::UTF8HTML *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__UTF8HTML, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::UTF8HTML *","processText", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::UTF8HTML * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","processText", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","processText", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  result = (char)(arg1)->processText(*arg2);
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_UTF8HTML_processText(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__UTF8HTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_UTF8HTML_processText__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__UTF8HTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_UTF8HTML_processText__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__UTF8HTML, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWKey, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWModule, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_UTF8HTML_processText__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "UTF8HTML.processText", 
    "    char UTF8HTML.processText(sword::SWBuf &text, sword::SWKey const *key, sword::SWModule const *module)\n"
    "    char UTF8HTML.processText(sword::SWBuf &text, sword::SWKey const *key)\n"
    "    char UTF8HTML.processText(sword::SWBuf &text)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_UTF8HTML(sword::UTF8HTML *arg1) {
    delete arg1;
}

swig_class SwigClassMarkupCallback;

SWIGINTERN void
free_MarkupCallback(MarkupCallback *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MarkupCallback_run(int argc, VALUE *argv, VALUE self) {
  MarkupCallback *arg1 = (MarkupCallback *) 0 ;
  sword::SWModule *arg2 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MarkupCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MarkupCallback *","run", 1, self )); 
  }
  arg1 = reinterpret_cast< MarkupCallback * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWModule *","run", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWModule * >(argp2);
  result = (bool)(arg1)->run(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MarkupCallback_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MarkupCallback_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MarkupCallback);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MarkupCallback(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::MarkupCallback";
  MarkupCallback *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (MarkupCallback *)new MarkupCallback();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


swig_class SwigClassMyMarkup;

SWIGINTERN VALUE
_wrap_new_MyMarkup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  MarkupCallback *arg1 = (MarkupCallback *) 0 ;
  char arg2 ;
  char arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::MyMarkup";
  MyMarkup *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_MarkupCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MarkupCallback *","MyMarkup", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< MarkupCallback * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","MyMarkup", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_char(argv[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "char","MyMarkup", 3, argv[2] ));
  } 
  arg3 = static_cast< char >(val3);
  result = (MyMarkup *)new MyMarkup(arg1,arg2,arg3);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_MyMarkup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  MarkupCallback *arg1 = (MarkupCallback *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::MyMarkup";
  MyMarkup *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_MarkupCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MarkupCallback *","MyMarkup", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< MarkupCallback * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","MyMarkup", 2, argv[1] ));
  } 
  arg2 = static_cast< char >(val2);
  result = (MyMarkup *)new MyMarkup(arg1,arg2);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_MyMarkup_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_MyMarkup_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_MyMarkup);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_MyMarkup__SWIG_2(int argc, VALUE *argv, VALUE self) {
  MarkupCallback *arg1 = (MarkupCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::MyMarkup";
  MyMarkup *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_MarkupCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MarkupCallback *","MyMarkup", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< MarkupCallback * >(argp1);
  result = (MyMarkup *)new MyMarkup(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_MyMarkup(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[3];
  int ii;
  
  argc = nargs;
  if (argc > 3) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MarkupCallback, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MyMarkup__SWIG_2(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MarkupCallback, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_MyMarkup__SWIG_1(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_MarkupCallback, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_MyMarkup__SWIG_0(nargs, args, self);
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 3, "MyMarkup.new", 
    "    MyMarkup.new(MarkupCallback *callback, char markup, char encoding)\n"
    "    MyMarkup.new(MarkupCallback *callback, char markup)\n"
    "    MyMarkup.new(MarkupCallback *callback)\n");
  
  return Qnil;
}


SWIGINTERN void
free_MyMarkup(MyMarkup *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_MyMarkup_delCallback(int argc, VALUE *argv, VALUE self) {
  MyMarkup *arg1 = (MyMarkup *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MyMarkup, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MyMarkup *","delCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< MyMarkup * >(argp1);
  (arg1)->delCallback();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MyMarkup_setCallback(int argc, VALUE *argv, VALUE self) {
  MyMarkup *arg1 = (MyMarkup *) 0 ;
  MarkupCallback *arg2 = (MarkupCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MyMarkup, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MyMarkup *","setCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< MyMarkup * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_MarkupCallback, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "MarkupCallback *","setCallback", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< MarkupCallback * >(argp2);
  (arg1)->setCallback(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_MyMarkup_call(int argc, VALUE *argv, VALUE self) {
  MyMarkup *arg1 = (MyMarkup *) 0 ;
  sword::SWModule *arg2 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_MyMarkup, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "MyMarkup *","call", 1, self )); 
  }
  arg1 = reinterpret_cast< MyMarkup * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWModule *","call", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWModule * >(argp2);
  result = (bool)(arg1)->call(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassReturnSuccess;

SWIGINTERN VALUE
_wrap_new_ReturnSuccess__SWIG_0(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::ReturnSuccess";
  ReturnSuccess *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (ReturnSuccess *)new ReturnSuccess();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_ReturnSuccess_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_ReturnSuccess_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_ReturnSuccess);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_ReturnSuccess__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::ReturnSuccess";
  ReturnSuccess *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","ReturnSuccess", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ReturnSuccess", 2, argv[1] ));
  } 
  arg2 = static_cast< int >(val2);
  result = (ReturnSuccess *)new ReturnSuccess(arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_ReturnSuccess(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_ReturnSuccess__SWIG_0(nargs, args, self);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ReturnSuccess__SWIG_1(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "ReturnSuccess.new", 
    "    ReturnSuccess.new()\n"
    "    ReturnSuccess.new(char *data, int success)\n");
  
  return Qnil;
}


SWIGINTERN void
free_ReturnSuccess(ReturnSuccess *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_ReturnSuccess_data_set(int argc, VALUE *argv, VALUE self) {
  ReturnSuccess *arg1 = (ReturnSuccess *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ReturnSuccess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ReturnSuccess *","data", 1, self )); 
  }
  arg1 = reinterpret_cast< ReturnSuccess * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","data", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  if (arg1->data) delete[] arg1->data;
  if (arg2) {
    size_t size = strlen(reinterpret_cast< const char * >(arg2)) + 1;
    arg1->data = (char *)reinterpret_cast< char* >(memcpy((new char[size]), reinterpret_cast< const char * >(arg2), sizeof(char)*(size)));
  } else {
    arg1->data = 0;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ReturnSuccess_data_get(int argc, VALUE *argv, VALUE self) {
  ReturnSuccess *arg1 = (ReturnSuccess *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ReturnSuccess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ReturnSuccess *","data", 1, self )); 
  }
  arg1 = reinterpret_cast< ReturnSuccess * >(argp1);
  result = (char *) ((arg1)->data);
  vresult = SWIG_FromCharPtr((const char *)result);
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ReturnSuccess_success_set(int argc, VALUE *argv, VALUE self) {
  ReturnSuccess *arg1 = (ReturnSuccess *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ReturnSuccess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ReturnSuccess *","success", 1, self )); 
  }
  arg1 = reinterpret_cast< ReturnSuccess * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","success", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->success = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ReturnSuccess_success_get(int argc, VALUE *argv, VALUE self) {
  ReturnSuccess *arg1 = (ReturnSuccess *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ReturnSuccess, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ReturnSuccess *","success", 1, self )); 
  }
  arg1 = reinterpret_cast< ReturnSuccess * >(argp1);
  result = (int) ((arg1)->success);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


swig_class SwigClassRenderCallback;

SWIGINTERN void
free_RenderCallback(RenderCallback *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_RenderCallback_run(int argc, VALUE *argv, VALUE self) {
  RenderCallback *arg1 = (RenderCallback *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  sword::BasicFilterUserData *arg4 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  ReturnSuccess result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RenderCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "RenderCallback *","run", 1, self )); 
  }
  arg1 = reinterpret_cast< RenderCallback * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","run", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","run", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","run", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","run", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::BasicFilterUserData * >(argp4);
  result = (arg1)->run(*arg2,(char const *)arg3,arg4);
  vresult = SWIG_NewPointerObj((new ReturnSuccess(static_cast< const ReturnSuccess& >(result))), SWIGTYPE_p_ReturnSuccess, SWIG_POINTER_OWN |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_RenderCallback_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_RenderCallback_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_RenderCallback);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_RenderCallback(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::RenderCallback";
  RenderCallback *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (RenderCallback *)new RenderCallback();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


swig_class SwigClassPyOSISHTMLHREF;

SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_removeTokenSubstitute(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","removeTokenSubstitute", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","removeTokenSubstitute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->removeTokenSubstitute((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_addTokenSubstitute(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","addTokenSubstitute", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","addTokenSubstitute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","addTokenSubstitute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->addTokenSubstitute((char const *)arg2,(char const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_addAllowedEscapeString(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","addAllowedEscapeString", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","addAllowedEscapeString", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->addAllowedEscapeString((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_removeAllowedEscapeString(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","removeAllowedEscapeString", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","removeAllowedEscapeString", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->removeAllowedEscapeString((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PyOSISHTMLHREF_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_PyOSISHTMLHREF);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PyOSISHTMLHREF(int argc, VALUE *argv, VALUE self) {
  RenderCallback *arg1 = (RenderCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::PyOSISHTMLHREF";
  PyOSISHTMLHREF *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_RenderCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "RenderCallback *","PyOSISHTMLHREF", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< RenderCallback * >(argp1);
  result = (PyOSISHTMLHREF *)new PyOSISHTMLHREF(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_getData(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  OSISData *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","PyOSISHTMLHREF::getData", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (OSISData *)PyOSISHTMLHREF::getData(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OSISData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_PyOSISHTMLHREF(PyOSISHTMLHREF *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_delCallback(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","delCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  (arg1)->delCallback();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_setCallback(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  RenderCallback *arg2 = (RenderCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","setCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_RenderCallback, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "RenderCallback *","setCallback", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< RenderCallback * >(argp2);
  (arg1)->setCallback(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyOSISHTMLHREF_call(int argc, VALUE *argv, VALUE self) {
  PyOSISHTMLHREF *arg1 = (PyOSISHTMLHREF *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  sword::BasicFilterUserData *arg4 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  ReturnSuccess result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyOSISHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyOSISHTMLHREF *","call", 1, self )); 
  }
  arg1 = reinterpret_cast< PyOSISHTMLHREF * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","call", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","call", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","call", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","call", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::BasicFilterUserData * >(argp4);
  result = (arg1)->call(*arg2,(char const *)arg3,arg4);
  vresult = SWIG_NewPointerObj((new ReturnSuccess(static_cast< const ReturnSuccess& >(result))), SWIGTYPE_p_ReturnSuccess, SWIG_POINTER_OWN |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


swig_class SwigClassPyThMLHTMLHREF;

SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_removeTokenSubstitute(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","removeTokenSubstitute", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","removeTokenSubstitute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->removeTokenSubstitute((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_addTokenSubstitute(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","addTokenSubstitute", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","addTokenSubstitute", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","addTokenSubstitute", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  (arg1)->addTokenSubstitute((char const *)arg2,(char const *)arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_addAllowedEscapeString(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","addAllowedEscapeString", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","addAllowedEscapeString", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->addAllowedEscapeString((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_removeAllowedEscapeString(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","removeAllowedEscapeString", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","removeAllowedEscapeString", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->removeAllowedEscapeString((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_PyThMLHTMLHREF_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_PyThMLHTMLHREF);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_PyThMLHTMLHREF(int argc, VALUE *argv, VALUE self) {
  RenderCallback *arg1 = (RenderCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::PyThMLHTMLHREF";
  PyThMLHTMLHREF *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_RenderCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "RenderCallback *","PyThMLHTMLHREF", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< RenderCallback * >(argp1);
  result = (PyThMLHTMLHREF *)new PyThMLHTMLHREF(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_getData(int argc, VALUE *argv, VALUE self) {
  sword::BasicFilterUserData *arg1 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ThMLData *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","PyThMLHTMLHREF::getData", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::BasicFilterUserData * >(argp1);
  result = (ThMLData *)PyThMLHTMLHREF::getData(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ThMLData, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_PyThMLHTMLHREF(PyThMLHTMLHREF *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_delCallback(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","delCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  (arg1)->delCallback();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_setCallback(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  RenderCallback *arg2 = (RenderCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","setCallback", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_RenderCallback, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "RenderCallback *","setCallback", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< RenderCallback * >(argp2);
  (arg1)->setCallback(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_PyThMLHTMLHREF_call(int argc, VALUE *argv, VALUE self) {
  PyThMLHTMLHREF *arg1 = (PyThMLHTMLHREF *) 0 ;
  sword::SWBuf *arg2 = 0 ;
  char *arg3 = (char *) 0 ;
  sword::BasicFilterUserData *arg4 = (sword::BasicFilterUserData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  ReturnSuccess result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PyThMLHTMLHREF, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "PyThMLHTMLHREF *","call", 1, self )); 
  }
  arg1 = reinterpret_cast< PyThMLHTMLHREF * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_sword__SWBuf,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf &","call", 2, argv[0] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf &","call", 2, argv[0])); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","call", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__BasicFilterUserData, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::BasicFilterUserData *","call", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::BasicFilterUserData * >(argp4);
  result = (arg1)->call(*arg2,(char const *)arg3,arg4);
  vresult = SWIG_NewPointerObj((new ReturnSuccess(static_cast< const ReturnSuccess& >(result))), SWIGTYPE_p_ReturnSuccess, SWIG_POINTER_OWN |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


swig_class SwigClassOSISData;

SWIGINTERN VALUE
_wrap_OSISData_osisQToTick_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","osisQToTick", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","osisQToTick", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->osisQToTick = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_osisQToTick_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","osisQToTick", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (bool) ((arg1)->osisQToTick);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_inBold_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","inBold", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","inBold", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->inBold = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_inBold_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","inBold", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (bool) ((arg1)->inBold);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_inXRefNote_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","inXRefNote", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","inXRefNote", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->inXRefNote = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_inXRefNote_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","inXRefNote", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (bool) ((arg1)->inXRefNote);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_BiblicalText_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","BiblicalText", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","BiblicalText", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->BiblicalText = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_BiblicalText_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","BiblicalText", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (bool) ((arg1)->BiblicalText);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_suspendLevel_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","suspendLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","suspendLevel", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->suspendLevel = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_suspendLevel_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","suspendLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (int) ((arg1)->suspendLevel);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_wordsOfChristStart_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","wordsOfChristStart", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","wordsOfChristStart", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->wordsOfChristStart = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_wordsOfChristStart_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","wordsOfChristStart", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->wordsOfChristStart);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_wordsOfChristEnd_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","wordsOfChristEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","wordsOfChristEnd", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->wordsOfChristEnd = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_wordsOfChristEnd_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","wordsOfChristEnd", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->wordsOfChristEnd);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_lastTransChange_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","lastTransChange", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","lastTransChange", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->lastTransChange = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_lastTransChange_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","lastTransChange", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->lastTransChange);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_w_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","w", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","w", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->w = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_w_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","w", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->w);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_fn_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","fn", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","fn", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->fn = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_fn_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","fn", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->fn);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_version_set(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","version", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->version = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_OSISData_version_get(int argc, VALUE *argv, VALUE self) {
  OSISData *arg1 = (OSISData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OSISData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OSISData *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< OSISData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->version);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_OSISData(OSISData *arg1) {
    delete arg1;
}

swig_class SwigClassThMLData;

SWIGINTERN VALUE
_wrap_ThMLData_inscriptRef_set(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","inscriptRef", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","inscriptRef", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->inscriptRef = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_inscriptRef_get(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","inscriptRef", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->inscriptRef);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_SecHead_set(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","SecHead", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SecHead", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->SecHead = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_SecHead_get(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","SecHead", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  result = (bool) ((arg1)->SecHead);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_BiblicalText_set(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","BiblicalText", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","BiblicalText", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->BiblicalText = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_BiblicalText_get(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","BiblicalText", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  result = (bool) ((arg1)->BiblicalText);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_version_set(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","version", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->version = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_version_get(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","version", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->version);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_startTag_set(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  sword::XMLTag *arg2 = (sword::XMLTag *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","startTag", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::XMLTag *","startTag", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::XMLTag * >(argp2);
  if (arg1) (arg1)->startTag = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_ThMLData_startTag_get(int argc, VALUE *argv, VALUE self) {
  ThMLData *arg1 = (ThMLData *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::XMLTag *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ThMLData, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "ThMLData *","startTag", 1, self )); 
  }
  arg1 = reinterpret_cast< ThMLData * >(argp1);
  result = (sword::XMLTag *)& ((arg1)->startTag);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__XMLTag, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN void
free_ThMLData(ThMLData *arg1) {
    delete arg1;
}

swig_class SwigClassSWSearcher;

SWIGINTERN VALUE
_wrap_SWSearcher_mod_set(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  sword::SWModule *arg2 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","mod", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWModule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWModule *","mod", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWModule * >(argp2);
  if (arg1) (arg1)->mod = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_mod_get(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWModule *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","mod", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  result = (sword::SWModule *) ((arg1)->mod);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWModule, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_percent_set(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","percent", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","percent", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->percent = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_percent_get(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","percent", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  result = (int) ((arg1)->percent);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_Callback(int argc, VALUE *argv, VALUE self) {
  char arg1 ;
  void *arg2 = (void *) 0 ;
  char val1 ;
  int ecode1 = 0 ;
  int res2 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  ecode1 = SWIG_AsVal_char(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "char","SWSearcher::Callback", 1, argv[0] ));
  } 
  arg1 = static_cast< char >(val1);
  res2 = SWIG_ConvertPtr(argv[1],SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "void *","SWSearcher::Callback", 2, argv[1] )); 
  }
  SWSearcher::Callback(arg1,arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_PercentFunction(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","PercentFunction", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","PercentFunction", 2, argv[0] ));
  } 
  arg2 = static_cast< int >(val2);
  (arg1)->PercentFunction(arg2);
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWSearcher_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWSearcher_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_SWSearcher);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWSearcher(int argc, VALUE *argv, VALUE self) {
  sword::SWModule *arg1 = (sword::SWModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::SWSearcher";
  SWSearcher *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWModule *","SWSearcher", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWModule * >(argp1);
  result = (SWSearcher *)new SWSearcher(arg1);
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_SWSearcher(SWSearcher *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWSearcher_GetPercent(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","GetPercent", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  result = (int)(arg1)->GetPercent();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_isSearchSupported__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  sword::SWKey *arg5 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","isSearchSupported", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWKey *","isSearchSupported", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWKey * >(argp5);
  result = (bool)(arg1)->isSearchSupported((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_isSearchSupported__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","isSearchSupported", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (bool)(arg1)->isSearchSupported((char const *)arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_isSearchSupported__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","isSearchSupported", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (bool)(arg1)->isSearchSupported((char const *)arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_isSearchSupported__SWIG_3(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","isSearchSupported", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isSearchSupported", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->isSearchSupported((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWSearcher_isSearchSupported(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWSearcher_isSearchSupported__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWSearcher_isSearchSupported__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWSearcher_isSearchSupported__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWKey, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_SWSearcher_isSearchSupported__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "SWSearcher.isSearchSupported", 
    "    bool SWSearcher.isSearchSupported(char const *istr, int searchType, int flags, sword::SWKey *scope)\n"
    "    bool SWSearcher.isSearchSupported(char const *istr, int searchType, int flags)\n"
    "    bool SWSearcher.isSearchSupported(char const *istr, int searchType)\n"
    "    bool SWSearcher.isSearchSupported(char const *istr)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_doSearch__SWIG_0(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  sword::SWKey *arg5 = (sword::SWKey *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","doSearch", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__SWKey, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::SWKey *","doSearch", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::SWKey * >(argp5);
  result = (sword::ListKey *) &(arg1)->doSearch((char const *)arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_doSearch__SWIG_1(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","doSearch", 4, argv[2] ));
  } 
  arg4 = static_cast< int >(val4);
  result = (sword::ListKey *) &(arg1)->doSearch((char const *)arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_doSearch__SWIG_2(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","doSearch", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  result = (sword::ListKey *) &(arg1)->doSearch((char const *)arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_doSearch__SWIG_3(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  sword::ListKey *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","doSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","doSearch", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::ListKey *) &(arg1)->doSearch((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__ListKey, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE _wrap_SWSearcher_doSearch(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SWSearcher_doSearch__SWIG_3(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SWSearcher_doSearch__SWIG_2(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SWSearcher_doSearch__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SWSearcher, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__SWKey, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_SWSearcher_doSearch__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "SWSearcher.doSearch", 
    "    sword::ListKey & SWSearcher.doSearch(char const *istr, int searchType, int flags, sword::SWKey *scope)\n"
    "    sword::ListKey & SWSearcher.doSearch(char const *istr, int searchType, int flags)\n"
    "    sword::ListKey & SWSearcher.doSearch(char const *istr, int searchType)\n"
    "    sword::ListKey & SWSearcher.doSearch(char const *istr)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWSearcher_TerminateSearch(int argc, VALUE *argv, VALUE self) {
  SWSearcher *arg1 = (SWSearcher *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_SWSearcher, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "SWSearcher *","TerminateSearch", 1, self )); 
  }
  arg1 = reinterpret_cast< SWSearcher * >(argp1);
  (arg1)->TerminateSearch();
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassSWLog;

SWIGINTERN VALUE
_wrap_SWLog_LOG_ERROR_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::SWLog::LOG_ERROR));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLog_LOG_WARN_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::SWLog::LOG_WARN));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLog_LOG_INFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::SWLog::LOG_INFO));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLog_LOG_TIMEDINFO_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::SWLog::LOG_TIMEDINFO));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLog_LOG_DEBUG_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::SWLog::LOG_DEBUG));
  return _val;
}


SWIGINTERN VALUE
_wrap_SWLog_getSystemLog(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWLog *)sword::SWLog::getSystemLog();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWLog, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_setSystemLog(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog *","sword::SWLog::setSystemLog", 1, argv[0] )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  sword::SWLog::setSystemLog(arg1);
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_SWLog_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_SWLog_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__SWLog);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_SWLog(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::SWLog";
  sword::SWLog *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::SWLog *)new sword::SWLog();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN void
free_sword_SWLog(sword::SWLog *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_SWLog_setLogLevel(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog *","setLogLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","setLogLevel", 2, argv[0] ));
  } 
  arg2 = static_cast< char >(val2);
  (arg1)->setLogLevel(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_getLogLevel(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","getLogLevel", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  result = (char)((sword::SWLog const *)arg1)->getLogLevel();
  vresult = SWIG_From_char(static_cast< char >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logWarning(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logWarning", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logWarning", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ((sword::SWLog const *)arg1)->logWarning((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logError(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logError", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logError", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ((sword::SWLog const *)arg1)->logError((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logInformation(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logInformation", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logInformation", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ((sword::SWLog const *)arg1)->logInformation((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logTimedInformation(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logTimedInformation", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logTimedInformation", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ((sword::SWLog const *)arg1)->logTimedInformation((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logDebug(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logDebug", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logDebug", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ((sword::SWLog const *)arg1)->logDebug((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_SWLog_logMessage(int argc, VALUE *argv, VALUE self) {
  sword::SWLog *arg1 = (sword::SWLog *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__SWLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWLog const *","logMessage", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::SWLog * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","logMessage", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","logMessage", 3, argv[1] ));
  } 
  arg3 = static_cast< int >(val3);
  ((sword::SWLog const *)arg1)->logMessage((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


swig_class SwigClassStatusReporter;

SWIGINTERN void
free_sword_StatusReporter(sword::StatusReporter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_StatusReporter_preStatus(int argc, VALUE *argv, VALUE self) {
  sword::StatusReporter *arg1 = (sword::StatusReporter *) 0 ;
  long arg2 ;
  long arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StatusReporter *","preStatus", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StatusReporter * >(argp1);
  ecode2 = SWIG_AsVal_long(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "long","preStatus", 2, argv[0] ));
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_long(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "long","preStatus", 3, argv[1] ));
  } 
  arg3 = static_cast< long >(val3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","preStatus", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  (arg1)->preStatus(arg2,arg3,(char const *)arg4);
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_StatusReporter_statusUpdate(int argc, VALUE *argv, VALUE self) {
  sword::StatusReporter *arg1 = (sword::StatusReporter *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::StatusReporter *","statusUpdate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::StatusReporter * >(argp1);
  ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","statusUpdate", 2, argv[0] ));
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","statusUpdate", 3, argv[1] ));
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->statusUpdate(arg2,arg3);
  return Qnil;
fail:
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_StatusReporter_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_StatusReporter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__StatusReporter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_StatusReporter(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::StatusReporter";
  sword::StatusReporter *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::StatusReporter *)new sword::StatusReporter();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


swig_class SwigClassFTPTransport;

SWIGINTERN VALUE
_wrap_new_FTPTransport__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  sword::StatusReporter *arg2 = (sword::StatusReporter *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::FTPTransport";
  sword::FTPTransport *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FTPTransport", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::StatusReporter *","sword::FTPTransport", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::StatusReporter * >(argp2);
  result = (sword::FTPTransport *)new sword::FTPTransport((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_FTPTransport_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_FTPTransport_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__FTPTransport);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_FTPTransport__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::FTPTransport";
  sword::FTPTransport *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::FTPTransport", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::FTPTransport *)new sword::FTPTransport((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_FTPTransport(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FTPTransport__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__StatusReporter, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_FTPTransport__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "FTPTransport.new", 
    "    FTPTransport.new(char const *host, sword::StatusReporter *statusReporter)\n"
    "    FTPTransport.new(char const *host)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_FTPTransport(sword::FTPTransport *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_FTPTransport_getURL__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  sword::SWBuf *arg4 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","getURL", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getURL", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","getURL", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWBuf *","getURL", 4, argv[2] )); 
  }
  arg4 = reinterpret_cast< sword::SWBuf * >(argp4);
  result = (char)(arg1)->getURL((char const *)arg2,(char const *)arg3,arg4);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_getURL__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  char result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","getURL", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getURL", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","getURL", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (char)(arg1)->getURL((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_char(static_cast< char >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE _wrap_FTPTransport_getURL(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[5];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 5) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FTPTransport, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_FTPTransport_getURL__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__FTPTransport, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_FTPTransport_getURL__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 5, "FTPTransport.getURL", 
    "    char FTPTransport.getURL(char const *destPath, char const *sourceURL, sword::SWBuf *destBuf)\n"
    "    char FTPTransport.getURL(char const *destPath, char const *sourceURL)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_copyDirectory(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","copyDirectory", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","copyDirectory", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","copyDirectory", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","copyDirectory", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(argv[3], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "char const *","copyDirectory", 5, argv[3] ));
  }
  arg5 = reinterpret_cast< char * >(buf5);
  result = (int)(arg1)->copyDirectory((char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_getDirList(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","getDirList", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getDirList", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (arg1)->getDirList((char const *)arg2);
  vresult = swig::from(static_cast< std::vector<sword::DirEntry,std::allocator< sword::DirEntry > > >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_setPassive(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","setPassive", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setPassive", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setPassive(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_setUser(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","setUser", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setUser", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setUser((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_setPasswd(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","setPasswd", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","setPasswd", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  (arg1)->setPasswd((char const *)arg2);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_FTPTransport_terminate(int argc, VALUE *argv, VALUE self) {
  sword::FTPTransport *arg1 = (sword::FTPTransport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__FTPTransport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::FTPTransport *","terminate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::FTPTransport * >(argp1);
  (arg1)->terminate();
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassInstallSource;

SWIGINTERN VALUE
_wrap_new_InstallSource__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallSource";
  sword::InstallSource *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallSource", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","sword::InstallSource", 2, argv[1] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (sword::InstallSource *)new sword::InstallSource((char const *)arg1,(char const *)arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InstallSource_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InstallSource_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__InstallSource);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InstallSource__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallSource";
  sword::InstallSource *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallSource", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::InstallSource *)new sword::InstallSource((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InstallSource(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[2];
  int ii;
  
  argc = nargs;
  if (argc > 2) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InstallSource__SWIG_1(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_InstallSource__SWIG_0(nargs, args, self);
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 2, "InstallSource.new", 
    "    InstallSource.new(char const *type, char const *confEnt)\n"
    "    InstallSource.new(char const *type)\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_InstallSource(sword::InstallSource *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_InstallSource_getConfEnt(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","getConfEnt", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (arg1)->getConfEnt();
  vresult = SWIG_NewPointerObj((new sword::SWBuf(static_cast< const sword::SWBuf& >(result))), SWIGTYPE_p_sword__SWBuf, SWIG_POINTER_OWN |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_caption_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","caption", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","caption", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->caption = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_caption_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","caption", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->caption);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_source_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","source", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","source", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->source = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_source_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","source", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->source);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_directory_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","directory", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","directory", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->directory = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_directory_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","directory", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->directory);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_u_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","u", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","u", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->u = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_u_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","u", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->u);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_p_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","p", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","p", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->p = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_p_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","p", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->p);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_uid_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","uid", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","uid", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->uid = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_uid_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","uid", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->uid);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_type_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","type", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->type = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_type_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","type", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->type);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_localShadow_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  sword::SWBuf *arg2 = (sword::SWBuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","localShadow", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWBuf *","localShadow", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWBuf * >(argp2);
  if (arg1) (arg1)->localShadow = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_localShadow_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWBuf *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","localShadow", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWBuf *)& ((arg1)->localShadow);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWBuf, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_getMgr(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWMgr *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","getMgr", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  result = (sword::SWMgr *)(arg1)->getMgr();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallSource_flush(int argc, VALUE *argv, VALUE self) {
  sword::InstallSource *arg1 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallSource *","flush", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallSource * >(argp1);
  (arg1)->flush();
  return Qnil;
fail:
  return Qnil;
}


swig_class SwigClassInstallMgr;

SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_OLDER_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_OLDER));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_SAMEVERSION_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_SAMEVERSION));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_UPDATED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_UPDATED));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_NEW_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_NEW));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_CIPHERED_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_CIPHERED));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_MODSTAT_CIPHERKEYPRESENT_get(VALUE self) {
  VALUE _val;
  
  _val = SWIG_From_int(static_cast< int >(sword::InstallMgr::MODSTAT_CIPHERKEYPRESENT));
  return _val;
}


SWIGINTERN VALUE
_wrap_InstallMgr_installConf_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::SWConfig *arg2 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","installConf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWConfig, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWConfig *","installConf", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWConfig * >(argp2);
  if (arg1) (arg1)->installConf = arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_installConf_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::SWConfig *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","installConf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  result = (sword::SWConfig *) ((arg1)->installConf);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_sources_set(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::InstallSourceMap *arg2 = (sword::InstallSourceMap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","sources", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::InstallSourceMap *","sources", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::InstallSourceMap * >(argp2);
  if (arg1) (arg1)->sources = *arg2;
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_sources_get(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sword::InstallSourceMap *result = 0 ;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","sources", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  result = (sword::InstallSourceMap *)& ((arg1)->sources);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0 |  0 );
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InstallMgr__SWIG_0(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  sword::StatusReporter *arg2 = (sword::StatusReporter *) 0 ;
  sword::SWBuf arg3 ;
  sword::SWBuf arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallMgr";
  sword::InstallMgr *result = 0 ;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::StatusReporter *","sword::InstallMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::StatusReporter * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf","sword::InstallMgr", 3, argv[2] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf","sword::InstallMgr", 3, argv[2]));
    } else {
      arg3 = *(reinterpret_cast< sword::SWBuf * >(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_sword__SWBuf,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "sword::SWBuf","sword::InstallMgr", 4, argv[3] )); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf","sword::InstallMgr", 4, argv[3]));
    } else {
      arg4 = *(reinterpret_cast< sword::SWBuf * >(argp4));
    }
  }
  result = (sword::InstallMgr *)new sword::InstallMgr((char const *)arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InstallMgr__SWIG_1(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  sword::StatusReporter *arg2 = (sword::StatusReporter *) 0 ;
  sword::SWBuf arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallMgr";
  sword::InstallMgr *result = 0 ;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::StatusReporter *","sword::InstallMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::StatusReporter * >(argp2);
  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_sword__SWBuf,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWBuf","sword::InstallMgr", 3, argv[2] )); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWBuf","sword::InstallMgr", 3, argv[2]));
    } else {
      arg3 = *(reinterpret_cast< sword::SWBuf * >(argp3));
    }
  }
  result = (sword::InstallMgr *)new sword::InstallMgr((char const *)arg1,arg2,arg3);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InstallMgr__SWIG_2(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  sword::StatusReporter *arg2 = (sword::StatusReporter *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallMgr";
  sword::InstallMgr *result = 0 ;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_sword__StatusReporter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::StatusReporter *","sword::InstallMgr", 2, argv[1] )); 
  }
  arg2 = reinterpret_cast< sword::StatusReporter * >(argp2);
  result = (sword::InstallMgr *)new sword::InstallMgr((char const *)arg1,arg2);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_new_InstallMgr__SWIG_3(int argc, VALUE *argv, VALUE self) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  const char *classname SWIGUNUSED = "Sword::InstallMgr";
  sword::InstallMgr *result = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","sword::InstallMgr", 1, argv[0] ));
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (sword::InstallMgr *)new sword::InstallMgr((char const *)arg1);
  DATA_PTR(self) = result;
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return self;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return Qnil;
}


#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE
_wrap_InstallMgr_allocate(VALUE self) {
#else
  SWIGINTERN VALUE
  _wrap_InstallMgr_allocate(int argc, VALUE *argv, VALUE self) {
#endif
    
    
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_sword__InstallMgr);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
    return vresult;
  }
  

SWIGINTERN VALUE
_wrap_new_InstallMgr__SWIG_4(int argc, VALUE *argv, VALUE self) {
  const char *classname SWIGUNUSED = "Sword::InstallMgr";
  sword::InstallMgr *result = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  result = (sword::InstallMgr *)new sword::InstallMgr();
  DATA_PTR(self) = result;
  return self;
fail:
  return Qnil;
}


SWIGINTERN VALUE _wrap_new_InstallMgr(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[4];
  int ii;
  
  argc = nargs;
  if (argc > 4) SWIG_fail;
  for (ii = 0; (ii < argc); ++ii) {
    argv[ii] = args[ii];
  }
  if (argc == 0) {
    return _wrap_new_InstallMgr__SWIG_4(nargs, args, self);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InstallMgr__SWIG_3(nargs, args, self);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__StatusReporter, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_InstallMgr__SWIG_2(nargs, args, self);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__StatusReporter, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_InstallMgr__SWIG_1(nargs, args, self);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__StatusReporter, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_sword__SWBuf, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_InstallMgr__SWIG_0(nargs, args, self);
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 4, "InstallMgr.new", 
    "    InstallMgr.new(char const *privatePath, sword::StatusReporter *statusReporter, sword::SWBuf u, sword::SWBuf p)\n"
    "    InstallMgr.new(char const *privatePath, sword::StatusReporter *statusReporter, sword::SWBuf u)\n"
    "    InstallMgr.new(char const *privatePath, sword::StatusReporter *statusReporter)\n"
    "    InstallMgr.new(char const *privatePath)\n"
    "    InstallMgr.new()\n");
  
  return Qnil;
}


SWIGINTERN void
free_sword_InstallMgr(sword::InstallMgr *arg1) {
    delete arg1;
}

SWIGINTERN VALUE
_wrap_InstallMgr_readInstallConf(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","readInstallConf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  (arg1)->readInstallConf();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_saveInstallConf(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","saveInstallConf", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  (arg1)->saveInstallConf();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_clearSources(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","clearSources", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  (arg1)->clearSources();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_removeModule(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::SWMgr *arg2 = (sword::SWMgr *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","removeModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWMgr *","removeModule", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWMgr * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","removeModule", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  result = (int)(arg1)->removeModule(arg2,(char const *)arg3);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_ftpCopy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::InstallSource *arg2 = (sword::InstallSource *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool arg5 ;
  char *arg6 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","ftpCopy", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::InstallSource *","ftpCopy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::InstallSource * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ftpCopy", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","ftpCopy", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_bool(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","ftpCopy", 5, argv[3] ));
  } 
  arg5 = static_cast< bool >(val5);
  res6 = SWIG_AsCharPtrAndSize(argv[4], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "char const *","ftpCopy", 6, argv[4] ));
  }
  arg6 = reinterpret_cast< char * >(buf6);
  result = (int)(arg1)->ftpCopy(arg2,(char const *)arg3,(char const *)arg4,arg5,(char const *)arg6);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_ftpCopy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::InstallSource *arg2 = (sword::InstallSource *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","ftpCopy", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::InstallSource *","ftpCopy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::InstallSource * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ftpCopy", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","ftpCopy", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_bool(argv[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "bool","ftpCopy", 5, argv[3] ));
  } 
  arg5 = static_cast< bool >(val5);
  result = (int)(arg1)->ftpCopy(arg2,(char const *)arg3,(char const *)arg4,arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_ftpCopy__SWIG_2(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::InstallSource *arg2 = (sword::InstallSource *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","ftpCopy", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::InstallSource *","ftpCopy", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::InstallSource * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","ftpCopy", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","ftpCopy", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  result = (int)(arg1)->ftpCopy(arg2,(char const *)arg3,(char const *)arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_InstallMgr_ftpCopy(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[7];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 7) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__InstallMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__InstallSource, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_InstallMgr_ftpCopy__SWIG_2(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__InstallMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__InstallSource, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_InstallMgr_ftpCopy__SWIG_1(nargs, args, self);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__InstallMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__InstallSource, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              int res = SWIG_AsCharPtrAndSize(argv[5], 0, NULL, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_InstallMgr_ftpCopy__SWIG_0(nargs, args, self);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 7, "InstallMgr.ftpCopy", 
    "    int InstallMgr.ftpCopy(sword::InstallSource *is, char const *src, char const *dest, bool dirTransfer, char const *suffix)\n"
    "    int InstallMgr.ftpCopy(sword::InstallSource *is, char const *src, char const *dest, bool dirTransfer)\n"
    "    int InstallMgr.ftpCopy(sword::InstallSource *is, char const *src, char const *dest)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_installModule__SWIG_0(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::SWMgr *arg2 = (sword::SWMgr *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  sword::InstallSource *arg5 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","installModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWMgr *","installModule", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWMgr * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","installModule", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","installModule", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "sword::InstallSource *","installModule", 5, argv[3] )); 
  }
  arg5 = reinterpret_cast< sword::InstallSource * >(argp5);
  result = (int)(arg1)->installModule(arg2,(char const *)arg3,(char const *)arg4,arg5);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_installModule__SWIG_1(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::SWMgr *arg2 = (sword::SWMgr *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","installModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__SWMgr, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWMgr *","installModule", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::SWMgr * >(argp2);
  res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","installModule", 3, argv[1] ));
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","installModule", 4, argv[2] ));
  }
  arg4 = reinterpret_cast< char * >(buf4);
  result = (int)(arg1)->installModule(arg2,(char const *)arg3,(char const *)arg4);
  vresult = SWIG_From_int(static_cast< int >(result));
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return vresult;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return Qnil;
}


SWIGINTERN VALUE _wrap_InstallMgr_installModule(int nargs, VALUE *args, VALUE self) {
  int argc;
  VALUE argv[6];
  int ii;
  
  argc = nargs + 1;
  argv[0] = self;
  if (argc > 6) SWIG_fail;
  for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1];
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__InstallMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_InstallMgr_installModule__SWIG_1(nargs, args, self);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_sword__InstallMgr, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_sword__SWMgr, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *vptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_sword__InstallSource, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_InstallMgr_installModule__SWIG_0(nargs, args, self);
            }
          }
        }
      }
    }
  }
  
fail:
  Ruby_Format_OverloadedError( argc, 6, "InstallMgr.installModule", 
    "    int InstallMgr.installModule(sword::SWMgr *destMgr, char const *fromLocation, char const *modName, sword::InstallSource *is)\n"
    "    int InstallMgr.installModule(sword::SWMgr *destMgr, char const *fromLocation, char const *modName)\n");
  
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_refreshRemoteSource(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  sword::InstallSource *arg2 = (sword::InstallSource *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","refreshRemoteSource", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_sword__InstallSource, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::InstallSource *","refreshRemoteSource", 2, argv[0] )); 
  }
  arg2 = reinterpret_cast< sword::InstallSource * >(argp2);
  result = (int)(arg1)->refreshRemoteSource(arg2);
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_refreshRemoteSourceConfiguration(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","refreshRemoteSourceConfiguration", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  result = (int)(arg1)->refreshRemoteSourceConfiguration();
  vresult = SWIG_From_int(static_cast< int >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_isUserDisclaimerConfirmed(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr const *","isUserDisclaimerConfirmed", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  result = (bool)((sword::InstallMgr const *)arg1)->isUserDisclaimerConfirmed();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_setUserDisclaimerConfirmed(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","setUserDisclaimerConfirmed", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setUserDisclaimerConfirmed", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setUserDisclaimerConfirmed(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_getCipherCode(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  sword::SWConfig *arg3 = (sword::SWConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","getCipherCode", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","getCipherCode", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_sword__SWConfig, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "sword::SWConfig *","getCipherCode", 3, argv[1] )); 
  }
  arg3 = reinterpret_cast< sword::SWConfig * >(argp3);
  result = (bool)(arg1)->getCipherCode((char const *)arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_setFTPPassive(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","setFTPPassive", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","setFTPPassive", 2, argv[0] ));
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setFTPPassive(arg2);
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_isFTPPassive(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","isFTPPassive", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  result = (bool)(arg1)->isFTPPassive();
  vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_terminate(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","terminate", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  (arg1)->terminate();
  return Qnil;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_getModuleStatus(int argc, VALUE *argv, VALUE self) {
  sword::SWMgr *arg1 = 0 ;
  sword::SWMgr *arg2 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  std::map< sword::SWModule *,int,std::less< sword::SWModule * >,std::allocator< std::pair< sword::SWModule *const,int > > > result;
  VALUE vresult = Qnil;
  
  if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_sword__SWMgr,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::SWMgr const &","sword::InstallMgr::getModuleStatus", 1, argv[0] )); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWMgr const &","sword::InstallMgr::getModuleStatus", 1, argv[0])); 
  }
  arg1 = reinterpret_cast< sword::SWMgr * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_sword__SWMgr,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "sword::SWMgr const &","sword::InstallMgr::getModuleStatus", 2, argv[1] )); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "sword::SWMgr const &","sword::InstallMgr::getModuleStatus", 2, argv[1])); 
  }
  arg2 = reinterpret_cast< sword::SWMgr * >(argp2);
  result = sword::InstallMgr::getModuleStatus((sword::SWMgr const &)*arg1,(sword::SWMgr const &)*arg2);
  vresult = swig::from(static_cast< std::map<sword::SWModule *,int,std::less< sword::SWModule * >,std::allocator< std::pair< sword::SWModule *const,int > > > >(result));
  return vresult;
fail:
  return Qnil;
}


SWIGINTERN VALUE
_wrap_InstallMgr_isDefaultModule(int argc, VALUE *argv, VALUE self) {
  sword::InstallMgr *arg1 = (sword::InstallMgr *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  VALUE vresult = Qnil;
  
  if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_sword__InstallMgr, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "sword::InstallMgr *","isDefaultModule", 1, self )); 
  }
  arg1 = reinterpret_cast< sword::InstallMgr * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","isDefaultModule", 2, argv[0] ));
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (bool)(arg1)->isDefaultModule((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return vresult;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil;
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_sword__VerseTreeKeyTo_p_sword__VerseKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::VerseKey *)  ((sword::VerseTreeKey *) x));
}
static void *_p_sword__RawLDTo_p_sword__RawStr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::RawStr *)  ((sword::RawLD *) x));
}
static void *_p_sword__RawLDTo_p_sword__SWLD(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWLD *)  ((sword::RawLD *) x));
}
static void *_p_sword__RawLD4To_p_sword__SWLD(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWLD *)  ((sword::RawLD4 *) x));
}
static void *_p_sword__zLDTo_p_sword__SWLD(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWLD *)  ((sword::zLD *) x));
}
static void *_p_sword__OSISHTMLHREFTo_p_sword__SWBasicFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWBasicFilter *)  ((sword::OSISHTMLHREF *) x));
}
static void *_p_sword__ThMLHTMLHREFTo_p_sword__SWBasicFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWBasicFilter *)  ((sword::ThMLHTMLHREF *) x));
}
static void *_p_sword__GBFHTMLHREFTo_p_sword__SWBasicFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWBasicFilter *)  ((sword::GBFHTMLHREF *) x));
}
static void *_p_PyOSISHTMLHREFTo_p_sword__SWBasicFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWBasicFilter *) (sword::OSISHTMLHREF *) ((PyOSISHTMLHREF *) x));
}
static void *_p_PyThMLHTMLHREFTo_p_sword__SWBasicFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWBasicFilter *) (sword::ThMLHTMLHREF *) ((PyThMLHTMLHREF *) x));
}
static void *_p_sword__SWOptionFilterTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *)  ((sword::SWOptionFilter *) x));
}
static void *_p_sword__OSISHTMLHREFTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *) (sword::SWBasicFilter *) ((sword::OSISHTMLHREF *) x));
}
static void *_p_sword__ThMLHTMLHREFTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *) (sword::SWBasicFilter *) ((sword::ThMLHTMLHREF *) x));
}
static void *_p_sword__GBFHTMLHREFTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *) (sword::SWBasicFilter *) ((sword::GBFHTMLHREF *) x));
}
static void *_p_PyOSISHTMLHREFTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *) (sword::SWBasicFilter *)(sword::OSISHTMLHREF *) ((PyOSISHTMLHREF *) x));
}
static void *_p_PyThMLHTMLHREFTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *) (sword::SWBasicFilter *)(sword::ThMLHTMLHREF *) ((PyThMLHTMLHREF *) x));
}
static void *_p_sword__SWBasicFilterTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *)  ((sword::SWBasicFilter *) x));
}
static void *_p_sword__PLAINHTMLTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *)  ((sword::PLAINHTML *) x));
}
static void *_p_sword__UTF8HTMLTo_p_sword__SWFilter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilter *)  ((sword::UTF8HTML *) x));
}
static void *_p_PyThMLHTMLHREFTo_p_sword__ThMLHTMLHREF(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::ThMLHTMLHREF *)  ((PyThMLHTMLHREF *) x));
}
static void *_p_PyOSISHTMLHREFTo_p_sword__OSISHTMLHREF(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::OSISHTMLHREF *)  ((PyOSISHTMLHREF *) x));
}
static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
}
static void *_p_sword__RawTextTo_p_sword__RawVerse(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::RawVerse *)  ((sword::RawText *) x));
}
static void *_p_sword__RawComTo_p_sword__RawVerse(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::RawVerse *)  ((sword::RawCom *) x));
}
static void *_p_sword__zComTo_p_sword__SWCom(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWCom *)  ((sword::zCom *) x));
}
static void *_p_sword__RawComTo_p_sword__SWCom(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWCom *)  ((sword::RawCom *) x));
}
static void *_p_sword__RawLD4To_p_sword__RawStr4(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::RawStr4 *)  ((sword::RawLD4 *) x));
}
static void *_p_sword__SWGenBookTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *)  ((sword::SWGenBook *) x));
}
static void *_p_sword__RawGenBookTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWGenBook *) ((sword::RawGenBook *) x));
}
static void *_p_sword__SWTextTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *)  ((sword::SWText *) x));
}
static void *_p_sword__zComTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWCom *) ((sword::zCom *) x));
}
static void *_p_sword__zTextTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWText *) ((sword::zText *) x));
}
static void *_p_sword__RawLDTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWLD *) ((sword::RawLD *) x));
}
static void *_p_sword__RawTextTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWText *) ((sword::RawText *) x));
}
static void *_p_sword__SWComTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *)  ((sword::SWCom *) x));
}
static void *_p_sword__SWLDTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *)  ((sword::SWLD *) x));
}
static void *_p_sword__RawLD4To_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWLD *) ((sword::RawLD4 *) x));
}
static void *_p_sword__RawComTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWCom *) ((sword::RawCom *) x));
}
static void *_p_sword__zLDTo_p_sword__SWModule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWModule *) (sword::SWLD *) ((sword::zLD *) x));
}
static void *_p_sword__zLDTo_p_sword__zStr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::zStr *)  ((sword::zLD *) x));
}
static void *_p_sword__SWDisplayTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *)  ((sword::SWDisplay *) x));
}
static void *_p_sword__ListKeyTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *) (sword::SWKey *) ((sword::ListKey *) x));
}
static void *_p_sword__TreeKeyIdxTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *) (sword::SWKey *)(sword::TreeKey *) ((sword::TreeKeyIdx *) x));
}
static void *_p_sword__VerseKeyTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *) (sword::SWKey *) ((sword::VerseKey *) x));
}
static void *_p_sword__SWKeyTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *)  ((sword::SWKey *) x));
}
static void *_p_sword__TreeKeyTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *) (sword::SWKey *) ((sword::TreeKey *) x));
}
static void *_p_sword__VerseTreeKeyTo_p_sword__SWObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWObject *) (sword::SWKey *)(sword::VerseKey *) ((sword::VerseTreeKey *) x));
}
static void *_p_sword__TreeKeyIdxTo_p_sword__TreeKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::TreeKey *)  ((sword::TreeKeyIdx *) x));
}
static void *_p_sword__zTextTo_p_sword__SWText(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWText *)  ((sword::zText *) x));
}
static void *_p_sword__RawTextTo_p_sword__SWText(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWText *)  ((sword::RawText *) x));
}
static void *_p_sword__LZSSCompressTo_p_sword__SWCompress(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWCompress *)  ((sword::LZSSCompress *) x));
}
static void *_p_sword__ZipCompressTo_p_sword__SWCompress(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWCompress *)  ((sword::ZipCompress *) x));
}
static void *_p_PyStringMgrTo_p_sword__StringMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::StringMgr *)  ((PyStringMgr *) x));
}
static void *_p_MyMarkupTo_p_sword__MarkupFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::MarkupFilterMgr *)  ((MyMarkup *) x));
}
static void *_p_sword__EncodingFilterMgrTo_p_sword__SWFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilterMgr *)  ((sword::EncodingFilterMgr *) x));
}
static void *_p_sword__MarkupFilterMgrTo_p_sword__SWFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilterMgr *) (sword::EncodingFilterMgr *) ((sword::MarkupFilterMgr *) x));
}
static void *_p_MyMarkupTo_p_sword__SWFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWFilterMgr *) (sword::EncodingFilterMgr *)(sword::MarkupFilterMgr *) ((MyMarkup *) x));
}
static void *_p_sword__MarkupFilterMgrTo_p_sword__EncodingFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::EncodingFilterMgr *)  ((sword::MarkupFilterMgr *) x));
}
static void *_p_MyMarkupTo_p_sword__EncodingFilterMgr(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::EncodingFilterMgr *) (sword::MarkupFilterMgr *) ((MyMarkup *) x));
}
static void *_p_sword__ListKeyTo_p_sword__SWKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWKey *)  ((sword::ListKey *) x));
}
static void *_p_sword__TreeKeyIdxTo_p_sword__SWKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWKey *) (sword::TreeKey *) ((sword::TreeKeyIdx *) x));
}
static void *_p_sword__VerseKeyTo_p_sword__SWKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWKey *)  ((sword::VerseKey *) x));
}
static void *_p_sword__TreeKeyTo_p_sword__SWKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWKey *)  ((sword::TreeKey *) x));
}
static void *_p_sword__VerseTreeKeyTo_p_sword__SWKey(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWKey *) (sword::VerseKey *) ((sword::VerseTreeKey *) x));
}
static void *_p_sword__zComTo_p_sword__zVerse(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::zVerse *)  ((sword::zCom *) x));
}
static void *_p_sword__zTextTo_p_sword__zVerse(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::zVerse *)  ((sword::zText *) x));
}
static void *_p_OSISDataTo_p_sword__BasicFilterUserData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::BasicFilterUserData *)  ((OSISData *) x));
}
static void *_p_ThMLDataTo_p_sword__BasicFilterUserData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::BasicFilterUserData *)  ((ThMLData *) x));
}
static void *_p_sword__RawGenBookTo_p_sword__SWGenBook(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWGenBook *)  ((sword::RawGenBook *) x));
}
static void *_p_sword__SWModuleTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *)  ((sword::SWModule *) x));
}
static void *_p_sword__SWGenBookTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *) ((sword::SWGenBook *) x));
}
static void *_p_sword__RawGenBookTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWGenBook *) ((sword::RawGenBook *) x));
}
static void *_p_sword__SWTextTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *) ((sword::SWText *) x));
}
static void *_p_sword__zComTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWCom *) ((sword::zCom *) x));
}
static void *_p_sword__zTextTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWText *) ((sword::zText *) x));
}
static void *_p_sword__RawLDTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWLD *) ((sword::RawLD *) x));
}
static void *_p_sword__RawTextTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWText *) ((sword::RawText *) x));
}
static void *_p_sword__SWComTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *) ((sword::SWCom *) x));
}
static void *_p_sword__SWLDTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *) ((sword::SWLD *) x));
}
static void *_p_sword__RawLD4To_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWLD *) ((sword::RawLD4 *) x));
}
static void *_p_sword__RawComTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWCom *) ((sword::RawCom *) x));
}
static void *_p_sword__zLDTo_p_sword__SWSearchable(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((sword::SWSearchable *) (sword::SWModule *)(sword::SWLD *) ((sword::zLD *) x));
}
static swig_type_info _swigt__p_MarkupCallback = {"_p_MarkupCallback", "MarkupCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MyMarkup = {"_p_MyMarkup", "MyMarkup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OSISData = {"_p_OSISData", "OSISData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ParameterMap = {"_p_ParameterMap", "ParameterMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PyOSISHTMLHREF = {"_p_PyOSISHTMLHREF", "PyOSISHTMLHREF *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PyStringMgr = {"_p_PyStringMgr", "PyStringMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PyThMLHTMLHREF = {"_p_PyThMLHTMLHREF", "PyThMLHTMLHREF *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RenderCallback = {"_p_RenderCallback", "RenderCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ReturnSuccess = {"_p_ReturnSuccess", "ReturnSuccess *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SWSearcher = {"_p_SWSearcher", "SWSearcher *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ThMLData = {"_p_ThMLData", "ThMLData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p___u16 = {"_p___u16", "__u16 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p___u32 = {"_p___u32", "__u32 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_first_type = {"_p_first_type", "first_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_key_type = {"_p_key_type", "key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mapped_type = {"_p_mapped_type", "mapped_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **|VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_second_type = {"_p_second_type", "second_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t", "std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > *|std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::allocator_type *|std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::allocator_type *|std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::allocator_type *|std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t", "std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > *|std::map< sword::SWBuf,sword::InstallSource * >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t", "std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > *|std::map< sword::SWBuf,sword::SWBuf >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t = {"_p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t", "std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > *|std::map< sword::SWBuf,sword::SWModule * >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_sword__DirEntry_t = {"_p_std__allocatorT_sword__DirEntry_t", "std::allocator< sword::DirEntry > *|std::vector< sword::DirEntry >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__allocatorT_sword__SWBuf_t = {"_p_std__allocatorT_sword__SWBuf_t", "std::allocator< sword::SWBuf > *|std::vector< sword::SWBuf >::allocator_type *|std::list< sword::SWBuf >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__lessT_sword__SWBuf_t = {"_p_std__lessT_sword__SWBuf_t", "std::less< sword::SWBuf > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t = {"_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t", "std::list< sword::SWBuf > *|sword::StringList *|std::list< sword::SWBuf,std::allocator< sword::SWBuf > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t = {"_p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t", "std::list< sword::SWFilter *,std::allocator< sword::SWFilter * > > *|sword::FilterList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t = {"_p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t", "std::list< sword::SWOptionFilter *,std::allocator< sword::SWOptionFilter * > > *|sword::OptionFilterList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t", "sword::AttributeTypeList *|std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > > > *|AttributeTypeListMap *|std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > > *|std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > > *|std::map< sword::SWBuf,AttributeListMap > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::iterator *|std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator", "std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::reverse_iterator *|std::map< sword::SWBuf,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,AttributeValueMap,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,AttributeValueMap > > > > > >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > *|std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > *|sword::AttributeList *|AttributeListMap *|std::map< sword::SWBuf,AttributeValueMap > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::iterator *|std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator", "std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::reverse_iterator *|std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t = {"_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t", "PySectionMap *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t = {"_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > > *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::iterator *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator", "std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::reverse_iterator *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::multimap< sword::SWBuf,sword::SWBuf > > > >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t", "std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > > *|std::map< sword::SWBuf,sword::InstallSource * > *|sword::InstallSourceMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator", "std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::iterator *|std::map< sword::SWBuf,sword::InstallSource * >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator", "std::map< sword::SWBuf,sword::InstallSource * >::reverse_iterator *|std::map< sword::SWBuf,sword::InstallSource *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::InstallSource * > > >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t", "std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > *|std::map< sword::SWBuf,sword::SWBuf > *|sword::AttributeValue *|sword::StringPairMap *|AttributeValueMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator", "std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::iterator *|std::map< sword::SWBuf,sword::SWBuf >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator", "std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >::reverse_iterator *|std::map< sword::SWBuf,sword::SWBuf >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t", "std::map< sword::SWBuf,sword::SWFilter *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWFilter * > > > *|sword::FilterMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t", "std::map< sword::SWBuf,sword::SWLocale *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWLocale * > > > *|sword::LocaleMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t", "std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > > *|sword::ModMap *|std::map< sword::SWBuf,sword::SWModule * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator = {"_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator", "std::map< sword::SWBuf,sword::SWModule * >::iterator *|std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator = {"_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator", "std::map< sword::SWBuf,sword::SWModule *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWModule * > > >::reverse_iterator *|std::map< sword::SWBuf,sword::SWModule * >::reverse_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t", "sword::OptionFilterMap *|std::map< sword::SWBuf,sword::SWOptionFilter *,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWOptionFilter * > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t = {"_p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t", "sword::SectionMap *|std::map< sword::SWBuf,sword::multimapwithdefault< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::multimapwithdefault< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t = {"_p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t", "PyConfigEntMap *|std::multimap< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_t = {"_p_std__multimapT_sword__SWBuf_sword__SWBuf_t", "std::multimap< sword::SWBuf,sword::SWBuf > *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::mapped_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t = {"_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t", "std::vector< sword::DirEntry > *|std::vector< sword::DirEntry,std::allocator< sword::DirEntry > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t = {"_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t", "std::vector< sword::SWBuf > *|std::vector< sword::SWBuf,std::allocator< sword::SWBuf > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__ConstIterator = {"_p_swig__ConstIterator", "swig::ConstIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__GC_VALUE = {"_p_swig__GC_VALUE", "swig::GC_VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__Iterator = {"_p_swig__Iterator", "swig::Iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__BasicFilterUserData = {"_p_sword__BasicFilterUserData", "sword::BasicFilterUserData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__DirEntry = {"_p_sword__DirEntry", "std::vector< sword::DirEntry >::value_type *|sword::DirEntry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__EncodingFilterMgr = {"_p_sword__EncodingFilterMgr", "sword::EncodingFilterMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__FTPTransport = {"_p_sword__FTPTransport", "sword::FTPTransport *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__FileDesc = {"_p_sword__FileDesc", "sword::FileDesc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__FileMgr = {"_p_sword__FileMgr", "sword::FileMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__GBFHTMLHREF = {"_p_sword__GBFHTMLHREF", "sword::GBFHTMLHREF *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__InstallMgr = {"_p_sword__InstallMgr", "sword::InstallMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__InstallSource = {"_p_sword__InstallSource", "sword::InstallSource *|std::map< sword::SWBuf,sword::InstallSource * >::mapped_type", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__LZSSCompress = {"_p_sword__LZSSCompress", "sword::LZSSCompress *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__ListKey = {"_p_sword__ListKey", "sword::ListKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__LocaleMgr = {"_p_sword__LocaleMgr", "sword::LocaleMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__MarkupFilterMgr = {"_p_sword__MarkupFilterMgr", "sword::MarkupFilterMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__OSISHTMLHREF = {"_p_sword__OSISHTMLHREF", "sword::OSISHTMLHREF *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__PLAINHTML = {"_p_sword__PLAINHTML", "sword::PLAINHTML *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawCom = {"_p_sword__RawCom", "sword::RawCom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawGenBook = {"_p_sword__RawGenBook", "sword::RawGenBook *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawLD = {"_p_sword__RawLD", "sword::RawLD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawLD4 = {"_p_sword__RawLD4", "sword::RawLD4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawStr = {"_p_sword__RawStr", "sword::RawStr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawStr4 = {"_p_sword__RawStr4", "sword::RawStr4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawText = {"_p_sword__RawText", "sword::RawText *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__RawVerse = {"_p_sword__RawVerse", "sword::RawVerse *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWBasicFilter = {"_p_sword__SWBasicFilter", "sword::SWBasicFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWBuf = {"_p_sword__SWBuf", "std::map< sword::SWBuf,sword::SWBuf >::mapped_type *|std::map< sword::SWBuf,sword::SWBuf >::key_type *|std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > >::key_type *|std::vector< sword::SWBuf >::value_type *|std::list< sword::SWBuf >::value_type *|std::map< sword::SWBuf,sword::SWModule * >::key_type *|std::map< sword::SWBuf,sword::InstallSource * >::key_type *|sword::SWBuf *|std::map< sword::SWBuf,std::multimap< sword::SWBuf,sword::SWBuf > >::key_type *|std::map< sword::SWBuf,std::map< sword::SWBuf,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > >,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,std::map< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf >,std::allocator< std::pair< sword::SWBuf const,sword::SWBuf > > > > > > >::key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWClass = {"_p_sword__SWClass", "sword::SWClass *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWCom = {"_p_sword__SWCom", "sword::SWCom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWCompress = {"_p_sword__SWCompress", "sword::SWCompress *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWConfig = {"_p_sword__SWConfig", "sword::SWConfig *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWDisplay = {"_p_sword__SWDisplay", "sword::SWDisplay *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWFilter = {"_p_sword__SWFilter", "sword::SWFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWFilterMgr = {"_p_sword__SWFilterMgr", "sword::SWFilterMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWGenBook = {"_p_sword__SWGenBook", "sword::SWGenBook *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWKey = {"_p_sword__SWKey", "sword::SWKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWLD = {"_p_sword__SWLD", "sword::SWLD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWLocale = {"_p_sword__SWLocale", "sword::SWLocale *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWLog = {"_p_sword__SWLog", "sword::SWLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWMgr = {"_p_sword__SWMgr", "sword::SWMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWModule = {"_p_sword__SWModule", "std::map< sword::SWBuf,sword::SWModule * >::mapped_type|sword::SWModule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWObject = {"_p_sword__SWObject", "sword::SWObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWOptionFilter = {"_p_sword__SWOptionFilter", "sword::SWOptionFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWSearchable = {"_p_sword__SWSearchable", "sword::SWSearchable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWText = {"_p_sword__SWText", "sword::SWText *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SWVersion = {"_p_sword__SWVersion", "sword::SWVersion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__SW_POSITION = {"_p_sword__SW_POSITION", "sword::SW_POSITION *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__StatusReporter = {"_p_sword__StatusReporter", "sword::StatusReporter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__StringMgr = {"_p_sword__StringMgr", "sword::StringMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__ThMLHTMLHREF = {"_p_sword__ThMLHTMLHREF", "sword::ThMLHTMLHREF *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__TreeKey = {"_p_sword__TreeKey", "sword::TreeKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__TreeKeyIdx = {"_p_sword__TreeKeyIdx", "sword::TreeKeyIdx *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__TreeKey__PositionChangeListener = {"_p_sword__TreeKey__PositionChangeListener", "sword::TreeKey::PositionChangeListener *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__URL = {"_p_sword__URL", "sword::URL *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__UTF8HTML = {"_p_sword__UTF8HTML", "sword::UTF8HTML *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__VerseKey = {"_p_sword__VerseKey", "sword::VerseKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__VerseMgr = {"_p_sword__VerseMgr", "sword::VerseMgr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__VerseMgr__System = {"_p_sword__VerseMgr__System", "sword::VerseMgr::System *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__VerseTreeKey = {"_p_sword__VerseTreeKey", "sword::VerseTreeKey *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__XMLTag = {"_p_sword__XMLTag", "sword::XMLTag *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__ZipCompress = {"_p_sword__ZipCompress", "sword::ZipCompress *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__abbrev = {"_p_sword__abbrev", "sword::abbrev *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t = {"_p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t", "sword::multimapwithdefault< sword::SWBuf,sword::SWBuf,std::less< sword::SWBuf > > *|sword::ConfigEntMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__sbook = {"_p_sword__sbook", "sword::sbook *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__zCom = {"_p_sword__zCom", "sword::zCom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__zLD = {"_p_sword__zLD", "sword::zLD *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__zStr = {"_p_sword__zStr", "sword::zStr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__zText = {"_p_sword__zText", "sword::zText *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sword__zVerse = {"_p_sword__zVerse", "sword::zVerse *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "VALUE|void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_MarkupCallback,
  &_swigt__p_MyMarkup,
  &_swigt__p_OSISData,
  &_swigt__p_ParameterMap,
  &_swigt__p_PyOSISHTMLHREF,
  &_swigt__p_PyStringMgr,
  &_swigt__p_PyThMLHTMLHREF,
  &_swigt__p_RenderCallback,
  &_swigt__p_ReturnSuccess,
  &_swigt__p_SWSearcher,
  &_swigt__p_ThMLData,
  &_swigt__p___u16,
  &_swigt__p___u32,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_difference_type,
  &_swigt__p_first_type,
  &_swigt__p_int,
  &_swigt__p_key_type,
  &_swigt__p_long,
  &_swigt__p_mapped_type,
  &_swigt__p_p_char,
  &_swigt__p_p_void,
  &_swigt__p_second_type,
  &_swigt__p_size_type,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t,
  &_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t,
  &_swigt__p_std__allocatorT_sword__DirEntry_t,
  &_swigt__p_std__allocatorT_sword__SWBuf_t,
  &_swigt__p_std__lessT_sword__SWBuf_t,
  &_swigt__p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,
  &_swigt__p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t,
  &_swigt__p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator,
  &_swigt__p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t,
  &_swigt__p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t,
  &_swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t,
  &_swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_t,
  &_swigt__p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t,
  &_swigt__p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,
  &_swigt__p_swig__ConstIterator,
  &_swigt__p_swig__GC_VALUE,
  &_swigt__p_swig__Iterator,
  &_swigt__p_sword__BasicFilterUserData,
  &_swigt__p_sword__DirEntry,
  &_swigt__p_sword__EncodingFilterMgr,
  &_swigt__p_sword__FTPTransport,
  &_swigt__p_sword__FileDesc,
  &_swigt__p_sword__FileMgr,
  &_swigt__p_sword__GBFHTMLHREF,
  &_swigt__p_sword__InstallMgr,
  &_swigt__p_sword__InstallSource,
  &_swigt__p_sword__LZSSCompress,
  &_swigt__p_sword__ListKey,
  &_swigt__p_sword__LocaleMgr,
  &_swigt__p_sword__MarkupFilterMgr,
  &_swigt__p_sword__OSISHTMLHREF,
  &_swigt__p_sword__PLAINHTML,
  &_swigt__p_sword__RawCom,
  &_swigt__p_sword__RawGenBook,
  &_swigt__p_sword__RawLD,
  &_swigt__p_sword__RawLD4,
  &_swigt__p_sword__RawStr,
  &_swigt__p_sword__RawStr4,
  &_swigt__p_sword__RawText,
  &_swigt__p_sword__RawVerse,
  &_swigt__p_sword__SWBasicFilter,
  &_swigt__p_sword__SWBuf,
  &_swigt__p_sword__SWClass,
  &_swigt__p_sword__SWCom,
  &_swigt__p_sword__SWCompress,
  &_swigt__p_sword__SWConfig,
  &_swigt__p_sword__SWDisplay,
  &_swigt__p_sword__SWFilter,
  &_swigt__p_sword__SWFilterMgr,
  &_swigt__p_sword__SWGenBook,
  &_swigt__p_sword__SWKey,
  &_swigt__p_sword__SWLD,
  &_swigt__p_sword__SWLocale,
  &_swigt__p_sword__SWLog,
  &_swigt__p_sword__SWMgr,
  &_swigt__p_sword__SWModule,
  &_swigt__p_sword__SWObject,
  &_swigt__p_sword__SWOptionFilter,
  &_swigt__p_sword__SWSearchable,
  &_swigt__p_sword__SWText,
  &_swigt__p_sword__SWVersion,
  &_swigt__p_sword__SW_POSITION,
  &_swigt__p_sword__StatusReporter,
  &_swigt__p_sword__StringMgr,
  &_swigt__p_sword__ThMLHTMLHREF,
  &_swigt__p_sword__TreeKey,
  &_swigt__p_sword__TreeKeyIdx,
  &_swigt__p_sword__TreeKey__PositionChangeListener,
  &_swigt__p_sword__URL,
  &_swigt__p_sword__UTF8HTML,
  &_swigt__p_sword__VerseKey,
  &_swigt__p_sword__VerseMgr,
  &_swigt__p_sword__VerseMgr__System,
  &_swigt__p_sword__VerseTreeKey,
  &_swigt__p_sword__XMLTag,
  &_swigt__p_sword__ZipCompress,
  &_swigt__p_sword__abbrev,
  &_swigt__p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t,
  &_swigt__p_sword__sbook,
  &_swigt__p_sword__zCom,
  &_swigt__p_sword__zLD,
  &_swigt__p_sword__zStr,
  &_swigt__p_sword__zText,
  &_swigt__p_sword__zVerse,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_value_type,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_MarkupCallback[] = {  {&_swigt__p_MarkupCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MyMarkup[] = {  {&_swigt__p_MyMarkup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OSISData[] = {  {&_swigt__p_OSISData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ParameterMap[] = {  {&_swigt__p_ParameterMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PyOSISHTMLHREF[] = {  {&_swigt__p_PyOSISHTMLHREF, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PyStringMgr[] = {  {&_swigt__p_PyStringMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PyThMLHTMLHREF[] = {  {&_swigt__p_PyThMLHTMLHREF, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RenderCallback[] = {  {&_swigt__p_RenderCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ReturnSuccess[] = {  {&_swigt__p_ReturnSuccess, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SWSearcher[] = {  {&_swigt__p_SWSearcher, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ThMLData[] = {  {&_swigt__p_ThMLData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p___u16[] = {  {&_swigt__p___u16, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p___u32[] = {  {&_swigt__p___u32, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_first_type[] = {  {&_swigt__p_first_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_key_type[] = {  {&_swigt__p_key_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mapped_type[] = {  {&_swigt__p_mapped_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_second_type[] = {  {&_swigt__p_second_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t[] = {  {&_swigt__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_sword__DirEntry_t[] = {  {&_swigt__p_std__allocatorT_sword__DirEntry_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__allocatorT_sword__SWBuf_t[] = {  {&_swigt__p_std__allocatorT_sword__SWBuf_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__lessT_sword__SWBuf_t[] = {  {&_swigt__p_std__lessT_sword__SWBuf_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t[] = {  {&_swigt__p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t[] = {  {&_swigt__p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t[] = {  {&_swigt__p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t[] = {  {&_swigt__p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t[] = {  {&_swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_sword__SWBuf_sword__SWBuf_t[] = {  {&_swigt__p_std__multimapT_sword__SWBuf_sword__SWBuf_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t[] = {  {&_swigt__p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t[] = {  {&_swigt__p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&_swigt__p_swig__ConstIterator, 0, 0, 0},  {&_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__Iterator[] = {  {&_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__BasicFilterUserData[] = {  {&_swigt__p_sword__BasicFilterUserData, 0, 0, 0},  {&_swigt__p_OSISData, _p_OSISDataTo_p_sword__BasicFilterUserData, 0, 0},  {&_swigt__p_ThMLData, _p_ThMLDataTo_p_sword__BasicFilterUserData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__DirEntry[] = {  {&_swigt__p_sword__DirEntry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__EncodingFilterMgr[] = {  {&_swigt__p_sword__EncodingFilterMgr, 0, 0, 0},  {&_swigt__p_sword__MarkupFilterMgr, _p_sword__MarkupFilterMgrTo_p_sword__EncodingFilterMgr, 0, 0},  {&_swigt__p_MyMarkup, _p_MyMarkupTo_p_sword__EncodingFilterMgr, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__FTPTransport[] = {  {&_swigt__p_sword__FTPTransport, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__FileDesc[] = {  {&_swigt__p_sword__FileDesc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__FileMgr[] = {  {&_swigt__p_sword__FileMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__GBFHTMLHREF[] = {  {&_swigt__p_sword__GBFHTMLHREF, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__InstallMgr[] = {  {&_swigt__p_sword__InstallMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__InstallSource[] = {  {&_swigt__p_sword__InstallSource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__LZSSCompress[] = {  {&_swigt__p_sword__LZSSCompress, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__ListKey[] = {  {&_swigt__p_sword__ListKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__LocaleMgr[] = {  {&_swigt__p_sword__LocaleMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__MarkupFilterMgr[] = {  {&_swigt__p_sword__MarkupFilterMgr, 0, 0, 0},  {&_swigt__p_MyMarkup, _p_MyMarkupTo_p_sword__MarkupFilterMgr, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__OSISHTMLHREF[] = {  {&_swigt__p_sword__OSISHTMLHREF, 0, 0, 0},  {&_swigt__p_PyOSISHTMLHREF, _p_PyOSISHTMLHREFTo_p_sword__OSISHTMLHREF, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__PLAINHTML[] = {  {&_swigt__p_sword__PLAINHTML, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawCom[] = {  {&_swigt__p_sword__RawCom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawGenBook[] = {  {&_swigt__p_sword__RawGenBook, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawLD[] = {  {&_swigt__p_sword__RawLD, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawLD4[] = {  {&_swigt__p_sword__RawLD4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawStr[] = {  {&_swigt__p_sword__RawStr, 0, 0, 0},  {&_swigt__p_sword__RawLD, _p_sword__RawLDTo_p_sword__RawStr, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawStr4[] = {  {&_swigt__p_sword__RawStr4, 0, 0, 0},  {&_swigt__p_sword__RawLD4, _p_sword__RawLD4To_p_sword__RawStr4, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawText[] = {  {&_swigt__p_sword__RawText, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__RawVerse[] = {  {&_swigt__p_sword__RawText, _p_sword__RawTextTo_p_sword__RawVerse, 0, 0},  {&_swigt__p_sword__RawVerse, 0, 0, 0},  {&_swigt__p_sword__RawCom, _p_sword__RawComTo_p_sword__RawVerse, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWBasicFilter[] = {  {&_swigt__p_sword__OSISHTMLHREF, _p_sword__OSISHTMLHREFTo_p_sword__SWBasicFilter, 0, 0},  {&_swigt__p_PyOSISHTMLHREF, _p_PyOSISHTMLHREFTo_p_sword__SWBasicFilter, 0, 0},  {&_swigt__p_sword__ThMLHTMLHREF, _p_sword__ThMLHTMLHREFTo_p_sword__SWBasicFilter, 0, 0},  {&_swigt__p_PyThMLHTMLHREF, _p_PyThMLHTMLHREFTo_p_sword__SWBasicFilter, 0, 0},  {&_swigt__p_sword__GBFHTMLHREF, _p_sword__GBFHTMLHREFTo_p_sword__SWBasicFilter, 0, 0},  {&_swigt__p_sword__SWBasicFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWBuf[] = {  {&_swigt__p_sword__SWBuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWClass[] = {  {&_swigt__p_sword__SWClass, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWCom[] = {  {&_swigt__p_sword__SWCom, 0, 0, 0},  {&_swigt__p_sword__zCom, _p_sword__zComTo_p_sword__SWCom, 0, 0},  {&_swigt__p_sword__RawCom, _p_sword__RawComTo_p_sword__SWCom, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWCompress[] = {  {&_swigt__p_sword__SWCompress, 0, 0, 0},  {&_swigt__p_sword__LZSSCompress, _p_sword__LZSSCompressTo_p_sword__SWCompress, 0, 0},  {&_swigt__p_sword__ZipCompress, _p_sword__ZipCompressTo_p_sword__SWCompress, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWConfig[] = {  {&_swigt__p_sword__SWConfig, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWDisplay[] = {  {&_swigt__p_sword__SWDisplay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWFilter[] = {  {&_swigt__p_sword__SWOptionFilter, _p_sword__SWOptionFilterTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__OSISHTMLHREF, _p_sword__OSISHTMLHREFTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_PyOSISHTMLHREF, _p_PyOSISHTMLHREFTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__ThMLHTMLHREF, _p_sword__ThMLHTMLHREFTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_PyThMLHTMLHREF, _p_PyThMLHTMLHREFTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__GBFHTMLHREF, _p_sword__GBFHTMLHREFTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__SWFilter, 0, 0, 0},  {&_swigt__p_sword__SWBasicFilter, _p_sword__SWBasicFilterTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__PLAINHTML, _p_sword__PLAINHTMLTo_p_sword__SWFilter, 0, 0},  {&_swigt__p_sword__UTF8HTML, _p_sword__UTF8HTMLTo_p_sword__SWFilter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWFilterMgr[] = {  {&_swigt__p_sword__SWFilterMgr, 0, 0, 0},  {&_swigt__p_sword__EncodingFilterMgr, _p_sword__EncodingFilterMgrTo_p_sword__SWFilterMgr, 0, 0},  {&_swigt__p_sword__MarkupFilterMgr, _p_sword__MarkupFilterMgrTo_p_sword__SWFilterMgr, 0, 0},  {&_swigt__p_MyMarkup, _p_MyMarkupTo_p_sword__SWFilterMgr, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWGenBook[] = {  {&_swigt__p_sword__SWGenBook, 0, 0, 0},  {&_swigt__p_sword__RawGenBook, _p_sword__RawGenBookTo_p_sword__SWGenBook, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWKey[] = {  {&_swigt__p_sword__SWKey, 0, 0, 0},  {&_swigt__p_sword__ListKey, _p_sword__ListKeyTo_p_sword__SWKey, 0, 0},  {&_swigt__p_sword__TreeKeyIdx, _p_sword__TreeKeyIdxTo_p_sword__SWKey, 0, 0},  {&_swigt__p_sword__VerseKey, _p_sword__VerseKeyTo_p_sword__SWKey, 0, 0},  {&_swigt__p_sword__VerseTreeKey, _p_sword__VerseTreeKeyTo_p_sword__SWKey, 0, 0},  {&_swigt__p_sword__TreeKey, _p_sword__TreeKeyTo_p_sword__SWKey, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWLD[] = {  {&_swigt__p_sword__SWLD, 0, 0, 0},  {&_swigt__p_sword__zLD, _p_sword__zLDTo_p_sword__SWLD, 0, 0},  {&_swigt__p_sword__RawLD, _p_sword__RawLDTo_p_sword__SWLD, 0, 0},  {&_swigt__p_sword__RawLD4, _p_sword__RawLD4To_p_sword__SWLD, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWLocale[] = {  {&_swigt__p_sword__SWLocale, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWLog[] = {  {&_swigt__p_sword__SWLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWMgr[] = {  {&_swigt__p_sword__SWMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWModule[] = {  {&_swigt__p_sword__SWLD, _p_sword__SWLDTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__SWModule, 0, 0, 0},  {&_swigt__p_sword__zLD, _p_sword__zLDTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__SWGenBook, _p_sword__SWGenBookTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__RawGenBook, _p_sword__RawGenBookTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__SWText, _p_sword__SWTextTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__zText, _p_sword__zTextTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__RawText, _p_sword__RawTextTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__RawLD, _p_sword__RawLDTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__RawLD4, _p_sword__RawLD4To_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__zCom, _p_sword__zComTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__SWCom, _p_sword__SWComTo_p_sword__SWModule, 0, 0},  {&_swigt__p_sword__RawCom, _p_sword__RawComTo_p_sword__SWModule, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWObject[] = {  {&_swigt__p_sword__SWDisplay, _p_sword__SWDisplayTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__SWKey, _p_sword__SWKeyTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__ListKey, _p_sword__ListKeyTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__TreeKeyIdx, _p_sword__TreeKeyIdxTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__SWObject, 0, 0, 0},  {&_swigt__p_sword__VerseKey, _p_sword__VerseKeyTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__VerseTreeKey, _p_sword__VerseTreeKeyTo_p_sword__SWObject, 0, 0},  {&_swigt__p_sword__TreeKey, _p_sword__TreeKeyTo_p_sword__SWObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWOptionFilter[] = {  {&_swigt__p_sword__SWOptionFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWSearchable[] = {  {&_swigt__p_sword__RawLD4, _p_sword__RawLD4To_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWCom, _p_sword__SWComTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__RawCom, _p_sword__RawComTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWGenBook, _p_sword__SWGenBookTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__RawGenBook, _p_sword__RawGenBookTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__RawLD, _p_sword__RawLDTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWModule, _p_sword__SWModuleTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWLD, _p_sword__SWLDTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__zText, _p_sword__zTextTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWSearchable, 0, 0, 0},  {&_swigt__p_sword__zLD, _p_sword__zLDTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__zCom, _p_sword__zComTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__RawText, _p_sword__RawTextTo_p_sword__SWSearchable, 0, 0},  {&_swigt__p_sword__SWText, _p_sword__SWTextTo_p_sword__SWSearchable, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWText[] = {  {&_swigt__p_sword__SWText, 0, 0, 0},  {&_swigt__p_sword__zText, _p_sword__zTextTo_p_sword__SWText, 0, 0},  {&_swigt__p_sword__RawText, _p_sword__RawTextTo_p_sword__SWText, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SWVersion[] = {  {&_swigt__p_sword__SWVersion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__SW_POSITION[] = {  {&_swigt__p_sword__SW_POSITION, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__StatusReporter[] = {  {&_swigt__p_sword__StatusReporter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__StringMgr[] = {  {&_swigt__p_sword__StringMgr, 0, 0, 0},  {&_swigt__p_PyStringMgr, _p_PyStringMgrTo_p_sword__StringMgr, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__ThMLHTMLHREF[] = {  {&_swigt__p_sword__ThMLHTMLHREF, 0, 0, 0},  {&_swigt__p_PyThMLHTMLHREF, _p_PyThMLHTMLHREFTo_p_sword__ThMLHTMLHREF, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__TreeKey[] = {  {&_swigt__p_sword__TreeKeyIdx, _p_sword__TreeKeyIdxTo_p_sword__TreeKey, 0, 0},  {&_swigt__p_sword__TreeKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__TreeKeyIdx[] = {  {&_swigt__p_sword__TreeKeyIdx, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__TreeKey__PositionChangeListener[] = {  {&_swigt__p_sword__TreeKey__PositionChangeListener, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__URL[] = {  {&_swigt__p_sword__URL, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__UTF8HTML[] = {  {&_swigt__p_sword__UTF8HTML, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__VerseKey[] = {  {&_swigt__p_sword__VerseKey, 0, 0, 0},  {&_swigt__p_sword__VerseTreeKey, _p_sword__VerseTreeKeyTo_p_sword__VerseKey, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__VerseMgr[] = {  {&_swigt__p_sword__VerseMgr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__VerseMgr__System[] = {  {&_swigt__p_sword__VerseMgr__System, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__VerseTreeKey[] = {  {&_swigt__p_sword__VerseTreeKey, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__XMLTag[] = {  {&_swigt__p_sword__XMLTag, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__ZipCompress[] = {  {&_swigt__p_sword__ZipCompress, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__abbrev[] = {  {&_swigt__p_sword__abbrev, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t[] = {  {&_swigt__p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__sbook[] = {  {&_swigt__p_sword__sbook, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__zCom[] = {  {&_swigt__p_sword__zCom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__zLD[] = {  {&_swigt__p_sword__zLD, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__zStr[] = {  {&_swigt__p_sword__zLD, _p_sword__zLDTo_p_sword__zStr, 0, 0},  {&_swigt__p_sword__zStr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__zText[] = {  {&_swigt__p_sword__zText, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sword__zVerse[] = {  {&_swigt__p_sword__zText, _p_sword__zTextTo_p_sword__zVerse, 0, 0},  {&_swigt__p_sword__zVerse, 0, 0, 0},  {&_swigt__p_sword__zCom, _p_sword__zComTo_p_sword__zVerse, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_MarkupCallback,
  _swigc__p_MyMarkup,
  _swigc__p_OSISData,
  _swigc__p_ParameterMap,
  _swigc__p_PyOSISHTMLHREF,
  _swigc__p_PyStringMgr,
  _swigc__p_PyThMLHTMLHREF,
  _swigc__p_RenderCallback,
  _swigc__p_ReturnSuccess,
  _swigc__p_SWSearcher,
  _swigc__p_ThMLData,
  _swigc__p___u16,
  _swigc__p___u32,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_difference_type,
  _swigc__p_first_type,
  _swigc__p_int,
  _swigc__p_key_type,
  _swigc__p_long,
  _swigc__p_mapped_type,
  _swigc__p_p_char,
  _swigc__p_p_void,
  _swigc__p_second_type,
  _swigc__p_size_type,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t,
  _swigc__p_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t,
  _swigc__p_std__allocatorT_sword__DirEntry_t,
  _swigc__p_std__allocatorT_sword__SWBuf_t,
  _swigc__p_std__lessT_sword__SWBuf_t,
  _swigc__p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,
  _swigc__p_std__listT_sword__SWFilter_p_std__allocatorT_sword__SWFilter_p_t_t,
  _swigc__p_std__listT_sword__SWOptionFilter_p_std__allocatorT_sword__SWOptionFilter_p_t_t,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWFilter_p_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWLocale_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWLocale_p_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t__reverse_iterator,
  _swigc__p_std__mapT_sword__SWBuf_sword__SWOptionFilter_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWOptionFilter_p_t_t_t,
  _swigc__p_std__mapT_sword__SWBuf_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t_t_t_t,
  _swigc__p_std__multimapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t,
  _swigc__p_std__multimapT_sword__SWBuf_sword__SWBuf_t,
  _swigc__p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t,
  _swigc__p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t,
  _swigc__p_swig__ConstIterator,
  _swigc__p_swig__GC_VALUE,
  _swigc__p_swig__Iterator,
  _swigc__p_sword__BasicFilterUserData,
  _swigc__p_sword__DirEntry,
  _swigc__p_sword__EncodingFilterMgr,
  _swigc__p_sword__FTPTransport,
  _swigc__p_sword__FileDesc,
  _swigc__p_sword__FileMgr,
  _swigc__p_sword__GBFHTMLHREF,
  _swigc__p_sword__InstallMgr,
  _swigc__p_sword__InstallSource,
  _swigc__p_sword__LZSSCompress,
  _swigc__p_sword__ListKey,
  _swigc__p_sword__LocaleMgr,
  _swigc__p_sword__MarkupFilterMgr,
  _swigc__p_sword__OSISHTMLHREF,
  _swigc__p_sword__PLAINHTML,
  _swigc__p_sword__RawCom,
  _swigc__p_sword__RawGenBook,
  _swigc__p_sword__RawLD,
  _swigc__p_sword__RawLD4,
  _swigc__p_sword__RawStr,
  _swigc__p_sword__RawStr4,
  _swigc__p_sword__RawText,
  _swigc__p_sword__RawVerse,
  _swigc__p_sword__SWBasicFilter,
  _swigc__p_sword__SWBuf,
  _swigc__p_sword__SWClass,
  _swigc__p_sword__SWCom,
  _swigc__p_sword__SWCompress,
  _swigc__p_sword__SWConfig,
  _swigc__p_sword__SWDisplay,
  _swigc__p_sword__SWFilter,
  _swigc__p_sword__SWFilterMgr,
  _swigc__p_sword__SWGenBook,
  _swigc__p_sword__SWKey,
  _swigc__p_sword__SWLD,
  _swigc__p_sword__SWLocale,
  _swigc__p_sword__SWLog,
  _swigc__p_sword__SWMgr,
  _swigc__p_sword__SWModule,
  _swigc__p_sword__SWObject,
  _swigc__p_sword__SWOptionFilter,
  _swigc__p_sword__SWSearchable,
  _swigc__p_sword__SWText,
  _swigc__p_sword__SWVersion,
  _swigc__p_sword__SW_POSITION,
  _swigc__p_sword__StatusReporter,
  _swigc__p_sword__StringMgr,
  _swigc__p_sword__ThMLHTMLHREF,
  _swigc__p_sword__TreeKey,
  _swigc__p_sword__TreeKeyIdx,
  _swigc__p_sword__TreeKey__PositionChangeListener,
  _swigc__p_sword__URL,
  _swigc__p_sword__UTF8HTML,
  _swigc__p_sword__VerseKey,
  _swigc__p_sword__VerseMgr,
  _swigc__p_sword__VerseMgr__System,
  _swigc__p_sword__VerseTreeKey,
  _swigc__p_sword__XMLTag,
  _swigc__p_sword__ZipCompress,
  _swigc__p_sword__abbrev,
  _swigc__p_sword__multimapwithdefaultT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_t,
  _swigc__p_sword__sbook,
  _swigc__p_sword__zCom,
  _swigc__p_sword__zLD,
  _swigc__p_sword__zStr,
  _swigc__p_sword__zText,
  _swigc__p_sword__zVerse,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_short,
  _swigc__p_value_type,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_rsword(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mSword = rb_define_module("Sword");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  rb_define_const(mSword, "DIRECTION_LTR", SWIG_From_int(static_cast< int >(sword::DIRECTION_LTR)));
  rb_define_const(mSword, "DIRECTION_RTL", SWIG_From_int(static_cast< int >(sword::DIRECTION_RTL)));
  rb_define_const(mSword, "DIRECTION_BIDI", SWIG_From_int(static_cast< int >(sword::DIRECTION_BIDI)));
  rb_define_const(mSword, "FMT_UNKNOWN", SWIG_From_int(static_cast< int >(sword::FMT_UNKNOWN)));
  rb_define_const(mSword, "FMT_PLAIN", SWIG_From_int(static_cast< int >(sword::FMT_PLAIN)));
  rb_define_const(mSword, "FMT_THML", SWIG_From_int(static_cast< int >(sword::FMT_THML)));
  rb_define_const(mSword, "FMT_GBF", SWIG_From_int(static_cast< int >(sword::FMT_GBF)));
  rb_define_const(mSword, "FMT_HTML", SWIG_From_int(static_cast< int >(sword::FMT_HTML)));
  rb_define_const(mSword, "FMT_HTMLHREF", SWIG_From_int(static_cast< int >(sword::FMT_HTMLHREF)));
  rb_define_const(mSword, "FMT_RTF", SWIG_From_int(static_cast< int >(sword::FMT_RTF)));
  rb_define_const(mSword, "FMT_OSIS", SWIG_From_int(static_cast< int >(sword::FMT_OSIS)));
  rb_define_const(mSword, "FMT_WEBIF", SWIG_From_int(static_cast< int >(sword::FMT_WEBIF)));
  rb_define_const(mSword, "FMT_TEI", SWIG_From_int(static_cast< int >(sword::FMT_TEI)));
  rb_define_const(mSword, "FMT_XHTML", SWIG_From_int(static_cast< int >(sword::FMT_XHTML)));
  rb_define_const(mSword, "ENC_UNKNOWN", SWIG_From_int(static_cast< int >(sword::ENC_UNKNOWN)));
  rb_define_const(mSword, "ENC_LATIN1", SWIG_From_int(static_cast< int >(sword::ENC_LATIN1)));
  rb_define_const(mSword, "ENC_UTF8", SWIG_From_int(static_cast< int >(sword::ENC_UTF8)));
  rb_define_const(mSword, "ENC_UTF16", SWIG_From_int(static_cast< int >(sword::ENC_UTF16)));
  rb_define_const(mSword, "ENC_RTF", SWIG_From_int(static_cast< int >(sword::ENC_RTF)));
  rb_define_const(mSword, "ENC_HTML", SWIG_From_int(static_cast< int >(sword::ENC_HTML)));
  rb_define_const(mSword, "JUNKBUFSIZE", SWIG_From_int(static_cast< int >(65534)));
  
  SwigClassSWBuf.klass = rb_define_class_under(mSword, "SWBuf", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWBuf, (void *) &SwigClassSWBuf);
  rb_define_alloc_func(SwigClassSWBuf.klass, _wrap_SWBuf_allocate);
  rb_define_method(SwigClassSWBuf.klass, "initialize", VALUEFUNC(_wrap_new_SWBuf), -1);
  rb_define_method(SwigClassSWBuf.klass, "setFillByte", VALUEFUNC(_wrap_SWBuf_setFillByte), -1);
  rb_define_method(SwigClassSWBuf.klass, "getFillByte", VALUEFUNC(_wrap_SWBuf_getFillByte), -1);
  rb_define_method(SwigClassSWBuf.klass, "c_str", VALUEFUNC(_wrap_SWBuf_c_str), -1);
  rb_define_method(SwigClassSWBuf.klass, "size", VALUEFUNC(_wrap_SWBuf_size), -1);
  rb_define_method(SwigClassSWBuf.klass, "length", VALUEFUNC(_wrap_SWBuf_length), -1);
  rb_define_method(SwigClassSWBuf.klass, "set", VALUEFUNC(_wrap_SWBuf_set), -1);
  rb_define_method(SwigClassSWBuf.klass, "setFormatted", VALUEFUNC(_wrap_SWBuf_setFormatted), -1);
  rb_define_method(SwigClassSWBuf.klass, "setSize", VALUEFUNC(_wrap_SWBuf_setSize), -1);
  rb_define_method(SwigClassSWBuf.klass, "resize", VALUEFUNC(_wrap_SWBuf_resize), -1);
  rb_define_method(SwigClassSWBuf.klass, "append", VALUEFUNC(_wrap_SWBuf_append), -1);
  rb_define_method(SwigClassSWBuf.klass, "appendFormatted", VALUEFUNC(_wrap_SWBuf_appendFormatted), -1);
  rb_define_method(SwigClassSWBuf.klass, "insert", VALUEFUNC(_wrap_SWBuf_insert), -1);
  rb_define_method(SwigClassSWBuf.klass, "getRawData", VALUEFUNC(_wrap_SWBuf_getRawData), -1);
  rb_define_method(SwigClassSWBuf.klass, "trimStart", VALUEFUNC(_wrap_SWBuf_trimStart), -1);
  rb_define_method(SwigClassSWBuf.klass, "trimEnd", VALUEFUNC(_wrap_SWBuf_trimEnd), -1);
  rb_define_method(SwigClassSWBuf.klass, "trim", VALUEFUNC(_wrap_SWBuf_trim), -1);
  rb_define_method(SwigClassSWBuf.klass, "stripPrefix", VALUEFUNC(_wrap_SWBuf_stripPrefix), -1);
  rb_define_method(SwigClassSWBuf.klass, "replaceBytes", VALUEFUNC(_wrap_SWBuf_replaceBytes), -1);
  rb_define_method(SwigClassSWBuf.klass, "indexOf", VALUEFUNC(_wrap_SWBuf_indexOf), -1);
  rb_define_method(SwigClassSWBuf.klass, "startsWith", VALUEFUNC(_wrap_SWBuf_startsWith), -1);
  rb_define_method(SwigClassSWBuf.klass, "endsWith", VALUEFUNC(_wrap_SWBuf_endsWith), -1);
  rb_define_method(SwigClassSWBuf.klass, "compare", VALUEFUNC(_wrap_SWBuf_compare), -1);
  rb_define_method(SwigClassSWBuf.klass, "charAt2", VALUEFUNC(_wrap_SWBuf_charAt2), -1);
  SwigClassSWBuf.mark = 0;
  SwigClassSWBuf.destroy = (void (*)(void *)) free_sword_SWBuf;
  SwigClassSWBuf.trackObjects = 0;
  
  SwigClassGC_VALUE.klass = rb_define_class_under(mSword, "GC_VALUE", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &SwigClassGC_VALUE);
  rb_undef_alloc_func(SwigClassGC_VALUE.klass);
  rb_define_method(SwigClassGC_VALUE.klass, "inspect", VALUEFUNC(_wrap_GC_VALUE_inspect), -1);
  rb_define_method(SwigClassGC_VALUE.klass, "to_s", VALUEFUNC(_wrap_GC_VALUE_to_s), -1);
  SwigClassGC_VALUE.mark = 0;
  SwigClassGC_VALUE.trackObjects = 0;
  
  swig::GC_VALUE::initialize();
  
  
  SwigClassConstIterator.klass = rb_define_class_under(mSword, "ConstIterator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &SwigClassConstIterator);
  rb_undef_alloc_func(SwigClassConstIterator.klass);
  rb_define_method(SwigClassConstIterator.klass, "value", VALUEFUNC(_wrap_ConstIterator_value), -1);
  rb_define_method(SwigClassConstIterator.klass, "dup", VALUEFUNC(_wrap_ConstIterator_dup), -1);
  rb_define_method(SwigClassConstIterator.klass, "inspect", VALUEFUNC(_wrap_ConstIterator_inspect), -1);
  rb_define_method(SwigClassConstIterator.klass, "to_s", VALUEFUNC(_wrap_ConstIterator_to_s), -1);
  rb_define_method(SwigClassConstIterator.klass, "next", VALUEFUNC(_wrap_ConstIterator_next), -1);
  rb_define_method(SwigClassConstIterator.klass, "previous", VALUEFUNC(_wrap_ConstIterator_previous), -1);
  rb_define_method(SwigClassConstIterator.klass, "==", VALUEFUNC(_wrap_ConstIterator___eq__), -1);
  rb_define_method(SwigClassConstIterator.klass, "+", VALUEFUNC(_wrap_ConstIterator___add__), -1);
  rb_define_method(SwigClassConstIterator.klass, "-", VALUEFUNC(_wrap_ConstIterator___sub__), -1);
  SwigClassConstIterator.mark = 0;
  SwigClassConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
  SwigClassConstIterator.trackObjects = 0;
  
  SwigClassIterator.klass = rb_define_class_under(mSword, "Iterator", ((swig_class *) SWIGTYPE_p_swig__ConstIterator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &SwigClassIterator);
  rb_undef_alloc_func(SwigClassIterator.klass);
  rb_define_method(SwigClassIterator.klass, "value=", VALUEFUNC(_wrap_Iterator_valuee___), -1);
  rb_define_method(SwigClassIterator.klass, "dup", VALUEFUNC(_wrap_Iterator_dup), -1);
  rb_define_method(SwigClassIterator.klass, "next", VALUEFUNC(_wrap_Iterator_next), -1);
  rb_define_method(SwigClassIterator.klass, "previous", VALUEFUNC(_wrap_Iterator_previous), -1);
  rb_define_method(SwigClassIterator.klass, "inspect", VALUEFUNC(_wrap_Iterator_inspect), -1);
  rb_define_method(SwigClassIterator.klass, "to_s", VALUEFUNC(_wrap_Iterator_to_s), -1);
  rb_define_method(SwigClassIterator.klass, "==", VALUEFUNC(_wrap_Iterator___eq__), -1);
  rb_define_method(SwigClassIterator.klass, "+", VALUEFUNC(_wrap_Iterator___add__), -1);
  rb_define_method(SwigClassIterator.klass, "-", VALUEFUNC(_wrap_Iterator___sub__), -1);
  SwigClassIterator.mark = 0;
  SwigClassIterator.destroy = (void (*)(void *)) free_swig_Iterator;
  SwigClassIterator.trackObjects = 0;
  
  SwigClassAttributeValueMap.klass = rb_define_class_under(mSword, "AttributeValueMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t, (void *) &SwigClassAttributeValueMap);
  rb_include_module(SwigClassAttributeValueMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassAttributeValueMap.klass, _wrap_AttributeValueMap_allocate);
  rb_define_method(SwigClassAttributeValueMap.klass, "initialize", VALUEFUNC(_wrap_new_AttributeValueMap), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "dup", VALUEFUNC(_wrap_AttributeValueMap_dup), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "delete", VALUEFUNC(_wrap_AttributeValueMap_delete), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "has_key?", VALUEFUNC(_wrap_AttributeValueMap_has_keyq___), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "keys", VALUEFUNC(_wrap_AttributeValueMap_keys), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "each", VALUEFUNC(_wrap_AttributeValueMap_each), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "select", VALUEFUNC(_wrap_AttributeValueMap_select), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "values_at", VALUEFUNC(_wrap_AttributeValueMap_values_at), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "each_key", VALUEFUNC(_wrap_AttributeValueMap_each_key), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "values", VALUEFUNC(_wrap_AttributeValueMap_values), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "each_value", VALUEFUNC(_wrap_AttributeValueMap_each_value), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "entries", VALUEFUNC(_wrap_AttributeValueMap_entries), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "include?", VALUEFUNC(_wrap_AttributeValueMap_includeq___), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "key_iterator", VALUEFUNC(_wrap_AttributeValueMap_key_iterator), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "value_iterator", VALUEFUNC(_wrap_AttributeValueMap_value_iterator), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "[]", VALUEFUNC(_wrap_AttributeValueMap___getitem__), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "[]=", VALUEFUNC(_wrap_AttributeValueMap___setitem__), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "inspect", VALUEFUNC(_wrap_AttributeValueMap_inspect), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "to_a", VALUEFUNC(_wrap_AttributeValueMap_to_a), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "to_s", VALUEFUNC(_wrap_AttributeValueMap_to_s), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "empty?", VALUEFUNC(_wrap_AttributeValueMap_emptyq___), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "size", VALUEFUNC(_wrap_AttributeValueMap_size), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "clear", VALUEFUNC(_wrap_AttributeValueMap_clear), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "swap", VALUEFUNC(_wrap_AttributeValueMap_swap), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "get_allocator", VALUEFUNC(_wrap_AttributeValueMap_get_allocator), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "begin", VALUEFUNC(_wrap_AttributeValueMap_begin), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "end", VALUEFUNC(_wrap_AttributeValueMap_end), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "rbegin", VALUEFUNC(_wrap_AttributeValueMap_rbegin), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "rend", VALUEFUNC(_wrap_AttributeValueMap_rend), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "count", VALUEFUNC(_wrap_AttributeValueMap_count), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "erase", VALUEFUNC(_wrap_AttributeValueMap_erase), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "find", VALUEFUNC(_wrap_AttributeValueMap_find), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "lower_bound", VALUEFUNC(_wrap_AttributeValueMap_lower_bound), -1);
  rb_define_method(SwigClassAttributeValueMap.klass, "upper_bound", VALUEFUNC(_wrap_AttributeValueMap_upper_bound), -1);
  SwigClassAttributeValueMap.mark = 0;
  SwigClassAttributeValueMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg_;
  SwigClassAttributeValueMap.trackObjects = 0;
  
  SwigClassAttributeListMap.klass = rb_define_class_under(mSword, "AttributeListMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_sword__SWBuf_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWBuf_t_t_t_t_t_t, (void *) &SwigClassAttributeListMap);
  rb_include_module(SwigClassAttributeListMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassAttributeListMap.klass, _wrap_AttributeListMap_allocate);
  rb_define_method(SwigClassAttributeListMap.klass, "initialize", VALUEFUNC(_wrap_new_AttributeListMap), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "dup", VALUEFUNC(_wrap_AttributeListMap_dup), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "delete", VALUEFUNC(_wrap_AttributeListMap_delete), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "has_key?", VALUEFUNC(_wrap_AttributeListMap_has_keyq___), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "keys", VALUEFUNC(_wrap_AttributeListMap_keys), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "each", VALUEFUNC(_wrap_AttributeListMap_each), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "select", VALUEFUNC(_wrap_AttributeListMap_select), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "values_at", VALUEFUNC(_wrap_AttributeListMap_values_at), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "each_key", VALUEFUNC(_wrap_AttributeListMap_each_key), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "values", VALUEFUNC(_wrap_AttributeListMap_values), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "each_value", VALUEFUNC(_wrap_AttributeListMap_each_value), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "entries", VALUEFUNC(_wrap_AttributeListMap_entries), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "include?", VALUEFUNC(_wrap_AttributeListMap_includeq___), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "key_iterator", VALUEFUNC(_wrap_AttributeListMap_key_iterator), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "value_iterator", VALUEFUNC(_wrap_AttributeListMap_value_iterator), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "[]", VALUEFUNC(_wrap_AttributeListMap___getitem__), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "[]=", VALUEFUNC(_wrap_AttributeListMap___setitem__), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "inspect", VALUEFUNC(_wrap_AttributeListMap_inspect), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "to_a", VALUEFUNC(_wrap_AttributeListMap_to_a), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "to_s", VALUEFUNC(_wrap_AttributeListMap_to_s), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "empty?", VALUEFUNC(_wrap_AttributeListMap_emptyq___), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "size", VALUEFUNC(_wrap_AttributeListMap_size), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "clear", VALUEFUNC(_wrap_AttributeListMap_clear), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "swap", VALUEFUNC(_wrap_AttributeListMap_swap), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "get_allocator", VALUEFUNC(_wrap_AttributeListMap_get_allocator), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "begin", VALUEFUNC(_wrap_AttributeListMap_begin), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "end", VALUEFUNC(_wrap_AttributeListMap_end), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "rbegin", VALUEFUNC(_wrap_AttributeListMap_rbegin), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "rend", VALUEFUNC(_wrap_AttributeListMap_rend), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "count", VALUEFUNC(_wrap_AttributeListMap_count), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "erase", VALUEFUNC(_wrap_AttributeListMap_erase), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "find", VALUEFUNC(_wrap_AttributeListMap_find), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "lower_bound", VALUEFUNC(_wrap_AttributeListMap_lower_bound), -1);
  rb_define_method(SwigClassAttributeListMap.klass, "upper_bound", VALUEFUNC(_wrap_AttributeListMap_upper_bound), -1);
  SwigClassAttributeListMap.mark = 0;
  SwigClassAttributeListMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_AttributeValueMap_Sg_;
  SwigClassAttributeListMap.trackObjects = 0;
  
  SwigClassAttributeTypeListMap.klass = rb_define_class_under(mSword, "AttributeTypeListMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__mapT_sword__SWBuf_AttributeValueMap_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_AttributeValueMap_t_t_t_t_t_t, (void *) &SwigClassAttributeTypeListMap);
  rb_include_module(SwigClassAttributeTypeListMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassAttributeTypeListMap.klass, _wrap_AttributeTypeListMap_allocate);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "initialize", VALUEFUNC(_wrap_new_AttributeTypeListMap), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "dup", VALUEFUNC(_wrap_AttributeTypeListMap_dup), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "delete", VALUEFUNC(_wrap_AttributeTypeListMap_delete), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "has_key?", VALUEFUNC(_wrap_AttributeTypeListMap_has_keyq___), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "keys", VALUEFUNC(_wrap_AttributeTypeListMap_keys), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "each", VALUEFUNC(_wrap_AttributeTypeListMap_each), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "select", VALUEFUNC(_wrap_AttributeTypeListMap_select), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "values_at", VALUEFUNC(_wrap_AttributeTypeListMap_values_at), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "each_key", VALUEFUNC(_wrap_AttributeTypeListMap_each_key), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "values", VALUEFUNC(_wrap_AttributeTypeListMap_values), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "each_value", VALUEFUNC(_wrap_AttributeTypeListMap_each_value), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "entries", VALUEFUNC(_wrap_AttributeTypeListMap_entries), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "include?", VALUEFUNC(_wrap_AttributeTypeListMap_includeq___), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "key_iterator", VALUEFUNC(_wrap_AttributeTypeListMap_key_iterator), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "value_iterator", VALUEFUNC(_wrap_AttributeTypeListMap_value_iterator), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "[]", VALUEFUNC(_wrap_AttributeTypeListMap___getitem__), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "[]=", VALUEFUNC(_wrap_AttributeTypeListMap___setitem__), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "inspect", VALUEFUNC(_wrap_AttributeTypeListMap_inspect), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "to_a", VALUEFUNC(_wrap_AttributeTypeListMap_to_a), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "to_s", VALUEFUNC(_wrap_AttributeTypeListMap_to_s), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "empty?", VALUEFUNC(_wrap_AttributeTypeListMap_emptyq___), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "size", VALUEFUNC(_wrap_AttributeTypeListMap_size), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "clear", VALUEFUNC(_wrap_AttributeTypeListMap_clear), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "swap", VALUEFUNC(_wrap_AttributeTypeListMap_swap), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "get_allocator", VALUEFUNC(_wrap_AttributeTypeListMap_get_allocator), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "begin", VALUEFUNC(_wrap_AttributeTypeListMap_begin), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "end", VALUEFUNC(_wrap_AttributeTypeListMap_end), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "rbegin", VALUEFUNC(_wrap_AttributeTypeListMap_rbegin), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "rend", VALUEFUNC(_wrap_AttributeTypeListMap_rend), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "count", VALUEFUNC(_wrap_AttributeTypeListMap_count), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "erase", VALUEFUNC(_wrap_AttributeTypeListMap_erase), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "find", VALUEFUNC(_wrap_AttributeTypeListMap_find), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "lower_bound", VALUEFUNC(_wrap_AttributeTypeListMap_lower_bound), -1);
  rb_define_method(SwigClassAttributeTypeListMap.klass, "upper_bound", VALUEFUNC(_wrap_AttributeTypeListMap_upper_bound), -1);
  SwigClassAttributeTypeListMap.mark = 0;
  SwigClassAttributeTypeListMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_AttributeListMap_Sg_;
  SwigClassAttributeTypeListMap.trackObjects = 0;
  
  SwigClassPySectionMap.klass = rb_define_class_under(mSword, "PySectionMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_std__multimapT_sword__SWBuf_sword__SWBuf_t_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_std__multimapT_sword__SWBuf_sword__SWBuf_t_t_t_t, (void *) &SwigClassPySectionMap);
  rb_include_module(SwigClassPySectionMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassPySectionMap.klass, _wrap_PySectionMap_allocate);
  rb_define_method(SwigClassPySectionMap.klass, "initialize", VALUEFUNC(_wrap_new_PySectionMap), -1);
  rb_define_method(SwigClassPySectionMap.klass, "dup", VALUEFUNC(_wrap_PySectionMap_dup), -1);
  rb_define_method(SwigClassPySectionMap.klass, "delete", VALUEFUNC(_wrap_PySectionMap_delete), -1);
  rb_define_method(SwigClassPySectionMap.klass, "has_key?", VALUEFUNC(_wrap_PySectionMap_has_keyq___), -1);
  rb_define_method(SwigClassPySectionMap.klass, "keys", VALUEFUNC(_wrap_PySectionMap_keys), -1);
  rb_define_method(SwigClassPySectionMap.klass, "each", VALUEFUNC(_wrap_PySectionMap_each), -1);
  rb_define_method(SwigClassPySectionMap.klass, "select", VALUEFUNC(_wrap_PySectionMap_select), -1);
  rb_define_method(SwigClassPySectionMap.klass, "values_at", VALUEFUNC(_wrap_PySectionMap_values_at), -1);
  rb_define_method(SwigClassPySectionMap.klass, "each_key", VALUEFUNC(_wrap_PySectionMap_each_key), -1);
  rb_define_method(SwigClassPySectionMap.klass, "values", VALUEFUNC(_wrap_PySectionMap_values), -1);
  rb_define_method(SwigClassPySectionMap.klass, "each_value", VALUEFUNC(_wrap_PySectionMap_each_value), -1);
  rb_define_method(SwigClassPySectionMap.klass, "entries", VALUEFUNC(_wrap_PySectionMap_entries), -1);
  rb_define_method(SwigClassPySectionMap.klass, "include?", VALUEFUNC(_wrap_PySectionMap_includeq___), -1);
  rb_define_method(SwigClassPySectionMap.klass, "key_iterator", VALUEFUNC(_wrap_PySectionMap_key_iterator), -1);
  rb_define_method(SwigClassPySectionMap.klass, "value_iterator", VALUEFUNC(_wrap_PySectionMap_value_iterator), -1);
  rb_define_method(SwigClassPySectionMap.klass, "[]", VALUEFUNC(_wrap_PySectionMap___getitem__), -1);
  rb_define_method(SwigClassPySectionMap.klass, "[]=", VALUEFUNC(_wrap_PySectionMap___setitem__), -1);
  rb_define_method(SwigClassPySectionMap.klass, "inspect", VALUEFUNC(_wrap_PySectionMap_inspect), -1);
  rb_define_method(SwigClassPySectionMap.klass, "to_a", VALUEFUNC(_wrap_PySectionMap_to_a), -1);
  rb_define_method(SwigClassPySectionMap.klass, "to_s", VALUEFUNC(_wrap_PySectionMap_to_s), -1);
  rb_define_method(SwigClassPySectionMap.klass, "empty?", VALUEFUNC(_wrap_PySectionMap_emptyq___), -1);
  rb_define_method(SwigClassPySectionMap.klass, "size", VALUEFUNC(_wrap_PySectionMap_size), -1);
  rb_define_method(SwigClassPySectionMap.klass, "clear", VALUEFUNC(_wrap_PySectionMap_clear), -1);
  rb_define_method(SwigClassPySectionMap.klass, "swap", VALUEFUNC(_wrap_PySectionMap_swap), -1);
  rb_define_method(SwigClassPySectionMap.klass, "get_allocator", VALUEFUNC(_wrap_PySectionMap_get_allocator), -1);
  rb_define_method(SwigClassPySectionMap.klass, "begin", VALUEFUNC(_wrap_PySectionMap_begin), -1);
  rb_define_method(SwigClassPySectionMap.klass, "end", VALUEFUNC(_wrap_PySectionMap_end), -1);
  rb_define_method(SwigClassPySectionMap.klass, "rbegin", VALUEFUNC(_wrap_PySectionMap_rbegin), -1);
  rb_define_method(SwigClassPySectionMap.klass, "rend", VALUEFUNC(_wrap_PySectionMap_rend), -1);
  rb_define_method(SwigClassPySectionMap.klass, "count", VALUEFUNC(_wrap_PySectionMap_count), -1);
  rb_define_method(SwigClassPySectionMap.klass, "erase", VALUEFUNC(_wrap_PySectionMap_erase), -1);
  rb_define_method(SwigClassPySectionMap.klass, "find", VALUEFUNC(_wrap_PySectionMap_find), -1);
  rb_define_method(SwigClassPySectionMap.klass, "lower_bound", VALUEFUNC(_wrap_PySectionMap_lower_bound), -1);
  rb_define_method(SwigClassPySectionMap.klass, "upper_bound", VALUEFUNC(_wrap_PySectionMap_upper_bound), -1);
  SwigClassPySectionMap.mark = 0;
  SwigClassPySectionMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_std_multimap_Sl_sword_SWBuf_Sc_sword_SWBuf_Sg__Sg_;
  SwigClassPySectionMap.trackObjects = 0;
  
  SwigClassModuleMap.klass = rb_define_class_under(mSword, "ModuleMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_sword__SWModule_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__SWModule_p_t_t_t, (void *) &SwigClassModuleMap);
  rb_include_module(SwigClassModuleMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassModuleMap.klass, _wrap_ModuleMap_allocate);
  rb_define_method(SwigClassModuleMap.klass, "initialize", VALUEFUNC(_wrap_new_ModuleMap), -1);
  rb_define_method(SwigClassModuleMap.klass, "dup", VALUEFUNC(_wrap_ModuleMap_dup), -1);
  rb_define_method(SwigClassModuleMap.klass, "delete", VALUEFUNC(_wrap_ModuleMap_delete), -1);
  rb_define_method(SwigClassModuleMap.klass, "has_key?", VALUEFUNC(_wrap_ModuleMap_has_keyq___), -1);
  rb_define_method(SwigClassModuleMap.klass, "keys", VALUEFUNC(_wrap_ModuleMap_keys), -1);
  rb_define_method(SwigClassModuleMap.klass, "each", VALUEFUNC(_wrap_ModuleMap_each), -1);
  rb_define_method(SwigClassModuleMap.klass, "select", VALUEFUNC(_wrap_ModuleMap_select), -1);
  rb_define_method(SwigClassModuleMap.klass, "values_at", VALUEFUNC(_wrap_ModuleMap_values_at), -1);
  rb_define_method(SwigClassModuleMap.klass, "each_key", VALUEFUNC(_wrap_ModuleMap_each_key), -1);
  rb_define_method(SwigClassModuleMap.klass, "values", VALUEFUNC(_wrap_ModuleMap_values), -1);
  rb_define_method(SwigClassModuleMap.klass, "each_value", VALUEFUNC(_wrap_ModuleMap_each_value), -1);
  rb_define_method(SwigClassModuleMap.klass, "entries", VALUEFUNC(_wrap_ModuleMap_entries), -1);
  rb_define_method(SwigClassModuleMap.klass, "include?", VALUEFUNC(_wrap_ModuleMap_includeq___), -1);
  rb_define_method(SwigClassModuleMap.klass, "key_iterator", VALUEFUNC(_wrap_ModuleMap_key_iterator), -1);
  rb_define_method(SwigClassModuleMap.klass, "value_iterator", VALUEFUNC(_wrap_ModuleMap_value_iterator), -1);
  rb_define_method(SwigClassModuleMap.klass, "[]", VALUEFUNC(_wrap_ModuleMap___getitem__), -1);
  rb_define_method(SwigClassModuleMap.klass, "[]=", VALUEFUNC(_wrap_ModuleMap___setitem__), -1);
  rb_define_method(SwigClassModuleMap.klass, "inspect", VALUEFUNC(_wrap_ModuleMap_inspect), -1);
  rb_define_method(SwigClassModuleMap.klass, "to_a", VALUEFUNC(_wrap_ModuleMap_to_a), -1);
  rb_define_method(SwigClassModuleMap.klass, "to_s", VALUEFUNC(_wrap_ModuleMap_to_s), -1);
  rb_define_method(SwigClassModuleMap.klass, "empty?", VALUEFUNC(_wrap_ModuleMap_emptyq___), -1);
  rb_define_method(SwigClassModuleMap.klass, "size", VALUEFUNC(_wrap_ModuleMap_size), -1);
  rb_define_method(SwigClassModuleMap.klass, "clear", VALUEFUNC(_wrap_ModuleMap_clear), -1);
  rb_define_method(SwigClassModuleMap.klass, "swap", VALUEFUNC(_wrap_ModuleMap_swap), -1);
  rb_define_method(SwigClassModuleMap.klass, "get_allocator", VALUEFUNC(_wrap_ModuleMap_get_allocator), -1);
  rb_define_method(SwigClassModuleMap.klass, "begin", VALUEFUNC(_wrap_ModuleMap_begin), -1);
  rb_define_method(SwigClassModuleMap.klass, "end", VALUEFUNC(_wrap_ModuleMap_end), -1);
  rb_define_method(SwigClassModuleMap.klass, "rbegin", VALUEFUNC(_wrap_ModuleMap_rbegin), -1);
  rb_define_method(SwigClassModuleMap.klass, "rend", VALUEFUNC(_wrap_ModuleMap_rend), -1);
  rb_define_method(SwigClassModuleMap.klass, "count", VALUEFUNC(_wrap_ModuleMap_count), -1);
  rb_define_method(SwigClassModuleMap.klass, "erase", VALUEFUNC(_wrap_ModuleMap_erase), -1);
  rb_define_method(SwigClassModuleMap.klass, "find", VALUEFUNC(_wrap_ModuleMap_find), -1);
  rb_define_method(SwigClassModuleMap.klass, "lower_bound", VALUEFUNC(_wrap_ModuleMap_lower_bound), -1);
  rb_define_method(SwigClassModuleMap.klass, "upper_bound", VALUEFUNC(_wrap_ModuleMap_upper_bound), -1);
  SwigClassModuleMap.mark = 0;
  SwigClassModuleMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_sword_SWModule_Sm__Sg_;
  SwigClassModuleMap.trackObjects = 0;
  
  SwigClassStringVector.klass = rb_define_class_under(mSword, "StringVector", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, (void *) &SwigClassStringVector);
  rb_include_module(SwigClassStringVector.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassStringVector.klass, _wrap_StringVector_allocate);
  rb_define_method(SwigClassStringVector.klass, "initialize", VALUEFUNC(_wrap_new_StringVector), -1);
  rb_define_method(SwigClassStringVector.klass, "dup", VALUEFUNC(_wrap_StringVector_dup), -1);
  rb_define_method(SwigClassStringVector.klass, "inspect", VALUEFUNC(_wrap_StringVector_inspect), -1);
  rb_define_method(SwigClassStringVector.klass, "to_a", VALUEFUNC(_wrap_StringVector_to_a), -1);
  rb_define_method(SwigClassStringVector.klass, "to_s", VALUEFUNC(_wrap_StringVector_to_s), -1);
  rb_define_method(SwigClassStringVector.klass, "slice", VALUEFUNC(_wrap_StringVector_slice), -1);
  rb_define_method(SwigClassStringVector.klass, "each", VALUEFUNC(_wrap_StringVector_each), -1);
  rb_define_method(SwigClassStringVector.klass, "select", VALUEFUNC(_wrap_StringVector_select), -1);
  rb_define_method(SwigClassStringVector.klass, "reject!", VALUEFUNC(_wrap_StringVector_rejectN___), -1);
  rb_define_alias(SwigClassStringVector.klass, "delete_if", "reject!");
  rb_define_method(SwigClassStringVector.klass, "delete_at", VALUEFUNC(_wrap_StringVector_delete_at), -1);
  rb_define_method(SwigClassStringVector.klass, "__delete2__", VALUEFUNC(_wrap_StringVector___delete2__), -1);
  rb_define_method(SwigClassStringVector.klass, "pop", VALUEFUNC(_wrap_StringVector_pop), -1);
  rb_define_method(SwigClassStringVector.klass, "push", VALUEFUNC(_wrap_StringVector_push), -1);
  rb_define_alias(SwigClassStringVector.klass, "<<", "push");
  rb_define_method(SwigClassStringVector.klass, "reject", VALUEFUNC(_wrap_StringVector_reject), -1);
  rb_define_method(SwigClassStringVector.klass, "at", VALUEFUNC(_wrap_StringVector_at), -1);
  rb_define_method(SwigClassStringVector.klass, "[]", VALUEFUNC(_wrap_StringVector___getitem__), -1);
  rb_define_method(SwigClassStringVector.klass, "[]=", VALUEFUNC(_wrap_StringVector___setitem__), -1);
  rb_define_method(SwigClassStringVector.klass, "shift", VALUEFUNC(_wrap_StringVector_shift), -1);
  rb_define_method(SwigClassStringVector.klass, "unshift", VALUEFUNC(_wrap_StringVector_unshift), -1);
  rb_define_method(SwigClassStringVector.klass, "empty?", VALUEFUNC(_wrap_StringVector_emptyq___), -1);
  rb_define_method(SwigClassStringVector.klass, "size", VALUEFUNC(_wrap_StringVector_size), -1);
  rb_define_method(SwigClassStringVector.klass, "clear", VALUEFUNC(_wrap_StringVector_clear), -1);
  rb_define_method(SwigClassStringVector.klass, "swap", VALUEFUNC(_wrap_StringVector_swap), -1);
  rb_define_method(SwigClassStringVector.klass, "get_allocator", VALUEFUNC(_wrap_StringVector_get_allocator), -1);
  rb_define_method(SwigClassStringVector.klass, "begin", VALUEFUNC(_wrap_StringVector_begin), -1);
  rb_define_method(SwigClassStringVector.klass, "end", VALUEFUNC(_wrap_StringVector_end), -1);
  rb_define_method(SwigClassStringVector.klass, "rbegin", VALUEFUNC(_wrap_StringVector_rbegin), -1);
  rb_define_method(SwigClassStringVector.klass, "rend", VALUEFUNC(_wrap_StringVector_rend), -1);
  rb_define_method(SwigClassStringVector.klass, "erase", VALUEFUNC(_wrap_StringVector_erase), -1);
  rb_define_method(SwigClassStringVector.klass, "front", VALUEFUNC(_wrap_StringVector_front), -1);
  rb_define_method(SwigClassStringVector.klass, "back", VALUEFUNC(_wrap_StringVector_back), -1);
  rb_define_method(SwigClassStringVector.klass, "assign", VALUEFUNC(_wrap_StringVector_assign), -1);
  rb_define_method(SwigClassStringVector.klass, "resize", VALUEFUNC(_wrap_StringVector_resize), -1);
  rb_define_method(SwigClassStringVector.klass, "insert", VALUEFUNC(_wrap_StringVector_insert), -1);
  rb_define_method(SwigClassStringVector.klass, "reserve", VALUEFUNC(_wrap_StringVector_reserve), -1);
  rb_define_method(SwigClassStringVector.klass, "capacity", VALUEFUNC(_wrap_StringVector_capacity), -1);
  SwigClassStringVector.mark = 0;
  SwigClassStringVector.destroy = (void (*)(void *)) free_std_vector_Sl_sword_SWBuf_Sg_;
  SwigClassStringVector.trackObjects = 0;
  
  SwigClassStringList.klass = rb_define_class_under(mSword, "StringList", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__listT_sword__SWBuf_std__allocatorT_sword__SWBuf_t_t, (void *) &SwigClassStringList);
  rb_define_alloc_func(SwigClassStringList.klass, _wrap_StringList_allocate);
  rb_define_method(SwigClassStringList.klass, "initialize", VALUEFUNC(_wrap_new_StringList), -1);
  rb_define_method(SwigClassStringList.klass, "dup", VALUEFUNC(_wrap_StringList_dup), -1);
  rb_define_method(SwigClassStringList.klass, "inspect", VALUEFUNC(_wrap_StringList_inspect), -1);
  rb_define_method(SwigClassStringList.klass, "to_a", VALUEFUNC(_wrap_StringList_to_a), -1);
  rb_define_method(SwigClassStringList.klass, "to_s", VALUEFUNC(_wrap_StringList_to_s), -1);
  rb_define_method(SwigClassStringList.klass, "slice", VALUEFUNC(_wrap_StringList_slice), -1);
  rb_define_method(SwigClassStringList.klass, "each", VALUEFUNC(_wrap_StringList_each), -1);
  rb_define_method(SwigClassStringList.klass, "select", VALUEFUNC(_wrap_StringList_select), -1);
  rb_define_method(SwigClassStringList.klass, "reject!", VALUEFUNC(_wrap_StringList_rejectN___), -1);
  rb_define_alias(SwigClassStringList.klass, "delete_if", "reject!");
  rb_define_method(SwigClassStringList.klass, "delete_at", VALUEFUNC(_wrap_StringList_delete_at), -1);
  rb_define_method(SwigClassStringList.klass, "__delete2__", VALUEFUNC(_wrap_StringList___delete2__), -1);
  rb_define_method(SwigClassStringList.klass, "pop", VALUEFUNC(_wrap_StringList_pop), -1);
  rb_define_method(SwigClassStringList.klass, "push", VALUEFUNC(_wrap_StringList_push), -1);
  rb_define_alias(SwigClassStringList.klass, "<<", "push");
  rb_define_method(SwigClassStringList.klass, "reject", VALUEFUNC(_wrap_StringList_reject), -1);
  rb_define_method(SwigClassStringList.klass, "at", VALUEFUNC(_wrap_StringList_at), -1);
  rb_define_method(SwigClassStringList.klass, "[]", VALUEFUNC(_wrap_StringList___getitem__), -1);
  rb_define_method(SwigClassStringList.klass, "[]=", VALUEFUNC(_wrap_StringList___setitem__), -1);
  rb_define_method(SwigClassStringList.klass, "empty?", VALUEFUNC(_wrap_StringList_emptyq___), -1);
  rb_define_method(SwigClassStringList.klass, "size", VALUEFUNC(_wrap_StringList_size), -1);
  rb_define_method(SwigClassStringList.klass, "clear", VALUEFUNC(_wrap_StringList_clear), -1);
  rb_define_method(SwigClassStringList.klass, "swap", VALUEFUNC(_wrap_StringList_swap), -1);
  rb_define_method(SwigClassStringList.klass, "get_allocator", VALUEFUNC(_wrap_StringList_get_allocator), -1);
  rb_define_method(SwigClassStringList.klass, "begin", VALUEFUNC(_wrap_StringList_begin), -1);
  rb_define_method(SwigClassStringList.klass, "end", VALUEFUNC(_wrap_StringList_end), -1);
  rb_define_method(SwigClassStringList.klass, "rbegin", VALUEFUNC(_wrap_StringList_rbegin), -1);
  rb_define_method(SwigClassStringList.klass, "rend", VALUEFUNC(_wrap_StringList_rend), -1);
  rb_define_method(SwigClassStringList.klass, "erase", VALUEFUNC(_wrap_StringList_erase), -1);
  rb_define_method(SwigClassStringList.klass, "front", VALUEFUNC(_wrap_StringList_front), -1);
  rb_define_method(SwigClassStringList.klass, "back", VALUEFUNC(_wrap_StringList_back), -1);
  rb_define_method(SwigClassStringList.klass, "assign", VALUEFUNC(_wrap_StringList_assign), -1);
  rb_define_method(SwigClassStringList.klass, "resize", VALUEFUNC(_wrap_StringList_resize), -1);
  rb_define_method(SwigClassStringList.klass, "insert", VALUEFUNC(_wrap_StringList_insert), -1);
  rb_define_method(SwigClassStringList.klass, "pop_front", VALUEFUNC(_wrap_StringList_pop_front), -1);
  rb_define_method(SwigClassStringList.klass, "push_front", VALUEFUNC(_wrap_StringList_push_front), -1);
  rb_define_method(SwigClassStringList.klass, "reverse", VALUEFUNC(_wrap_StringList_reverse), -1);
  SwigClassStringList.mark = 0;
  SwigClassStringList.destroy = (void (*)(void *)) free_std_list_Sl_sword_SWBuf_Sg_;
  SwigClassStringList.trackObjects = 0;
  
  SwigClassInstallSourceMap.klass = rb_define_class_under(mSword, "InstallSourceMap", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__mapT_sword__SWBuf_sword__InstallSource_p_std__lessT_sword__SWBuf_t_std__allocatorT_std__pairT_sword__SWBuf_const_sword__InstallSource_p_t_t_t, (void *) &SwigClassInstallSourceMap);
  rb_include_module(SwigClassInstallSourceMap.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassInstallSourceMap.klass, _wrap_InstallSourceMap_allocate);
  rb_define_method(SwigClassInstallSourceMap.klass, "initialize", VALUEFUNC(_wrap_new_InstallSourceMap), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "dup", VALUEFUNC(_wrap_InstallSourceMap_dup), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "delete", VALUEFUNC(_wrap_InstallSourceMap_delete), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "has_key?", VALUEFUNC(_wrap_InstallSourceMap_has_keyq___), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "keys", VALUEFUNC(_wrap_InstallSourceMap_keys), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "each", VALUEFUNC(_wrap_InstallSourceMap_each), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "select", VALUEFUNC(_wrap_InstallSourceMap_select), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "values_at", VALUEFUNC(_wrap_InstallSourceMap_values_at), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "each_key", VALUEFUNC(_wrap_InstallSourceMap_each_key), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "values", VALUEFUNC(_wrap_InstallSourceMap_values), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "each_value", VALUEFUNC(_wrap_InstallSourceMap_each_value), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "entries", VALUEFUNC(_wrap_InstallSourceMap_entries), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "include?", VALUEFUNC(_wrap_InstallSourceMap_includeq___), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "key_iterator", VALUEFUNC(_wrap_InstallSourceMap_key_iterator), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "value_iterator", VALUEFUNC(_wrap_InstallSourceMap_value_iterator), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "[]", VALUEFUNC(_wrap_InstallSourceMap___getitem__), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "[]=", VALUEFUNC(_wrap_InstallSourceMap___setitem__), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "inspect", VALUEFUNC(_wrap_InstallSourceMap_inspect), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "to_a", VALUEFUNC(_wrap_InstallSourceMap_to_a), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "to_s", VALUEFUNC(_wrap_InstallSourceMap_to_s), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "empty?", VALUEFUNC(_wrap_InstallSourceMap_emptyq___), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "size", VALUEFUNC(_wrap_InstallSourceMap_size), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "clear", VALUEFUNC(_wrap_InstallSourceMap_clear), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "swap", VALUEFUNC(_wrap_InstallSourceMap_swap), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "get_allocator", VALUEFUNC(_wrap_InstallSourceMap_get_allocator), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "begin", VALUEFUNC(_wrap_InstallSourceMap_begin), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "end", VALUEFUNC(_wrap_InstallSourceMap_end), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "rbegin", VALUEFUNC(_wrap_InstallSourceMap_rbegin), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "rend", VALUEFUNC(_wrap_InstallSourceMap_rend), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "count", VALUEFUNC(_wrap_InstallSourceMap_count), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "erase", VALUEFUNC(_wrap_InstallSourceMap_erase), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "find", VALUEFUNC(_wrap_InstallSourceMap_find), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "lower_bound", VALUEFUNC(_wrap_InstallSourceMap_lower_bound), -1);
  rb_define_method(SwigClassInstallSourceMap.klass, "upper_bound", VALUEFUNC(_wrap_InstallSourceMap_upper_bound), -1);
  SwigClassInstallSourceMap.mark = 0;
  SwigClassInstallSourceMap.destroy = (void (*)(void *)) free_std_map_Sl_sword_SWBuf_Sc_sword_InstallSource_Sm__Sg_;
  SwigClassInstallSourceMap.trackObjects = 0;
  
  SwigClassDirEntryVector.klass = rb_define_class_under(mSword, "DirEntryVector", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_sword__DirEntry_std__allocatorT_sword__DirEntry_t_t, (void *) &SwigClassDirEntryVector);
  rb_include_module(SwigClassDirEntryVector.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassDirEntryVector.klass, _wrap_DirEntryVector_allocate);
  rb_define_method(SwigClassDirEntryVector.klass, "initialize", VALUEFUNC(_wrap_new_DirEntryVector), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "dup", VALUEFUNC(_wrap_DirEntryVector_dup), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "inspect", VALUEFUNC(_wrap_DirEntryVector_inspect), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "to_a", VALUEFUNC(_wrap_DirEntryVector_to_a), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "to_s", VALUEFUNC(_wrap_DirEntryVector_to_s), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "slice", VALUEFUNC(_wrap_DirEntryVector_slice), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "each", VALUEFUNC(_wrap_DirEntryVector_each), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "select", VALUEFUNC(_wrap_DirEntryVector_select), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "reject!", VALUEFUNC(_wrap_DirEntryVector_rejectN___), -1);
  rb_define_alias(SwigClassDirEntryVector.klass, "delete_if", "reject!");
  rb_define_method(SwigClassDirEntryVector.klass, "delete_at", VALUEFUNC(_wrap_DirEntryVector_delete_at), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "__delete2__", VALUEFUNC(_wrap_DirEntryVector___delete2__), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "pop", VALUEFUNC(_wrap_DirEntryVector_pop), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "push", VALUEFUNC(_wrap_DirEntryVector_push), -1);
  rb_define_alias(SwigClassDirEntryVector.klass, "<<", "push");
  rb_define_method(SwigClassDirEntryVector.klass, "reject", VALUEFUNC(_wrap_DirEntryVector_reject), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "at", VALUEFUNC(_wrap_DirEntryVector_at), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "[]", VALUEFUNC(_wrap_DirEntryVector___getitem__), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "[]=", VALUEFUNC(_wrap_DirEntryVector___setitem__), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "shift", VALUEFUNC(_wrap_DirEntryVector_shift), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "unshift", VALUEFUNC(_wrap_DirEntryVector_unshift), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "empty?", VALUEFUNC(_wrap_DirEntryVector_emptyq___), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "size", VALUEFUNC(_wrap_DirEntryVector_size), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "clear", VALUEFUNC(_wrap_DirEntryVector_clear), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "swap", VALUEFUNC(_wrap_DirEntryVector_swap), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "get_allocator", VALUEFUNC(_wrap_DirEntryVector_get_allocator), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "begin", VALUEFUNC(_wrap_DirEntryVector_begin), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "end", VALUEFUNC(_wrap_DirEntryVector_end), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "rbegin", VALUEFUNC(_wrap_DirEntryVector_rbegin), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "rend", VALUEFUNC(_wrap_DirEntryVector_rend), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "erase", VALUEFUNC(_wrap_DirEntryVector_erase), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "front", VALUEFUNC(_wrap_DirEntryVector_front), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "back", VALUEFUNC(_wrap_DirEntryVector_back), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "assign", VALUEFUNC(_wrap_DirEntryVector_assign), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "resize", VALUEFUNC(_wrap_DirEntryVector_resize), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "insert", VALUEFUNC(_wrap_DirEntryVector_insert), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "reserve", VALUEFUNC(_wrap_DirEntryVector_reserve), -1);
  rb_define_method(SwigClassDirEntryVector.klass, "capacity", VALUEFUNC(_wrap_DirEntryVector_capacity), -1);
  SwigClassDirEntryVector.mark = 0;
  SwigClassDirEntryVector.destroy = (void (*)(void *)) free_std_vector_Sl_sword_DirEntry_Sg_;
  SwigClassDirEntryVector.trackObjects = 0;
  
  SwigClassSWClass.klass = rb_define_class_under(mSword, "SWClass", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWClass, (void *) &SwigClassSWClass);
  rb_undef_alloc_func(SwigClassSWClass.klass);
  rb_define_method(SwigClassSWClass.klass, "isAssignableFrom", VALUEFUNC(_wrap_SWClass_isAssignableFrom), -1);
  SwigClassSWClass.mark = 0;
  SwigClassSWClass.destroy = (void (*)(void *)) free_sword_SWClass;
  SwigClassSWClass.trackObjects = 0;
  
  SwigClassSWObject.klass = rb_define_class_under(mSword, "SWObject", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWObject, (void *) &SwigClassSWObject);
  rb_define_alloc_func(SwigClassSWObject.klass, _wrap_SWObject_allocate);
  rb_define_method(SwigClassSWObject.klass, "initialize", VALUEFUNC(_wrap_new_SWObject), -1);
  rb_define_method(SwigClassSWObject.klass, "getClass", VALUEFUNC(_wrap_SWObject_getClass), -1);
  SwigClassSWObject.mark = 0;
  SwigClassSWObject.destroy = (void (*)(void *)) free_sword_SWObject;
  SwigClassSWObject.trackObjects = 0;
  
  SwigClassSWConfig.klass = rb_define_class_under(mSword, "SWConfig", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWConfig, (void *) &SwigClassSWConfig);
  rb_define_alloc_func(SwigClassSWConfig.klass, _wrap_SWConfig_allocate);
  rb_define_method(SwigClassSWConfig.klass, "initialize", VALUEFUNC(_wrap_new_SWConfig), -1);
  rb_define_method(SwigClassSWConfig.klass, "filename=", VALUEFUNC(_wrap_SWConfig_filename_set), -1);
  rb_define_method(SwigClassSWConfig.klass, "filename", VALUEFUNC(_wrap_SWConfig_filename_get), -1);
  rb_define_method(SwigClassSWConfig.klass, "Load", VALUEFUNC(_wrap_SWConfig_Load), -1);
  rb_define_method(SwigClassSWConfig.klass, "Save", VALUEFUNC(_wrap_SWConfig_Save), -1);
  rb_define_method(SwigClassSWConfig.klass, "augment", VALUEFUNC(_wrap_SWConfig_augment), -1);
  rb_define_method(SwigClassSWConfig.klass, "set", VALUEFUNC(_wrap_SWConfig_set), -1);
  rb_define_method(SwigClassSWConfig.klass, "get", VALUEFUNC(_wrap_SWConfig_get), -1);
  rb_define_method(SwigClassSWConfig.klass, "getSections", VALUEFUNC(_wrap_SWConfig_getSections), -1);
  SwigClassSWConfig.mark = 0;
  SwigClassSWConfig.destroy = (void (*)(void *)) free_sword_SWConfig;
  SwigClassSWConfig.trackObjects = 0;
  
  SwigClassSWVersion.klass = rb_define_class_under(mSword, "SWVersion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWVersion, (void *) &SwigClassSWVersion);
  rb_define_alloc_func(SwigClassSWVersion.klass, _wrap_SWVersion_allocate);
  rb_define_method(SwigClassSWVersion.klass, "initialize", VALUEFUNC(_wrap_new_SWVersion), -1);
  rb_define_method(SwigClassSWVersion.klass, "major=", VALUEFUNC(_wrap_SWVersion_major_set), -1);
  rb_define_method(SwigClassSWVersion.klass, "major", VALUEFUNC(_wrap_SWVersion_major_get), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor=", VALUEFUNC(_wrap_SWVersion_minor_set), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor", VALUEFUNC(_wrap_SWVersion_minor_get), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor2=", VALUEFUNC(_wrap_SWVersion_minor2_set), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor2", VALUEFUNC(_wrap_SWVersion_minor2_get), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor3=", VALUEFUNC(_wrap_SWVersion_minor3_set), -1);
  rb_define_method(SwigClassSWVersion.klass, "minor3", VALUEFUNC(_wrap_SWVersion_minor3_get), -1);
  rb_define_method(SwigClassSWVersion.klass, "compare", VALUEFUNC(_wrap_SWVersion_compare), -1);
  rb_define_method(SwigClassSWVersion.klass, "getText", VALUEFUNC(_wrap_SWVersion_getText), -1);
  rb_define_method(SwigClassSWVersion.klass, ">", VALUEFUNC(_wrap_SWVersion___gt__), -1);
  rb_define_method(SwigClassSWVersion.klass, "<", VALUEFUNC(_wrap_SWVersion___lt__), -1);
  rb_define_method(SwigClassSWVersion.klass, ">=", VALUEFUNC(_wrap_SWVersion___ge__), -1);
  rb_define_method(SwigClassSWVersion.klass, "<=", VALUEFUNC(_wrap_SWVersion___le__), -1);
  rb_define_method(SwigClassSWVersion.klass, "==", VALUEFUNC(_wrap_SWVersion___eq__), -1);
  rb_define_singleton_method(SwigClassSWVersion.klass, "currentVersion", VALUEFUNC(_wrap_SWVersion_currentVersion_get), 0);
  rb_define_singleton_method(SwigClassSWVersion.klass, "currentVersion=", VALUEFUNC(_wrap_SWVersion_currentVersion_set), 1);
  SwigClassSWVersion.mark = 0;
  SwigClassSWVersion.destroy = (void (*)(void *)) free_sword_SWVersion;
  SwigClassSWVersion.trackObjects = 0;
  
  SwigClassRawVerse.klass = rb_define_class_under(mSword, "RawVerse", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawVerse, (void *) &SwigClassRawVerse);
  rb_define_alloc_func(SwigClassRawVerse.klass, _wrap_RawVerse_allocate);
  rb_define_method(SwigClassRawVerse.klass, "initialize", VALUEFUNC(_wrap_new_RawVerse), -1);
  rb_define_singleton_method(SwigClassRawVerse.klass, "nl", VALUEFUNC(_wrap_RawVerse_nl_get), 0);
  rb_define_method(SwigClassRawVerse.klass, "findOffset", VALUEFUNC(_wrap_RawVerse_findOffset), -1);
  rb_define_method(SwigClassRawVerse.klass, "readText", VALUEFUNC(_wrap_RawVerse_readText), -1);
  rb_define_singleton_method(SwigClassRawVerse.klass, "createModule", VALUEFUNC(_wrap_RawVerse_createModule), -1);
  SwigClassRawVerse.mark = 0;
  SwigClassRawVerse.destroy = (void (*)(void *)) free_sword_RawVerse;
  SwigClassRawVerse.trackObjects = 0;
  rb_define_const(mSword, "VERSEBLOCKS", SWIG_From_int(static_cast< int >(2)));
  rb_define_const(mSword, "CHAPTERBLOCKS", SWIG_From_int(static_cast< int >(3)));
  rb_define_const(mSword, "BOOKBLOCKS", SWIG_From_int(static_cast< int >(4)));
  
  SwigClassZVerse.klass = rb_define_class_under(mSword, "ZVerse", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__zVerse, (void *) &SwigClassZVerse);
  rb_define_alloc_func(SwigClassZVerse.klass, _wrap_zVerse_allocate);
  rb_define_method(SwigClassZVerse.klass, "initialize", VALUEFUNC(_wrap_new_zVerse), -1);
  rb_define_singleton_method(SwigClassZVerse.klass, "uniqueIndexID", VALUEFUNC(_wrap_zVerse_uniqueIndexID_get), 0);
  rb_define_method(SwigClassZVerse.klass, "nl=", VALUEFUNC(_wrap_zVerse_nl_set), -1);
  rb_define_method(SwigClassZVerse.klass, "nl", VALUEFUNC(_wrap_zVerse_nl_get), -1);
  rb_define_method(SwigClassZVerse.klass, "findOffset", VALUEFUNC(_wrap_zVerse_findOffset), -1);
  rb_define_method(SwigClassZVerse.klass, "zReadText", VALUEFUNC(_wrap_zVerse_zReadText), -1);
  rb_define_method(SwigClassZVerse.klass, "rawZFilter", VALUEFUNC(_wrap_zVerse_rawZFilter), -1);
  rb_define_singleton_method(SwigClassZVerse.klass, "createModule", VALUEFUNC(_wrap_zVerse_createModule), -1);
  SwigClassZVerse.mark = 0;
  SwigClassZVerse.destroy = (void (*)(void *)) free_sword_zVerse;
  SwigClassZVerse.trackObjects = 0;
  
  SwigClassRawStr.klass = rb_define_class_under(mSword, "RawStr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawStr, (void *) &SwigClassRawStr);
  rb_define_alloc_func(SwigClassRawStr.klass, _wrap_RawStr_allocate);
  rb_define_method(SwigClassRawStr.klass, "initialize", VALUEFUNC(_wrap_new_RawStr), -1);
  rb_define_singleton_method(SwigClassRawStr.klass, "nl", VALUEFUNC(_wrap_RawStr_nl_get), 0);
  rb_define_singleton_method(SwigClassRawStr.klass, "nl=", VALUEFUNC(_wrap_RawStr_nl_set), 1);
  rb_define_method(SwigClassRawStr.klass, "getIDXBuf", VALUEFUNC(_wrap_RawStr_getIDXBuf), -1);
  rb_define_method(SwigClassRawStr.klass, "getIDXBufDat", VALUEFUNC(_wrap_RawStr_getIDXBufDat), -1);
  rb_define_method(SwigClassRawStr.klass, "findOffset", VALUEFUNC(_wrap_RawStr_findOffset), -1);
  rb_define_method(SwigClassRawStr.klass, "readText", VALUEFUNC(_wrap_RawStr_readText), -1);
  rb_define_singleton_method(SwigClassRawStr.klass, "createModule", VALUEFUNC(_wrap_RawStr_createModule), -1);
  SwigClassRawStr.mark = 0;
  SwigClassRawStr.destroy = (void (*)(void *)) free_sword_RawStr;
  SwigClassRawStr.trackObjects = 0;
  
  SwigClassRawStr4.klass = rb_define_class_under(mSword, "RawStr4", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawStr4, (void *) &SwigClassRawStr4);
  rb_define_alloc_func(SwigClassRawStr4.klass, _wrap_RawStr4_allocate);
  rb_define_method(SwigClassRawStr4.klass, "initialize", VALUEFUNC(_wrap_new_RawStr4), -1);
  rb_define_method(SwigClassRawStr4.klass, "nl=", VALUEFUNC(_wrap_RawStr4_nl_set), -1);
  rb_define_method(SwigClassRawStr4.klass, "nl", VALUEFUNC(_wrap_RawStr4_nl_get), -1);
  rb_define_method(SwigClassRawStr4.klass, "getIDXBuf", VALUEFUNC(_wrap_RawStr4_getIDXBuf), -1);
  rb_define_method(SwigClassRawStr4.klass, "getIDXBufDat", VALUEFUNC(_wrap_RawStr4_getIDXBufDat), -1);
  rb_define_method(SwigClassRawStr4.klass, "findOffset", VALUEFUNC(_wrap_RawStr4_findOffset), -1);
  rb_define_method(SwigClassRawStr4.klass, "readText", VALUEFUNC(_wrap_RawStr4_readText), -1);
  rb_define_singleton_method(SwigClassRawStr4.klass, "createModule", VALUEFUNC(_wrap_RawStr4_createModule), -1);
  SwigClassRawStr4.mark = 0;
  SwigClassRawStr4.destroy = (void (*)(void *)) free_sword_RawStr4;
  SwigClassRawStr4.trackObjects = 0;
  
  SwigClassZStr.klass = rb_define_class_under(mSword, "ZStr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__zStr, (void *) &SwigClassZStr);
  rb_define_alloc_func(SwigClassZStr.klass, _wrap_zStr_allocate);
  rb_define_method(SwigClassZStr.klass, "initialize", VALUEFUNC(_wrap_new_zStr), -1);
  rb_define_method(SwigClassZStr.klass, "nl=", VALUEFUNC(_wrap_zStr_nl_set), -1);
  rb_define_method(SwigClassZStr.klass, "nl", VALUEFUNC(_wrap_zStr_nl_get), -1);
  rb_define_method(SwigClassZStr.klass, "findKeyIndex", VALUEFUNC(_wrap_zStr_findKeyIndex), -1);
  rb_define_method(SwigClassZStr.klass, "getText", VALUEFUNC(_wrap_zStr_getText), -1);
  rb_define_method(SwigClassZStr.klass, "setText", VALUEFUNC(_wrap_zStr_setText), -1);
  rb_define_method(SwigClassZStr.klass, "linkEntry", VALUEFUNC(_wrap_zStr_linkEntry), -1);
  rb_define_method(SwigClassZStr.klass, "rawZFilter", VALUEFUNC(_wrap_zStr_rawZFilter), -1);
  rb_define_singleton_method(SwigClassZStr.klass, "createModule", VALUEFUNC(_wrap_zStr_createModule), -1);
  SwigClassZStr.mark = 0;
  SwigClassZStr.destroy = (void (*)(void *)) free_sword_zStr;
  SwigClassZStr.trackObjects = 0;
  rb_define_const(mSword, "KEYERR_OUTOFBOUNDS", SWIG_From_int(static_cast< int >(1)));
  
  SwigClassSW_POSITION.klass = rb_define_class_under(mSword, "SW_POSITION", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SW_POSITION, (void *) &SwigClassSW_POSITION);
  rb_define_alloc_func(SwigClassSW_POSITION.klass, _wrap_SW_POSITION_allocate);
  rb_define_method(SwigClassSW_POSITION.klass, "initialize", VALUEFUNC(_wrap_new_SW_POSITION), -1);
  rb_define_method(SwigClassSW_POSITION.klass, "getPosition", VALUEFUNC(_wrap_SW_POSITION_getPosition), -1);
  SwigClassSW_POSITION.mark = 0;
  SwigClassSW_POSITION.destroy = (void (*)(void *)) free_sword_SW_POSITION;
  SwigClassSW_POSITION.trackObjects = 0;
  
  SwigClassSWKey.klass = rb_define_class_under(mSword, "SWKey", ((swig_class *) SWIGTYPE_p_sword__SWObject->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWKey, (void *) &SwigClassSWKey);
  rb_define_alloc_func(SwigClassSWKey.klass, _wrap_SWKey_allocate);
  rb_define_method(SwigClassSWKey.klass, "initialize", VALUEFUNC(_wrap_new_SWKey), -1);
  rb_define_method(SwigClassSWKey.klass, "clone", VALUEFUNC(_wrap_SWKey_clone), -1);
  rb_define_method(SwigClassSWKey.klass, "Persist", VALUEFUNC(_wrap_SWKey_Persist), -1);
  rb_define_method(SwigClassSWKey.klass, "Error", VALUEFUNC(_wrap_SWKey_Error), -1);
  rb_define_method(SwigClassSWKey.klass, "setError", VALUEFUNC(_wrap_SWKey_setError), -1);
  rb_define_method(SwigClassSWKey.klass, "setText", VALUEFUNC(_wrap_SWKey_setText), -1);
  rb_define_method(SwigClassSWKey.klass, "copyFrom", VALUEFUNC(_wrap_SWKey_copyFrom), -1);
  rb_define_method(SwigClassSWKey.klass, "positionFrom", VALUEFUNC(_wrap_SWKey_positionFrom), -1);
  rb_define_method(SwigClassSWKey.klass, "getText", VALUEFUNC(_wrap_SWKey_getText), -1);
  rb_define_method(SwigClassSWKey.klass, "getShortText", VALUEFUNC(_wrap_SWKey_getShortText), -1);
  rb_define_method(SwigClassSWKey.klass, "getRangeText", VALUEFUNC(_wrap_SWKey_getRangeText), -1);
  rb_define_method(SwigClassSWKey.klass, "getOSISRefRangeText", VALUEFUNC(_wrap_SWKey_getOSISRefRangeText), -1);
  rb_define_method(SwigClassSWKey.klass, "isBoundSet", VALUEFUNC(_wrap_SWKey_isBoundSet), -1);
  rb_define_method(SwigClassSWKey.klass, "clearBound", VALUEFUNC(_wrap_SWKey_clearBound), -1);
  rb_define_method(SwigClassSWKey.klass, "compare", VALUEFUNC(_wrap_SWKey_compare), -1);
  rb_define_method(SwigClassSWKey.klass, "equals", VALUEFUNC(_wrap_SWKey_equals), -1);
  rb_define_method(SwigClassSWKey.klass, "setPosition", VALUEFUNC(_wrap_SWKey_setPosition), -1);
  rb_define_method(SwigClassSWKey.klass, "decrement", VALUEFUNC(_wrap_SWKey_decrement), -1);
  rb_define_method(SwigClassSWKey.klass, "increment", VALUEFUNC(_wrap_SWKey_increment), -1);
  rb_define_method(SwigClassSWKey.klass, "Traversable", VALUEFUNC(_wrap_SWKey_Traversable), -1);
  rb_define_method(SwigClassSWKey.klass, "isTraversable", VALUEFUNC(_wrap_SWKey_isTraversable), -1);
  rb_define_method(SwigClassSWKey.klass, "getLocale", VALUEFUNC(_wrap_SWKey_getLocale), -1);
  rb_define_method(SwigClassSWKey.klass, "setLocale", VALUEFUNC(_wrap_SWKey_setLocale), -1);
  rb_define_method(SwigClassSWKey.klass, "getIndex", VALUEFUNC(_wrap_SWKey_getIndex), -1);
  rb_define_method(SwigClassSWKey.klass, "setIndex", VALUEFUNC(_wrap_SWKey_setIndex), -1);
  rb_define_method(SwigClassSWKey.klass, "Index", VALUEFUNC(_wrap_SWKey_Index), -1);
  rb_define_method(SwigClassSWKey.klass, "==", VALUEFUNC(_wrap_SWKey___eq__), -1);
  rb_define_method(SwigClassSWKey.klass, ">", VALUEFUNC(_wrap_SWKey___gt__), -1);
  rb_define_method(SwigClassSWKey.klass, "<", VALUEFUNC(_wrap_SWKey___lt__), -1);
  rb_define_method(SwigClassSWKey.klass, ">=", VALUEFUNC(_wrap_SWKey___ge__), -1);
  rb_define_method(SwigClassSWKey.klass, "<=", VALUEFUNC(_wrap_SWKey___le__), -1);
  SwigClassSWKey.mark = 0;
  SwigClassSWKey.destroy = (void (*)(void *)) free_sword_SWKey;
  SwigClassSWKey.trackObjects = 0;
  
  SwigClassListKey.klass = rb_define_class_under(mSword, "ListKey", ((swig_class *) SWIGTYPE_p_sword__SWKey->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__ListKey, (void *) &SwigClassListKey);
  rb_define_alloc_func(SwigClassListKey.klass, _wrap_ListKey_allocate);
  rb_define_method(SwigClassListKey.klass, "initialize", VALUEFUNC(_wrap_new_ListKey), -1);
  rb_define_method(SwigClassListKey.klass, "clone", VALUEFUNC(_wrap_ListKey_clone), -1);
  rb_define_method(SwigClassListKey.klass, "clear", VALUEFUNC(_wrap_ListKey_clear), -1);
  rb_define_method(SwigClassListKey.klass, "ClearList", VALUEFUNC(_wrap_ListKey_ClearList), -1);
  rb_define_method(SwigClassListKey.klass, "Count", VALUEFUNC(_wrap_ListKey_Count), -1);
  rb_define_method(SwigClassListKey.klass, "Remove", VALUEFUNC(_wrap_ListKey_Remove), -1);
  rb_define_method(SwigClassListKey.klass, "SetToElement", VALUEFUNC(_wrap_ListKey_SetToElement), -1);
  rb_define_method(SwigClassListKey.klass, "getElement", VALUEFUNC(_wrap_ListKey_getElement), -1);
  rb_define_method(SwigClassListKey.klass, "GetElement", VALUEFUNC(_wrap_ListKey_GetElement), -1);
  rb_define_method(SwigClassListKey.klass, "add", VALUEFUNC(_wrap_ListKey_add), -1);
  rb_define_method(SwigClassListKey.klass, "copyFrom", VALUEFUNC(_wrap_ListKey_copyFrom), -1);
  rb_define_method(SwigClassListKey.klass, "setPosition", VALUEFUNC(_wrap_ListKey_setPosition), -1);
  rb_define_method(SwigClassListKey.klass, "decrement", VALUEFUNC(_wrap_ListKey_decrement), -1);
  rb_define_method(SwigClassListKey.klass, "increment", VALUEFUNC(_wrap_ListKey_increment), -1);
  rb_define_method(SwigClassListKey.klass, "isTraversable", VALUEFUNC(_wrap_ListKey_isTraversable), -1);
  rb_define_method(SwigClassListKey.klass, "getIndex", VALUEFUNC(_wrap_ListKey_getIndex), -1);
  rb_define_method(SwigClassListKey.klass, "getRangeText", VALUEFUNC(_wrap_ListKey_getRangeText), -1);
  rb_define_method(SwigClassListKey.klass, "getOSISRefRangeText", VALUEFUNC(_wrap_ListKey_getOSISRefRangeText), -1);
  rb_define_method(SwigClassListKey.klass, "setIndex", VALUEFUNC(_wrap_ListKey_setIndex), -1);
  rb_define_method(SwigClassListKey.klass, "getText", VALUEFUNC(_wrap_ListKey_getText), -1);
  rb_define_method(SwigClassListKey.klass, "setText", VALUEFUNC(_wrap_ListKey_setText), -1);
  rb_define_method(SwigClassListKey.klass, "sort", VALUEFUNC(_wrap_ListKey_sort), -1);
  rb_define_method(SwigClassListKey.klass, "==", VALUEFUNC(_wrap_ListKey___eq__), -1);
  rb_define_method(SwigClassListKey.klass, ">", VALUEFUNC(_wrap_ListKey___gt__), -1);
  rb_define_method(SwigClassListKey.klass, "<", VALUEFUNC(_wrap_ListKey___lt__), -1);
  rb_define_method(SwigClassListKey.klass, ">=", VALUEFUNC(_wrap_ListKey___ge__), -1);
  rb_define_method(SwigClassListKey.klass, "<=", VALUEFUNC(_wrap_ListKey___le__), -1);
  rb_define_singleton_method(SwigClassListKey.klass, "castTo", VALUEFUNC(_wrap_ListKey_castTo), -1);
  SwigClassListKey.mark = 0;
  SwigClassListKey.destroy = (void (*)(void *)) free_sword_ListKey;
  SwigClassListKey.trackObjects = 0;
  
  SwigClassVerseKey.klass = rb_define_class_under(mSword, "VerseKey", ((swig_class *) SWIGTYPE_p_sword__SWKey->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__VerseKey, (void *) &SwigClassVerseKey);
  rb_define_alloc_func(SwigClassVerseKey.klass, _wrap_VerseKey_allocate);
  rb_define_method(SwigClassVerseKey.klass, "initialize", VALUEFUNC(_wrap_new_VerseKey), -1);
  rb_define_method(SwigClassVerseKey.klass, "LowerBound", VALUEFUNC(_wrap_VerseKey_LowerBound), -1);
  rb_define_method(SwigClassVerseKey.klass, "UpperBound", VALUEFUNC(_wrap_VerseKey_UpperBound), -1);
  rb_define_method(SwigClassVerseKey.klass, "ClearBounds", VALUEFUNC(_wrap_VerseKey_ClearBounds), -1);
  rb_define_method(SwigClassVerseKey.klass, "clone", VALUEFUNC(_wrap_VerseKey_clone), -1);
  rb_define_method(SwigClassVerseKey.klass, "getText", VALUEFUNC(_wrap_VerseKey_getText), -1);
  rb_define_method(SwigClassVerseKey.klass, "getShortText", VALUEFUNC(_wrap_VerseKey_getShortText), -1);
  rb_define_method(SwigClassVerseKey.klass, "setText", VALUEFUNC(_wrap_VerseKey_setText), -1);
  rb_define_method(SwigClassVerseKey.klass, "copyFrom", VALUEFUNC(_wrap_VerseKey_copyFrom), -1);
  rb_define_method(SwigClassVerseKey.klass, "positionFrom", VALUEFUNC(_wrap_VerseKey_positionFrom), -1);
  rb_define_method(SwigClassVerseKey.klass, "setPosition", VALUEFUNC(_wrap_VerseKey_setPosition), -1);
  rb_define_method(SwigClassVerseKey.klass, "decrement", VALUEFUNC(_wrap_VerseKey_decrement), -1);
  rb_define_method(SwigClassVerseKey.klass, "increment", VALUEFUNC(_wrap_VerseKey_increment), -1);
  rb_define_method(SwigClassVerseKey.klass, "isTraversable", VALUEFUNC(_wrap_VerseKey_isTraversable), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBookName", VALUEFUNC(_wrap_VerseKey_getBookName), -1);
  rb_define_method(SwigClassVerseKey.klass, "setBookName", VALUEFUNC(_wrap_VerseKey_setBookName), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBookAbbrev", VALUEFUNC(_wrap_VerseKey_getBookAbbrev), -1);
  rb_define_method(SwigClassVerseKey.klass, "getTestament", VALUEFUNC(_wrap_VerseKey_getTestament), -1);
  rb_define_method(SwigClassVerseKey.klass, "getTestamentMax", VALUEFUNC(_wrap_VerseKey_getTestamentMax), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBook", VALUEFUNC(_wrap_VerseKey_getBook), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBookMax", VALUEFUNC(_wrap_VerseKey_getBookMax), -1);
  rb_define_method(SwigClassVerseKey.klass, "getChapter", VALUEFUNC(_wrap_VerseKey_getChapter), -1);
  rb_define_method(SwigClassVerseKey.klass, "getChapterMax", VALUEFUNC(_wrap_VerseKey_getChapterMax), -1);
  rb_define_method(SwigClassVerseKey.klass, "getVerse", VALUEFUNC(_wrap_VerseKey_getVerse), -1);
  rb_define_method(SwigClassVerseKey.klass, "getVerseMax", VALUEFUNC(_wrap_VerseKey_getVerseMax), -1);
  rb_define_method(SwigClassVerseKey.klass, "getSuffix", VALUEFUNC(_wrap_VerseKey_getSuffix), -1);
  rb_define_method(SwigClassVerseKey.klass, "Testament", VALUEFUNC(_wrap_VerseKey_Testament), -1);
  rb_define_method(SwigClassVerseKey.klass, "setTestament", VALUEFUNC(_wrap_VerseKey_setTestament), -1);
  rb_define_method(SwigClassVerseKey.klass, "Book", VALUEFUNC(_wrap_VerseKey_Book), -1);
  rb_define_method(SwigClassVerseKey.klass, "setBook", VALUEFUNC(_wrap_VerseKey_setBook), -1);
  rb_define_method(SwigClassVerseKey.klass, "Chapter", VALUEFUNC(_wrap_VerseKey_Chapter), -1);
  rb_define_method(SwigClassVerseKey.klass, "setChapter", VALUEFUNC(_wrap_VerseKey_setChapter), -1);
  rb_define_method(SwigClassVerseKey.klass, "Verse", VALUEFUNC(_wrap_VerseKey_Verse), -1);
  rb_define_method(SwigClassVerseKey.klass, "setVerse", VALUEFUNC(_wrap_VerseKey_setVerse), -1);
  rb_define_method(SwigClassVerseKey.klass, "setSuffix", VALUEFUNC(_wrap_VerseKey_setSuffix), -1);
  rb_define_method(SwigClassVerseKey.klass, "Normalize", VALUEFUNC(_wrap_VerseKey_Normalize), -1);
  rb_define_method(SwigClassVerseKey.klass, "AutoNormalize", VALUEFUNC(_wrap_VerseKey_AutoNormalize), -1);
  rb_define_method(SwigClassVerseKey.klass, "isAutoNormalize", VALUEFUNC(_wrap_VerseKey_isAutoNormalize), -1);
  rb_define_method(SwigClassVerseKey.klass, "setAutoNormalize", VALUEFUNC(_wrap_VerseKey_setAutoNormalize), -1);
  rb_define_method(SwigClassVerseKey.klass, "Headings", VALUEFUNC(_wrap_VerseKey_Headings), -1);
  rb_define_method(SwigClassVerseKey.klass, "getIndex", VALUEFUNC(_wrap_VerseKey_getIndex), -1);
  rb_define_method(SwigClassVerseKey.klass, "setIndex", VALUEFUNC(_wrap_VerseKey_setIndex), -1);
  rb_define_method(SwigClassVerseKey.klass, "getTestamentIndex", VALUEFUNC(_wrap_VerseKey_getTestamentIndex), -1);
  rb_define_method(SwigClassVerseKey.klass, "TestamentIndex", VALUEFUNC(_wrap_VerseKey_TestamentIndex), -1);
  rb_define_method(SwigClassVerseKey.klass, "getOSISRef", VALUEFUNC(_wrap_VerseKey_getOSISRef), -1);
  rb_define_singleton_method(SwigClassVerseKey.klass, "convertToOSIS", VALUEFUNC(_wrap_VerseKey_convertToOSIS), -1);
  rb_define_method(SwigClassVerseKey.klass, "ParseVerseList", VALUEFUNC(_wrap_VerseKey_ParseVerseList), -1);
  rb_define_method(SwigClassVerseKey.klass, "getRangeText", VALUEFUNC(_wrap_VerseKey_getRangeText), -1);
  rb_define_method(SwigClassVerseKey.klass, "getOSISRefRangeText", VALUEFUNC(_wrap_VerseKey_getOSISRefRangeText), -1);
  rb_define_method(SwigClassVerseKey.klass, "compare", VALUEFUNC(_wrap_VerseKey_compare), -1);
  rb_define_method(SwigClassVerseKey.klass, "_compare", VALUEFUNC(_wrap_VerseKey__compare), -1);
  rb_define_method(SwigClassVerseKey.klass, "setVersificationSystem", VALUEFUNC(_wrap_VerseKey_setVersificationSystem), -1);
  rb_define_method(SwigClassVerseKey.klass, "getVersificationSystem", VALUEFUNC(_wrap_VerseKey_getVersificationSystem), -1);
  rb_define_method(SwigClassVerseKey.klass, "validateCurrentLocale", VALUEFUNC(_wrap_VerseKey_validateCurrentLocale), -1);
  rb_define_method(SwigClassVerseKey.klass, "==", VALUEFUNC(_wrap_VerseKey___eq__), -1);
  rb_define_method(SwigClassVerseKey.klass, ">", VALUEFUNC(_wrap_VerseKey___gt__), -1);
  rb_define_method(SwigClassVerseKey.klass, "<", VALUEFUNC(_wrap_VerseKey___lt__), -1);
  rb_define_method(SwigClassVerseKey.klass, ">=", VALUEFUNC(_wrap_VerseKey___ge__), -1);
  rb_define_method(SwigClassVerseKey.klass, "<=", VALUEFUNC(_wrap_VerseKey___le__), -1);
  rb_define_singleton_method(SwigClassVerseKey.klass, "castTo", VALUEFUNC(_wrap_VerseKey_castTo), -1);
  rb_define_method(SwigClassVerseKey.klass, "bookCount", VALUEFUNC(_wrap_VerseKey_bookCount), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBookCount", VALUEFUNC(_wrap_VerseKey_getBookCount), -1);
  rb_define_method(SwigClassVerseKey.klass, "bookName", VALUEFUNC(_wrap_VerseKey_bookName), -1);
  rb_define_method(SwigClassVerseKey.klass, "getBookNumberByOSISName", VALUEFUNC(_wrap_VerseKey_getBookNumberByOSISName), -1);
  rb_define_method(SwigClassVerseKey.klass, "getOSISBookName", VALUEFUNC(_wrap_VerseKey_getOSISBookName), -1);
  rb_define_method(SwigClassVerseKey.klass, "chapterCount", VALUEFUNC(_wrap_VerseKey_chapterCount), -1);
  rb_define_method(SwigClassVerseKey.klass, "verseCount", VALUEFUNC(_wrap_VerseKey_verseCount), -1);
  SwigClassVerseKey.mark = 0;
  SwigClassVerseKey.destroy = (void (*)(void *)) free_sword_VerseKey;
  SwigClassVerseKey.trackObjects = 0;
  
  SwigClassAbbrev.klass = rb_define_class_under(mSword, "Abbrev", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__abbrev, (void *) &SwigClassAbbrev);
  rb_define_alloc_func(SwigClassAbbrev.klass, _wrap_abbrev_allocate);
  rb_define_method(SwigClassAbbrev.klass, "initialize", VALUEFUNC(_wrap_new_abbrev), -1);
  rb_define_method(SwigClassAbbrev.klass, "ab", VALUEFUNC(_wrap_abbrev_ab_get), -1);
  rb_define_method(SwigClassAbbrev.klass, "osis=", VALUEFUNC(_wrap_abbrev_osis_set), -1);
  rb_define_method(SwigClassAbbrev.klass, "osis", VALUEFUNC(_wrap_abbrev_osis_get), -1);
  rb_define_method(SwigClassAbbrev.klass, "getAbbrevCount", VALUEFUNC(_wrap_abbrev_getAbbrevCount), -1);
  rb_define_method(SwigClassAbbrev.klass, "getAbbrevData", VALUEFUNC(_wrap_abbrev_getAbbrevData), -1);
  SwigClassAbbrev.mark = 0;
  SwigClassAbbrev.destroy = (void (*)(void *)) free_sword_abbrev;
  SwigClassAbbrev.trackObjects = 0;
  
  SwigClassSbook.klass = rb_define_class_under(mSword, "Sbook", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__sbook, (void *) &SwigClassSbook);
  rb_define_alloc_func(SwigClassSbook.klass, _wrap_sbook_allocate);
  rb_define_method(SwigClassSbook.klass, "initialize", VALUEFUNC(_wrap_new_sbook), -1);
  rb_define_method(SwigClassSbook.klass, "name", VALUEFUNC(_wrap_sbook_name_get), -1);
  rb_define_method(SwigClassSbook.klass, "osis=", VALUEFUNC(_wrap_sbook_osis_set), -1);
  rb_define_method(SwigClassSbook.klass, "osis", VALUEFUNC(_wrap_sbook_osis_get), -1);
  rb_define_method(SwigClassSbook.klass, "prefAbbrev", VALUEFUNC(_wrap_sbook_prefAbbrev_get), -1);
  rb_define_method(SwigClassSbook.klass, "chapmax=", VALUEFUNC(_wrap_sbook_chapmax_set), -1);
  rb_define_method(SwigClassSbook.klass, "chapmax", VALUEFUNC(_wrap_sbook_chapmax_get), -1);
  rb_define_method(SwigClassSbook.klass, "verseMax", VALUEFUNC(_wrap_sbook_verseMax), -1);
  SwigClassSbook.mark = 0;
  SwigClassSbook.destroy = (void (*)(void *)) free_sword_sbook;
  SwigClassSbook.trackObjects = 0;
  
  SwigClassVerseMgr.klass = rb_define_class_under(mSword, "VerseMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__VerseMgr, (void *) &SwigClassVerseMgr);
  rb_define_alloc_func(SwigClassVerseMgr.klass, _wrap_VerseMgr_allocate);
  rb_define_method(SwigClassVerseMgr.klass, "initialize", VALUEFUNC(_wrap_new_VerseMgr), -1);
  rb_define_singleton_method(SwigClassVerseMgr.klass, "getSystemVerseMgr", VALUEFUNC(_wrap_VerseMgr_getSystemVerseMgr), -1);
  rb_define_singleton_method(SwigClassVerseMgr.klass, "setSystemVerseMgr", VALUEFUNC(_wrap_VerseMgr_setSystemVerseMgr), -1);
  rb_define_method(SwigClassVerseMgr.klass, "getVersificationSystems", VALUEFUNC(_wrap_VerseMgr_getVersificationSystems), -1);
  rb_define_method(SwigClassVerseMgr.klass, "getVersificationSystem", VALUEFUNC(_wrap_VerseMgr_getVersificationSystem), -1);
  rb_define_method(SwigClassVerseMgr.klass, "registerVersificationSystem", VALUEFUNC(_wrap_VerseMgr_registerVersificationSystem), -1);
  SwigClassVerseMgr.mark = 0;
  SwigClassVerseMgr.destroy = (void (*)(void *)) free_sword_VerseMgr;
  SwigClassVerseMgr.trackObjects = 0;
  rb_define_singleton_method(mSword, "builtin_abbrevs", VALUEFUNC(_wrap_builtin_abbrevs_get), 0);
  
  SwigClassTreeKey.klass = rb_define_class_under(mSword, "TreeKey", ((swig_class *) SWIGTYPE_p_sword__SWKey->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__TreeKey, (void *) &SwigClassTreeKey);
  rb_undef_alloc_func(SwigClassTreeKey.klass);
  rb_define_method(SwigClassTreeKey.klass, "posChangeListener=", VALUEFUNC(_wrap_TreeKey_posChangeListener_set), -1);
  rb_define_method(SwigClassTreeKey.klass, "posChangeListener", VALUEFUNC(_wrap_TreeKey_posChangeListener_get), -1);
  rb_define_method(SwigClassTreeKey.klass, "setPositionChangeListener", VALUEFUNC(_wrap_TreeKey_setPositionChangeListener), -1);
  rb_define_method(SwigClassTreeKey.klass, "getLocalName", VALUEFUNC(_wrap_TreeKey_getLocalName), -1);
  rb_define_method(SwigClassTreeKey.klass, "setLocalName", VALUEFUNC(_wrap_TreeKey_setLocalName), -1);
  rb_define_method(SwigClassTreeKey.klass, "getLevel", VALUEFUNC(_wrap_TreeKey_getLevel), -1);
  rb_define_method(SwigClassTreeKey.klass, "getUserData", VALUEFUNC(_wrap_TreeKey_getUserData), -1);
  rb_define_method(SwigClassTreeKey.klass, "setUserData", VALUEFUNC(_wrap_TreeKey_setUserData), -1);
  rb_define_method(SwigClassTreeKey.klass, "root", VALUEFUNC(_wrap_TreeKey_root), -1);
  rb_define_method(SwigClassTreeKey.klass, "parent", VALUEFUNC(_wrap_TreeKey_parent), -1);
  rb_define_method(SwigClassTreeKey.klass, "firstChild", VALUEFUNC(_wrap_TreeKey_firstChild), -1);
  rb_define_method(SwigClassTreeKey.klass, "nextSibling", VALUEFUNC(_wrap_TreeKey_nextSibling), -1);
  rb_define_method(SwigClassTreeKey.klass, "previousSibling", VALUEFUNC(_wrap_TreeKey_previousSibling), -1);
  rb_define_method(SwigClassTreeKey.klass, "hasChildren", VALUEFUNC(_wrap_TreeKey_hasChildren), -1);
  rb_define_method(SwigClassTreeKey.klass, "append", VALUEFUNC(_wrap_TreeKey_append), -1);
  rb_define_method(SwigClassTreeKey.klass, "appendChild", VALUEFUNC(_wrap_TreeKey_appendChild), -1);
  rb_define_method(SwigClassTreeKey.klass, "insertBefore", VALUEFUNC(_wrap_TreeKey_insertBefore), -1);
  rb_define_method(SwigClassTreeKey.klass, "remove", VALUEFUNC(_wrap_TreeKey_remove), -1);
  rb_define_method(SwigClassTreeKey.klass, "setOffset", VALUEFUNC(_wrap_TreeKey_setOffset), -1);
  rb_define_method(SwigClassTreeKey.klass, "getOffset", VALUEFUNC(_wrap_TreeKey_getOffset), -1);
  rb_define_method(SwigClassTreeKey.klass, "setText", VALUEFUNC(_wrap_TreeKey_setText), -1);
  rb_define_method(SwigClassTreeKey.klass, "setPosition", VALUEFUNC(_wrap_TreeKey_setPosition), -1);
  rb_define_method(SwigClassTreeKey.klass, "getText", VALUEFUNC(_wrap_TreeKey_getText), -1);
  rb_define_method(SwigClassTreeKey.klass, "compare", VALUEFUNC(_wrap_TreeKey_compare), -1);
  rb_define_method(SwigClassTreeKey.klass, "decrement", VALUEFUNC(_wrap_TreeKey_decrement), -1);
  rb_define_method(SwigClassTreeKey.klass, "increment", VALUEFUNC(_wrap_TreeKey_increment), -1);
  rb_define_method(SwigClassTreeKey.klass, "isTraversable", VALUEFUNC(_wrap_TreeKey_isTraversable), -1);
  rb_define_method(SwigClassTreeKey.klass, "getIndex", VALUEFUNC(_wrap_TreeKey_getIndex), -1);
  rb_define_method(SwigClassTreeKey.klass, "setIndex", VALUEFUNC(_wrap_TreeKey_setIndex), -1);
  rb_define_method(SwigClassTreeKey.klass, "assureKeyPath", VALUEFUNC(_wrap_TreeKey_assureKeyPath), -1);
  rb_define_method(SwigClassTreeKey.klass, "save", VALUEFUNC(_wrap_TreeKey_save), -1);
  rb_define_method(SwigClassTreeKey.klass, "==", VALUEFUNC(_wrap_TreeKey___eq__), -1);
  rb_define_method(SwigClassTreeKey.klass, ">", VALUEFUNC(_wrap_TreeKey___gt__), -1);
  rb_define_method(SwigClassTreeKey.klass, "<", VALUEFUNC(_wrap_TreeKey___lt__), -1);
  rb_define_method(SwigClassTreeKey.klass, ">=", VALUEFUNC(_wrap_TreeKey___ge__), -1);
  rb_define_method(SwigClassTreeKey.klass, "<=", VALUEFUNC(_wrap_TreeKey___le__), -1);
  rb_define_singleton_method(SwigClassTreeKey.klass, "castTo", VALUEFUNC(_wrap_TreeKey_castTo), -1);
  SwigClassTreeKey.mark = 0;
  SwigClassTreeKey.destroy = (void (*)(void *)) free_sword_TreeKey;
  SwigClassTreeKey.trackObjects = 0;
  
  SwigClassTreeKeyIdx.klass = rb_define_class_under(mSword, "TreeKeyIdx", ((swig_class *) SWIGTYPE_p_sword__TreeKey->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__TreeKeyIdx, (void *) &SwigClassTreeKeyIdx);
  rb_define_alloc_func(SwigClassTreeKeyIdx.klass, _wrap_TreeKeyIdx_allocate);
  rb_define_method(SwigClassTreeKeyIdx.klass, "initialize", VALUEFUNC(_wrap_new_TreeKeyIdx), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "clone", VALUEFUNC(_wrap_TreeKeyIdx_clone), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "getLocalName", VALUEFUNC(_wrap_TreeKeyIdx_getLocalName), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "setLocalName", VALUEFUNC(_wrap_TreeKeyIdx_setLocalName), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "getUserData", VALUEFUNC(_wrap_TreeKeyIdx_getUserData), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "setUserData", VALUEFUNC(_wrap_TreeKeyIdx_setUserData), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "root", VALUEFUNC(_wrap_TreeKeyIdx_root), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "parent", VALUEFUNC(_wrap_TreeKeyIdx_parent), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "firstChild", VALUEFUNC(_wrap_TreeKeyIdx_firstChild), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "nextSibling", VALUEFUNC(_wrap_TreeKeyIdx_nextSibling), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "previousSibling", VALUEFUNC(_wrap_TreeKeyIdx_previousSibling), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "hasChildren", VALUEFUNC(_wrap_TreeKeyIdx_hasChildren), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "append", VALUEFUNC(_wrap_TreeKeyIdx_append), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "appendChild", VALUEFUNC(_wrap_TreeKeyIdx_appendChild), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "insertBefore", VALUEFUNC(_wrap_TreeKeyIdx_insertBefore), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "remove", VALUEFUNC(_wrap_TreeKeyIdx_remove), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "save", VALUEFUNC(_wrap_TreeKeyIdx_save), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "copyFrom", VALUEFUNC(_wrap_TreeKeyIdx_copyFrom), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "setOffset", VALUEFUNC(_wrap_TreeKeyIdx_setOffset), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "getOffset", VALUEFUNC(_wrap_TreeKeyIdx_getOffset), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "getLevel", VALUEFUNC(_wrap_TreeKeyIdx_getLevel), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "==", VALUEFUNC(_wrap_TreeKeyIdx___eq__), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, ">", VALUEFUNC(_wrap_TreeKeyIdx___gt__), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "<", VALUEFUNC(_wrap_TreeKeyIdx___lt__), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, ">=", VALUEFUNC(_wrap_TreeKeyIdx___ge__), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "<=", VALUEFUNC(_wrap_TreeKeyIdx___le__), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "setText", VALUEFUNC(_wrap_TreeKeyIdx_setText), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "setPosition", VALUEFUNC(_wrap_TreeKeyIdx_setPosition), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "getText", VALUEFUNC(_wrap_TreeKeyIdx_getText), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "_compare", VALUEFUNC(_wrap_TreeKeyIdx__compare), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "compare", VALUEFUNC(_wrap_TreeKeyIdx_compare), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "decrement", VALUEFUNC(_wrap_TreeKeyIdx_decrement), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "increment", VALUEFUNC(_wrap_TreeKeyIdx_increment), -1);
  rb_define_method(SwigClassTreeKeyIdx.klass, "isTraversable", VALUEFUNC(_wrap_TreeKeyIdx_isTraversable), -1);
  rb_define_singleton_method(SwigClassTreeKeyIdx.klass, "create", VALUEFUNC(_wrap_TreeKeyIdx_create), -1);
  rb_define_singleton_method(SwigClassTreeKeyIdx.klass, "castTo", VALUEFUNC(_wrap_TreeKeyIdx_castTo), -1);
  SwigClassTreeKeyIdx.mark = 0;
  SwigClassTreeKeyIdx.destroy = (void (*)(void *)) free_sword_TreeKeyIdx;
  SwigClassTreeKeyIdx.trackObjects = 0;
  
  SwigClassVerseTreeKey.klass = rb_define_class_under(mSword, "VerseTreeKey", ((swig_class *) SWIGTYPE_p_sword__VerseKey->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__VerseTreeKey, (void *) &SwigClassVerseTreeKey);
  rb_define_alloc_func(SwigClassVerseTreeKey.klass, _wrap_VerseTreeKey_allocate);
  rb_define_method(SwigClassVerseTreeKey.klass, "initialize", VALUEFUNC(_wrap_new_VerseTreeKey), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "clone", VALUEFUNC(_wrap_VerseTreeKey_clone), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "isTraversable", VALUEFUNC(_wrap_VerseTreeKey_isTraversable), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "getTreeKey", VALUEFUNC(_wrap_VerseTreeKey_getTreeKey), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "positionChanged", VALUEFUNC(_wrap_VerseTreeKey_positionChanged), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "internalPosChange=", VALUEFUNC(_wrap_VerseTreeKey_internalPosChange_set), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "internalPosChange", VALUEFUNC(_wrap_VerseTreeKey_internalPosChange_get), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "decrement", VALUEFUNC(_wrap_VerseTreeKey_decrement), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "increment", VALUEFUNC(_wrap_VerseTreeKey_increment), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "Normalize", VALUEFUNC(_wrap_VerseTreeKey_Normalize), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "setPosition", VALUEFUNC(_wrap_VerseTreeKey_setPosition), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "NewIndex", VALUEFUNC(_wrap_VerseTreeKey_NewIndex), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "==", VALUEFUNC(_wrap_VerseTreeKey___eq__), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, ">", VALUEFUNC(_wrap_VerseTreeKey___gt__), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "<", VALUEFUNC(_wrap_VerseTreeKey___lt__), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, ">=", VALUEFUNC(_wrap_VerseTreeKey___ge__), -1);
  rb_define_method(SwigClassVerseTreeKey.klass, "<=", VALUEFUNC(_wrap_VerseTreeKey___le__), -1);
  rb_define_singleton_method(SwigClassVerseTreeKey.klass, "castTo", VALUEFUNC(_wrap_VerseTreeKey_castTo), -1);
  SwigClassVerseTreeKey.mark = 0;
  SwigClassVerseTreeKey.destroy = (void (*)(void *)) free_sword_VerseTreeKey;
  SwigClassVerseTreeKey.trackObjects = 0;
  
  SwigClassSWDisplay.klass = rb_define_class_under(mSword, "SWDisplay", ((swig_class *) SWIGTYPE_p_sword__SWObject->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWDisplay, (void *) &SwigClassSWDisplay);
  rb_define_alloc_func(SwigClassSWDisplay.klass, _wrap_SWDisplay_allocate);
  rb_define_method(SwigClassSWDisplay.klass, "initialize", VALUEFUNC(_wrap_new_SWDisplay), -1);
  rb_define_method(SwigClassSWDisplay.klass, "Display", VALUEFUNC(_wrap_SWDisplay_Display), -1);
  SwigClassSWDisplay.mark = 0;
  SwigClassSWDisplay.destroy = (void (*)(void *)) free_sword_SWDisplay;
  SwigClassSWDisplay.trackObjects = 0;
  
  SwigClassSWFilter.klass = rb_define_class_under(mSword, "SWFilter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWFilter, (void *) &SwigClassSWFilter);
  rb_undef_alloc_func(SwigClassSWFilter.klass);
  rb_define_method(SwigClassSWFilter.klass, "processText", VALUEFUNC(_wrap_SWFilter_processText), -1);
  rb_define_method(SwigClassSWFilter.klass, "getHeader", VALUEFUNC(_wrap_SWFilter_getHeader), -1);
  SwigClassSWFilter.mark = 0;
  SwigClassSWFilter.destroy = (void (*)(void *)) free_sword_SWFilter;
  SwigClassSWFilter.trackObjects = 0;
  
  SwigClassSWOptionFilter.klass = rb_define_class_under(mSword, "SWOptionFilter", ((swig_class *) SWIGTYPE_p_sword__SWFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWOptionFilter, (void *) &SwigClassSWOptionFilter);
  rb_undef_alloc_func(SwigClassSWOptionFilter.klass);
  rb_define_method(SwigClassSWOptionFilter.klass, "getOptionName", VALUEFUNC(_wrap_SWOptionFilter_getOptionName), -1);
  rb_define_method(SwigClassSWOptionFilter.klass, "getOptionTip", VALUEFUNC(_wrap_SWOptionFilter_getOptionTip), -1);
  rb_define_method(SwigClassSWOptionFilter.klass, "getOptionValue", VALUEFUNC(_wrap_SWOptionFilter_getOptionValue), -1);
  rb_define_method(SwigClassSWOptionFilter.klass, "setOptionValue", VALUEFUNC(_wrap_SWOptionFilter_setOptionValue), -1);
  rb_define_singleton_method(SwigClassSWOptionFilter.klass, "castTo", VALUEFUNC(_wrap_SWOptionFilter_castTo), -1);
  SwigClassSWOptionFilter.mark = 0;
  SwigClassSWOptionFilter.destroy = (void (*)(void *)) free_sword_SWOptionFilter;
  SwigClassSWOptionFilter.trackObjects = 0;
  
  SwigClassSWFilterMgr.klass = rb_define_class_under(mSword, "SWFilterMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWFilterMgr, (void *) &SwigClassSWFilterMgr);
  rb_define_alloc_func(SwigClassSWFilterMgr.klass, _wrap_SWFilterMgr_allocate);
  rb_define_method(SwigClassSWFilterMgr.klass, "initialize", VALUEFUNC(_wrap_new_SWFilterMgr), -1);
  rb_define_method(SwigClassSWFilterMgr.klass, "setParentMgr", VALUEFUNC(_wrap_SWFilterMgr_setParentMgr), -1);
  rb_define_method(SwigClassSWFilterMgr.klass, "getParentMgr", VALUEFUNC(_wrap_SWFilterMgr_getParentMgr), -1);
  SwigClassSWFilterMgr.mark = 0;
  SwigClassSWFilterMgr.destroy = (void (*)(void *)) free_sword_SWFilterMgr;
  SwigClassSWFilterMgr.trackObjects = 0;
  
  SwigClassStringMgr.klass = rb_define_class_under(mSword, "StringMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__StringMgr, (void *) &SwigClassStringMgr);
  rb_undef_alloc_func(SwigClassStringMgr.klass);
  rb_define_singleton_method(SwigClassStringMgr.klass, "setSystemStringMgr", VALUEFUNC(_wrap_StringMgr_setSystemStringMgr), -1);
  rb_define_singleton_method(SwigClassStringMgr.klass, "getSystemStringMgr", VALUEFUNC(_wrap_StringMgr_getSystemStringMgr), -1);
  rb_define_singleton_method(SwigClassStringMgr.klass, "hasUTF8Support", VALUEFUNC(_wrap_StringMgr_hasUTF8Support), -1);
  rb_define_method(SwigClassStringMgr.klass, "upperUTF8", VALUEFUNC(_wrap_StringMgr_upperUTF8), -1);
  rb_define_method(SwigClassStringMgr.klass, "upperLatin1", VALUEFUNC(_wrap_StringMgr_upperLatin1), -1);
  SwigClassStringMgr.mark = 0;
  SwigClassStringMgr.trackObjects = 0;
  rb_define_module_function(mSword, "toupperstr_utf8", VALUEFUNC(_wrap_toupperstr_utf8), -1);
  rb_define_module_function(mSword, "toupperstr", VALUEFUNC(_wrap_toupperstr), -1);
  
  SwigClassPyStringMgr.klass = rb_define_class_under(mSword, "PyStringMgr", ((swig_class *) SWIGTYPE_p_sword__StringMgr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_PyStringMgr, (void *) &SwigClassPyStringMgr);
  rb_undef_alloc_func(SwigClassPyStringMgr.klass);
  rb_define_method(SwigClassPyStringMgr.klass, "upperUTF8", VALUEFUNC(_wrap_PyStringMgr_upperUTF8), -1);
  rb_define_method(SwigClassPyStringMgr.klass, "getUpper", VALUEFUNC(_wrap_PyStringMgr_getUpper), -1);
  SwigClassPyStringMgr.mark = 0;
  SwigClassPyStringMgr.destroy = (void (*)(void *)) free_PyStringMgr;
  SwigClassPyStringMgr.trackObjects = 0;
  
  SwigClassSWSearchable.klass = rb_define_class_under(mSword, "SWSearchable", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWSearchable, (void *) &SwigClassSWSearchable);
  rb_undef_alloc_func(SwigClassSWSearchable.klass);
  rb_define_method(SwigClassSWSearchable.klass, "deleteSearchFramework", VALUEFUNC(_wrap_SWSearchable_deleteSearchFramework), -1);
  rb_define_method(SwigClassSWSearchable.klass, "hasSearchFramework", VALUEFUNC(_wrap_SWSearchable_hasSearchFramework), -1);
  rb_define_method(SwigClassSWSearchable.klass, "isSearchOptimallySupported", VALUEFUNC(_wrap_SWSearchable_isSearchOptimallySupported), -1);
  rb_define_method(SwigClassSWSearchable.klass, "isSearchSupported", VALUEFUNC(_wrap_SWSearchable_isSearchSupported), -1);
  rb_define_method(SwigClassSWSearchable.klass, "doSearch", VALUEFUNC(_wrap_SWSearchable_doSearch), -1);
  SwigClassSWSearchable.mark = 0;
  SwigClassSWSearchable.destroy = (void (*)(void *)) free_sword_SWSearchable;
  SwigClassSWSearchable.trackObjects = 0;
  rb_define_const(mSword, "SEARCHFLAG_MATCHWHOLEENTRY", SWIG_From_int(static_cast< int >(4096)));
  
  SwigClassSWModule.klass = rb_define_class_under(mSword, "SWModule", ((swig_class *) SWIGTYPE_p_sword__SWSearchable->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWModule, (void *) &SwigClassSWModule);
  rb_undef_alloc_func(SwigClassSWModule.klass);
  rb_define_method(SwigClassSWModule.klass, "terminateSearch=", VALUEFUNC(_wrap_SWModule_terminateSearch_set), -1);
  rb_define_method(SwigClassSWModule.klass, "terminateSearch", VALUEFUNC(_wrap_SWModule_terminateSearch_get), -1);
  rb_define_method(SwigClassSWModule.klass, "Error", VALUEFUNC(_wrap_SWModule_Error), -1);
  rb_define_method(SwigClassSWModule.klass, "isUnicode", VALUEFUNC(_wrap_SWModule_isUnicode), -1);
  rb_define_method(SwigClassSWModule.klass, "getConfigEntry", VALUEFUNC(_wrap_SWModule_getConfigEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "getEntrySize", VALUEFUNC(_wrap_SWModule_getEntrySize), -1);
  rb_define_method(SwigClassSWModule.klass, "setKey", VALUEFUNC(_wrap_SWModule_setKey), -1);
  rb_define_method(SwigClassSWModule.klass, "SetKey", VALUEFUNC(_wrap_SWModule_SetKey), -1);
  rb_define_method(SwigClassSWModule.klass, "getKey", VALUEFUNC(_wrap_SWModule_getKey), -1);
  rb_define_method(SwigClassSWModule.klass, "Key", VALUEFUNC(_wrap_SWModule_Key), -1);
  rb_define_method(SwigClassSWModule.klass, "KeyText", VALUEFUNC(_wrap_SWModule_KeyText), -1);
  rb_define_method(SwigClassSWModule.klass, "getKeyText", VALUEFUNC(_wrap_SWModule_getKeyText), -1);
  rb_define_method(SwigClassSWModule.klass, "getIndex", VALUEFUNC(_wrap_SWModule_getIndex), -1);
  rb_define_method(SwigClassSWModule.klass, "setIndex", VALUEFUNC(_wrap_SWModule_setIndex), -1);
  rb_define_method(SwigClassSWModule.klass, "Index", VALUEFUNC(_wrap_SWModule_Index), -1);
  rb_define_method(SwigClassSWModule.klass, "Display", VALUEFUNC(_wrap_SWModule_Display), -1);
  rb_define_method(SwigClassSWModule.klass, "getDisplay", VALUEFUNC(_wrap_SWModule_getDisplay), -1);
  rb_define_method(SwigClassSWModule.klass, "setDisplay", VALUEFUNC(_wrap_SWModule_setDisplay), -1);
  rb_define_method(SwigClassSWModule.klass, "Disp", VALUEFUNC(_wrap_SWModule_Disp), -1);
  rb_define_method(SwigClassSWModule.klass, "Name", VALUEFUNC(_wrap_SWModule_Name), -1);
  rb_define_method(SwigClassSWModule.klass, "Description", VALUEFUNC(_wrap_SWModule_Description), -1);
  rb_define_method(SwigClassSWModule.klass, "Type", VALUEFUNC(_wrap_SWModule_Type), -1);
  rb_define_method(SwigClassSWModule.klass, "Direction", VALUEFUNC(_wrap_SWModule_Direction), -1);
  rb_define_method(SwigClassSWModule.klass, "Encoding", VALUEFUNC(_wrap_SWModule_Encoding), -1);
  rb_define_method(SwigClassSWModule.klass, "Markup", VALUEFUNC(_wrap_SWModule_Markup), -1);
  rb_define_method(SwigClassSWModule.klass, "Lang", VALUEFUNC(_wrap_SWModule_Lang), -1);
  rb_define_method(SwigClassSWModule.klass, "CreateKey", VALUEFUNC(_wrap_SWModule_CreateKey), -1);
  rb_define_method(SwigClassSWModule.klass, "getRawEntryBuf", VALUEFUNC(_wrap_SWModule_getRawEntryBuf), -1);
  rb_define_method(SwigClassSWModule.klass, "getRawEntry", VALUEFUNC(_wrap_SWModule_getRawEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "isWritable", VALUEFUNC(_wrap_SWModule_isWritable), -1);
  rb_define_singleton_method(SwigClassSWModule.klass, "createModule", VALUEFUNC(_wrap_SWModule_createModule), -1);
  rb_define_method(SwigClassSWModule.klass, "setEntry", VALUEFUNC(_wrap_SWModule_setEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "linkEntry", VALUEFUNC(_wrap_SWModule_linkEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "deleteEntry", VALUEFUNC(_wrap_SWModule_deleteEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "decrement", VALUEFUNC(_wrap_SWModule_decrement), -1);
  rb_define_method(SwigClassSWModule.klass, "increment", VALUEFUNC(_wrap_SWModule_increment), -1);
  rb_define_method(SwigClassSWModule.klass, "setPosition", VALUEFUNC(_wrap_SWModule_setPosition), -1);
  rb_define_method(SwigClassSWModule.klass, "AddRenderFilter", VALUEFUNC(_wrap_SWModule_AddRenderFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "getRenderFilters", VALUEFUNC(_wrap_SWModule_getRenderFilters), -1);
  rb_define_method(SwigClassSWModule.klass, "RemoveRenderFilter", VALUEFUNC(_wrap_SWModule_RemoveRenderFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "ReplaceRenderFilter", VALUEFUNC(_wrap_SWModule_ReplaceRenderFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "renderFilter", VALUEFUNC(_wrap_SWModule_renderFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "AddEncodingFilter", VALUEFUNC(_wrap_SWModule_AddEncodingFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "RemoveEncodingFilter", VALUEFUNC(_wrap_SWModule_RemoveEncodingFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "ReplaceEncodingFilter", VALUEFUNC(_wrap_SWModule_ReplaceEncodingFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "encodingFilter", VALUEFUNC(_wrap_SWModule_encodingFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "AddStripFilter", VALUEFUNC(_wrap_SWModule_AddStripFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "AddRawFilter", VALUEFUNC(_wrap_SWModule_AddRawFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "stripFilter", VALUEFUNC(_wrap_SWModule_stripFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "rawFilter", VALUEFUNC(_wrap_SWModule_rawFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "AddOptionFilter", VALUEFUNC(_wrap_SWModule_AddOptionFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "optionFilter", VALUEFUNC(_wrap_SWModule_optionFilter), -1);
  rb_define_method(SwigClassSWModule.klass, "getRenderHeader", VALUEFUNC(_wrap_SWModule_getRenderHeader), -1);
  rb_define_method(SwigClassSWModule.klass, "StripText", VALUEFUNC(_wrap_SWModule_StripText), -1);
  rb_define_method(SwigClassSWModule.klass, "RenderText", VALUEFUNC(_wrap_SWModule_RenderText), -1);
  rb_define_method(SwigClassSWModule.klass, "setSkipConsecutiveLinks", VALUEFUNC(_wrap_SWModule_setSkipConsecutiveLinks), -1);
  rb_define_method(SwigClassSWModule.klass, "getSkipConsecutiveLinks", VALUEFUNC(_wrap_SWModule_getSkipConsecutiveLinks), -1);
  rb_define_method(SwigClassSWModule.klass, "isLinked", VALUEFUNC(_wrap_SWModule_isLinked), -1);
  rb_define_method(SwigClassSWModule.klass, "hasEntry", VALUEFUNC(_wrap_SWModule_hasEntry), -1);
  rb_define_method(SwigClassSWModule.klass, "processEntryAttributes", VALUEFUNC(_wrap_SWModule_processEntryAttributes), -1);
  rb_define_method(SwigClassSWModule.klass, "isProcessEntryAttributes", VALUEFUNC(_wrap_SWModule_isProcessEntryAttributes), -1);
  rb_define_method(SwigClassSWModule.klass, "deleteSearchFramework", VALUEFUNC(_wrap_SWModule_deleteSearchFramework), -1);
  rb_define_method(SwigClassSWModule.klass, "hasSearchFramework", VALUEFUNC(_wrap_SWModule_hasSearchFramework), -1);
  rb_define_method(SwigClassSWModule.klass, "<<", VALUEFUNC(_wrap_SWModule___lshift__), -1);
  rb_define_singleton_method(SwigClassSWModule.klass, "castTo", VALUEFUNC(_wrap_SWModule_castTo), -1);
  rb_define_method(SwigClassSWModule.klass, "getEntryAttributesMap", VALUEFUNC(_wrap_SWModule_getEntryAttributesMap), -1);
  rb_define_method(SwigClassSWModule.klass, "getConfigMap", VALUEFUNC(_wrap_SWModule_getConfigMap), -1);
  SwigClassSWModule.mark = 0;
  SwigClassSWModule.destroy = (void (*)(void *)) free_sword_SWModule;
  SwigClassSWModule.trackObjects = 0;
  
  SwigClassSWMgr.klass = rb_define_class_under(mSword, "SWMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWMgr, (void *) &SwigClassSWMgr);
  rb_define_alloc_func(SwigClassSWMgr.klass, _wrap_SWMgr_allocate);
  rb_define_method(SwigClassSWMgr.klass, "initialize", VALUEFUNC(_wrap_new_SWMgr), -1);
  rb_define_singleton_method(SwigClassSWMgr.klass, "isICU", VALUEFUNC(_wrap_SWMgr_isICU_get), 0);
  rb_define_singleton_method(SwigClassSWMgr.klass, "isICU=", VALUEFUNC(_wrap_SWMgr_isICU_set), 1);
  rb_define_singleton_method(SwigClassSWMgr.klass, "globalConfPath", VALUEFUNC(_wrap_SWMgr_globalConfPath_get), 0);
  rb_define_singleton_method(SwigClassSWMgr.klass, "globalConfPath=", VALUEFUNC(_wrap_SWMgr_globalConfPath_set), 1);
  rb_define_singleton_method(SwigClassSWMgr.klass, "getHomeDir", VALUEFUNC(_wrap_SWMgr_getHomeDir), -1);
  rb_define_method(SwigClassSWMgr.klass, "config=", VALUEFUNC(_wrap_SWMgr_config_set), -1);
  rb_define_method(SwigClassSWMgr.klass, "config", VALUEFUNC(_wrap_SWMgr_config_get), -1);
  rb_define_method(SwigClassSWMgr.klass, "sysConfig=", VALUEFUNC(_wrap_SWMgr_sysConfig_set), -1);
  rb_define_method(SwigClassSWMgr.klass, "sysConfig", VALUEFUNC(_wrap_SWMgr_sysConfig_get), -1);
  rb_define_method(SwigClassSWMgr.klass, "prefixPath=", VALUEFUNC(_wrap_SWMgr_prefixPath_set), -1);
  rb_define_method(SwigClassSWMgr.klass, "prefixPath", VALUEFUNC(_wrap_SWMgr_prefixPath_get), -1);
  rb_define_method(SwigClassSWMgr.klass, "configPath=", VALUEFUNC(_wrap_SWMgr_configPath_set), -1);
  rb_define_method(SwigClassSWMgr.klass, "configPath", VALUEFUNC(_wrap_SWMgr_configPath_get), -1);
  rb_define_method(SwigClassSWMgr.klass, "getModule", VALUEFUNC(_wrap_SWMgr_getModule), -1);
  rb_define_method(SwigClassSWMgr.klass, "augmentModules", VALUEFUNC(_wrap_SWMgr_augmentModules), -1);
  rb_define_method(SwigClassSWMgr.klass, "deleteModule", VALUEFUNC(_wrap_SWMgr_deleteModule), -1);
  rb_define_method(SwigClassSWMgr.klass, "InstallScan", VALUEFUNC(_wrap_SWMgr_InstallScan), -1);
  rb_define_method(SwigClassSWMgr.klass, "Load", VALUEFUNC(_wrap_SWMgr_Load), -1);
  rb_define_method(SwigClassSWMgr.klass, "setGlobalOption", VALUEFUNC(_wrap_SWMgr_setGlobalOption), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOption", VALUEFUNC(_wrap_SWMgr_getGlobalOption), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOptionTip", VALUEFUNC(_wrap_SWMgr_getGlobalOptionTip), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOptions", VALUEFUNC(_wrap_SWMgr_getGlobalOptions), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOptionValues", VALUEFUNC(_wrap_SWMgr_getGlobalOptionValues), -1);
  rb_define_method(SwigClassSWMgr.klass, "filterText", VALUEFUNC(_wrap_SWMgr_filterText), -1);
  rb_define_method(SwigClassSWMgr.klass, "setCipherKey", VALUEFUNC(_wrap_SWMgr_setCipherKey), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOptionsVector", VALUEFUNC(_wrap_SWMgr_getGlobalOptionsVector), -1);
  rb_define_method(SwigClassSWMgr.klass, "getGlobalOptionValuesVector", VALUEFUNC(_wrap_SWMgr_getGlobalOptionValuesVector), -1);
  rb_define_method(SwigClassSWMgr.klass, "getModules", VALUEFUNC(_wrap_SWMgr_getModules), -1);
  rb_define_method(SwigClassSWMgr.klass, "getModuleAt", VALUEFUNC(_wrap_SWMgr_getModuleAt), -1);
  SwigClassSWMgr.mark = 0;
  SwigClassSWMgr.destroy = (void (*)(void *)) free_sword_SWMgr;
  SwigClassSWMgr.trackObjects = 0;
  
  SwigClassDirEntry.klass = rb_define_class_under(mSword, "DirEntry", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__DirEntry, (void *) &SwigClassDirEntry);
  rb_define_alloc_func(SwigClassDirEntry.klass, _wrap_DirEntry_allocate);
  rb_define_method(SwigClassDirEntry.klass, "initialize", VALUEFUNC(_wrap_new_DirEntry), -1);
  rb_define_method(SwigClassDirEntry.klass, "name=", VALUEFUNC(_wrap_DirEntry_name_set), -1);
  rb_define_method(SwigClassDirEntry.klass, "name", VALUEFUNC(_wrap_DirEntry_name_get), -1);
  rb_define_method(SwigClassDirEntry.klass, "size=", VALUEFUNC(_wrap_DirEntry_size_set), -1);
  rb_define_method(SwigClassDirEntry.klass, "size", VALUEFUNC(_wrap_DirEntry_size_get), -1);
  rb_define_method(SwigClassDirEntry.klass, "isDirectory=", VALUEFUNC(_wrap_DirEntry_isDirectory_set), -1);
  rb_define_method(SwigClassDirEntry.klass, "isDirectory", VALUEFUNC(_wrap_DirEntry_isDirectory_get), -1);
  SwigClassDirEntry.mark = 0;
  SwigClassDirEntry.destroy = (void (*)(void *)) free_sword_DirEntry;
  SwigClassDirEntry.trackObjects = 0;
  
  SwigClassFileDesc.klass = rb_define_class_under(mSword, "FileDesc", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__FileDesc, (void *) &SwigClassFileDesc);
  rb_undef_alloc_func(SwigClassFileDesc.klass);
  rb_define_method(SwigClassFileDesc.klass, "getFd", VALUEFUNC(_wrap_FileDesc_getFd), -1);
  rb_define_method(SwigClassFileDesc.klass, "seek", VALUEFUNC(_wrap_FileDesc_seek), -1);
  rb_define_method(SwigClassFileDesc.klass, "read", VALUEFUNC(_wrap_FileDesc_read), -1);
  rb_define_method(SwigClassFileDesc.klass, "write", VALUEFUNC(_wrap_FileDesc_write), -1);
  rb_define_method(SwigClassFileDesc.klass, "path=", VALUEFUNC(_wrap_FileDesc_path_set), -1);
  rb_define_method(SwigClassFileDesc.klass, "path", VALUEFUNC(_wrap_FileDesc_path_get), -1);
  rb_define_method(SwigClassFileDesc.klass, "mode=", VALUEFUNC(_wrap_FileDesc_mode_set), -1);
  rb_define_method(SwigClassFileDesc.klass, "mode", VALUEFUNC(_wrap_FileDesc_mode_get), -1);
  rb_define_method(SwigClassFileDesc.klass, "perms=", VALUEFUNC(_wrap_FileDesc_perms_set), -1);
  rb_define_method(SwigClassFileDesc.klass, "perms", VALUEFUNC(_wrap_FileDesc_perms_get), -1);
  rb_define_method(SwigClassFileDesc.klass, "tryDowngrade=", VALUEFUNC(_wrap_FileDesc_tryDowngrade_set), -1);
  rb_define_method(SwigClassFileDesc.klass, "tryDowngrade", VALUEFUNC(_wrap_FileDesc_tryDowngrade_get), -1);
  SwigClassFileDesc.mark = 0;
  SwigClassFileDesc.trackObjects = 0;
  
  SwigClassFileMgr.klass = rb_define_class_under(mSword, "FileMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__FileMgr, (void *) &SwigClassFileMgr);
  rb_define_alloc_func(SwigClassFileMgr.klass, _wrap_FileMgr_allocate);
  rb_define_method(SwigClassFileMgr.klass, "initialize", VALUEFUNC(_wrap_new_FileMgr), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "CREAT", VALUEFUNC(_wrap_FileMgr_CREAT_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "CREAT=", VALUEFUNC(_wrap_FileMgr_CREAT_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "APPEND", VALUEFUNC(_wrap_FileMgr_APPEND_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "APPEND=", VALUEFUNC(_wrap_FileMgr_APPEND_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "TRUNC", VALUEFUNC(_wrap_FileMgr_TRUNC_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "TRUNC=", VALUEFUNC(_wrap_FileMgr_TRUNC_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "RDONLY", VALUEFUNC(_wrap_FileMgr_RDONLY_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "RDONLY=", VALUEFUNC(_wrap_FileMgr_RDONLY_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "RDWR", VALUEFUNC(_wrap_FileMgr_RDWR_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "RDWR=", VALUEFUNC(_wrap_FileMgr_RDWR_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "WRONLY", VALUEFUNC(_wrap_FileMgr_WRONLY_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "WRONLY=", VALUEFUNC(_wrap_FileMgr_WRONLY_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "IREAD", VALUEFUNC(_wrap_FileMgr_IREAD_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "IREAD=", VALUEFUNC(_wrap_FileMgr_IREAD_set), 1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "IWRITE", VALUEFUNC(_wrap_FileMgr_IWRITE_get), 0);
  rb_define_singleton_method(SwigClassFileMgr.klass, "IWRITE=", VALUEFUNC(_wrap_FileMgr_IWRITE_set), 1);
  rb_define_method(SwigClassFileMgr.klass, "maxFiles=", VALUEFUNC(_wrap_FileMgr_maxFiles_set), -1);
  rb_define_method(SwigClassFileMgr.klass, "maxFiles", VALUEFUNC(_wrap_FileMgr_maxFiles_get), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "getSystemFileMgr", VALUEFUNC(_wrap_FileMgr_getSystemFileMgr), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "setSystemFileMgr", VALUEFUNC(_wrap_FileMgr_setSystemFileMgr), -1);
  rb_define_method(SwigClassFileMgr.klass, "open", VALUEFUNC(_wrap_FileMgr_open), -1);
  rb_define_method(SwigClassFileMgr.klass, "close", VALUEFUNC(_wrap_FileMgr_close), -1);
  rb_define_method(SwigClassFileMgr.klass, "flush", VALUEFUNC(_wrap_FileMgr_flush), -1);
  rb_define_method(SwigClassFileMgr.klass, "resourceConsumption", VALUEFUNC(_wrap_FileMgr_resourceConsumption), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "existsFile", VALUEFUNC(_wrap_FileMgr_existsFile), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "existsDir", VALUEFUNC(_wrap_FileMgr_existsDir), -1);
  rb_define_method(SwigClassFileMgr.klass, "trunc", VALUEFUNC(_wrap_FileMgr_trunc), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "isDirectory", VALUEFUNC(_wrap_FileMgr_isDirectory), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "createParent", VALUEFUNC(_wrap_FileMgr_createParent), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "createPathAndFile", VALUEFUNC(_wrap_FileMgr_createPathAndFile), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "openFileReadOnly", VALUEFUNC(_wrap_FileMgr_openFileReadOnly), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "copyFile", VALUEFUNC(_wrap_FileMgr_copyFile), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "copyDir", VALUEFUNC(_wrap_FileMgr_copyDir), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "removeDir", VALUEFUNC(_wrap_FileMgr_removeDir), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "removeFile", VALUEFUNC(_wrap_FileMgr_removeFile), -1);
  rb_define_singleton_method(SwigClassFileMgr.klass, "getLine", VALUEFUNC(_wrap_FileMgr_getLine), -1);
  SwigClassFileMgr.mark = 0;
  SwigClassFileMgr.destroy = (void (*)(void *)) free_sword_FileMgr;
  SwigClassFileMgr.trackObjects = 0;
  
  SwigClassEncodingFilterMgr.klass = rb_define_class_under(mSword, "EncodingFilterMgr", ((swig_class *) SWIGTYPE_p_sword__SWFilterMgr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__EncodingFilterMgr, (void *) &SwigClassEncodingFilterMgr);
  rb_define_alloc_func(SwigClassEncodingFilterMgr.klass, _wrap_EncodingFilterMgr_allocate);
  rb_define_method(SwigClassEncodingFilterMgr.klass, "initialize", VALUEFUNC(_wrap_new_EncodingFilterMgr), -1);
  rb_define_method(SwigClassEncodingFilterMgr.klass, "Encoding", VALUEFUNC(_wrap_EncodingFilterMgr_Encoding), -1);
  rb_define_singleton_method(SwigClassEncodingFilterMgr.klass, "castTo", VALUEFUNC(_wrap_EncodingFilterMgr_castTo), -1);
  SwigClassEncodingFilterMgr.mark = 0;
  SwigClassEncodingFilterMgr.destroy = (void (*)(void *)) free_sword_EncodingFilterMgr;
  SwigClassEncodingFilterMgr.trackObjects = 0;
  
  SwigClassMarkupFilterMgr.klass = rb_define_class_under(mSword, "MarkupFilterMgr", ((swig_class *) SWIGTYPE_p_sword__EncodingFilterMgr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__MarkupFilterMgr, (void *) &SwigClassMarkupFilterMgr);
  rb_define_alloc_func(SwigClassMarkupFilterMgr.klass, _wrap_MarkupFilterMgr_allocate);
  rb_define_method(SwigClassMarkupFilterMgr.klass, "initialize", VALUEFUNC(_wrap_new_MarkupFilterMgr), -1);
  rb_define_method(SwigClassMarkupFilterMgr.klass, "Markup", VALUEFUNC(_wrap_MarkupFilterMgr_Markup), -1);
  rb_define_singleton_method(SwigClassMarkupFilterMgr.klass, "castTo", VALUEFUNC(_wrap_MarkupFilterMgr_castTo), -1);
  SwigClassMarkupFilterMgr.mark = 0;
  SwigClassMarkupFilterMgr.destroy = (void (*)(void *)) free_sword_MarkupFilterMgr;
  SwigClassMarkupFilterMgr.trackObjects = 0;
  rb_define_singleton_method(mSword, "ENDOFABBREVS", VALUEFUNC(_wrap_ENDOFABBREVS_get), 0);
  
  SwigClassSWLocale.klass = rb_define_class_under(mSword, "SWLocale", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWLocale, (void *) &SwigClassSWLocale);
  rb_define_alloc_func(SwigClassSWLocale.klass, _wrap_SWLocale_allocate);
  rb_define_method(SwigClassSWLocale.klass, "initialize", VALUEFUNC(_wrap_new_SWLocale), -1);
  rb_define_method(SwigClassSWLocale.klass, "getName", VALUEFUNC(_wrap_SWLocale_getName), -1);
  rb_define_method(SwigClassSWLocale.klass, "getDescription", VALUEFUNC(_wrap_SWLocale_getDescription), -1);
  rb_define_method(SwigClassSWLocale.klass, "getEncoding", VALUEFUNC(_wrap_SWLocale_getEncoding), -1);
  rb_define_method(SwigClassSWLocale.klass, "translate", VALUEFUNC(_wrap_SWLocale_translate), -1);
  rb_define_method(SwigClassSWLocale.klass, "augment", VALUEFUNC(_wrap_SWLocale_augment), -1);
  rb_define_singleton_method(SwigClassSWLocale.klass, "DEFAULT_LOCALE_NAME", VALUEFUNC(_wrap_SWLocale_DEFAULT_LOCALE_NAME_get), 0);
  rb_define_singleton_method(SwigClassSWLocale.klass, "DEFAULT_LOCALE_NAME=", VALUEFUNC(_wrap_SWLocale_DEFAULT_LOCALE_NAME_set), 1);
  rb_define_method(SwigClassSWLocale.klass, "getBookAbbrevs", VALUEFUNC(_wrap_SWLocale_getBookAbbrevs), -1);
  SwigClassSWLocale.mark = 0;
  SwigClassSWLocale.destroy = (void (*)(void *)) free_sword_SWLocale;
  SwigClassSWLocale.trackObjects = 0;
  
  SwigClassSWCompress.klass = rb_define_class_under(mSword, "SWCompress", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWCompress, (void *) &SwigClassSWCompress);
  rb_define_alloc_func(SwigClassSWCompress.klass, _wrap_SWCompress_allocate);
  rb_define_method(SwigClassSWCompress.klass, "initialize", VALUEFUNC(_wrap_new_SWCompress), -1);
  rb_define_method(SwigClassSWCompress.klass, "Encode", VALUEFUNC(_wrap_SWCompress_Encode), -1);
  rb_define_method(SwigClassSWCompress.klass, "Decode", VALUEFUNC(_wrap_SWCompress_Decode), -1);
  SwigClassSWCompress.mark = 0;
  SwigClassSWCompress.destroy = (void (*)(void *)) free_sword_SWCompress;
  SwigClassSWCompress.trackObjects = 0;
  rb_define_const(mSword, "N", SWIG_From_int(static_cast< int >(4096)));
  rb_define_const(mSword, "F", SWIG_From_int(static_cast< int >(18)));
  rb_define_const(mSword, "THRESHOLD", SWIG_From_int(static_cast< int >(3)));
  rb_define_const(mSword, "NOT_USED", SWIG_From_int(static_cast< int >(4096)));
  
  SwigClassLZSSCompress.klass = rb_define_class_under(mSword, "LZSSCompress", ((swig_class *) SWIGTYPE_p_sword__SWCompress->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__LZSSCompress, (void *) &SwigClassLZSSCompress);
  rb_define_alloc_func(SwigClassLZSSCompress.klass, _wrap_LZSSCompress_allocate);
  rb_define_method(SwigClassLZSSCompress.klass, "initialize", VALUEFUNC(_wrap_new_LZSSCompress), -1);
  rb_define_method(SwigClassLZSSCompress.klass, "Encode", VALUEFUNC(_wrap_LZSSCompress_Encode), -1);
  rb_define_method(SwigClassLZSSCompress.klass, "Decode", VALUEFUNC(_wrap_LZSSCompress_Decode), -1);
  rb_define_singleton_method(SwigClassLZSSCompress.klass, "castTo", VALUEFUNC(_wrap_LZSSCompress_castTo), -1);
  SwigClassLZSSCompress.mark = 0;
  SwigClassLZSSCompress.destroy = (void (*)(void *)) free_sword_LZSSCompress;
  SwigClassLZSSCompress.trackObjects = 0;
  
  SwigClassZipCompress.klass = rb_define_class_under(mSword, "ZipCompress", ((swig_class *) SWIGTYPE_p_sword__SWCompress->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__ZipCompress, (void *) &SwigClassZipCompress);
  rb_define_alloc_func(SwigClassZipCompress.klass, _wrap_ZipCompress_allocate);
  rb_define_method(SwigClassZipCompress.klass, "initialize", VALUEFUNC(_wrap_new_ZipCompress), -1);
  rb_define_method(SwigClassZipCompress.klass, "Encode", VALUEFUNC(_wrap_ZipCompress_Encode), -1);
  rb_define_method(SwigClassZipCompress.klass, "Decode", VALUEFUNC(_wrap_ZipCompress_Decode), -1);
  rb_define_singleton_method(SwigClassZipCompress.klass, "castTo", VALUEFUNC(_wrap_ZipCompress_castTo), -1);
  SwigClassZipCompress.mark = 0;
  SwigClassZipCompress.destroy = (void (*)(void *)) free_sword_ZipCompress;
  SwigClassZipCompress.trackObjects = 0;
  
  SwigClassSWCom.klass = rb_define_class_under(mSword, "SWCom", ((swig_class *) SWIGTYPE_p_sword__SWModule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWCom, (void *) &SwigClassSWCom);
  rb_undef_alloc_func(SwigClassSWCom.klass);
  rb_define_method(SwigClassSWCom.klass, "CreateKey", VALUEFUNC(_wrap_SWCom_CreateKey), -1);
  rb_define_method(SwigClassSWCom.klass, "getIndex", VALUEFUNC(_wrap_SWCom_getIndex), -1);
  rb_define_method(SwigClassSWCom.klass, "setIndex", VALUEFUNC(_wrap_SWCom_setIndex), -1);
  rb_define_method(SwigClassSWCom.klass, "<<", VALUEFUNC(_wrap_SWCom___lshift__), -1);
  rb_define_singleton_method(SwigClassSWCom.klass, "castTo", VALUEFUNC(_wrap_SWCom_castTo), -1);
  SwigClassSWCom.mark = 0;
  SwigClassSWCom.destroy = (void (*)(void *)) free_sword_SWCom;
  SwigClassSWCom.trackObjects = 0;
  
  SwigClassRawCom.klass = rb_define_class_under(mSword, "RawCom", ((swig_class *) SWIGTYPE_p_sword__RawVerse->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawCom, (void *) &SwigClassRawCom);
  rb_define_alloc_func(SwigClassRawCom.klass, _wrap_RawCom_allocate);
  rb_define_method(SwigClassRawCom.klass, "initialize", VALUEFUNC(_wrap_new_RawCom), -1);
  rb_define_method(SwigClassRawCom.klass, "getRawEntryBuf", VALUEFUNC(_wrap_RawCom_getRawEntryBuf), -1);
  rb_define_method(SwigClassRawCom.klass, "increment", VALUEFUNC(_wrap_RawCom_increment), -1);
  rb_define_method(SwigClassRawCom.klass, "decrement", VALUEFUNC(_wrap_RawCom_decrement), -1);
  rb_define_method(SwigClassRawCom.klass, "isWritable", VALUEFUNC(_wrap_RawCom_isWritable), -1);
  rb_define_singleton_method(SwigClassRawCom.klass, "createModule", VALUEFUNC(_wrap_RawCom_createModule), -1);
  rb_define_method(SwigClassRawCom.klass, "setEntry", VALUEFUNC(_wrap_RawCom_setEntry), -1);
  rb_define_method(SwigClassRawCom.klass, "linkEntry", VALUEFUNC(_wrap_RawCom_linkEntry), -1);
  rb_define_method(SwigClassRawCom.klass, "deleteEntry", VALUEFUNC(_wrap_RawCom_deleteEntry), -1);
  rb_define_method(SwigClassRawCom.klass, "isLinked", VALUEFUNC(_wrap_RawCom_isLinked), -1);
  rb_define_method(SwigClassRawCom.klass, "hasEntry", VALUEFUNC(_wrap_RawCom_hasEntry), -1);
  rb_define_method(SwigClassRawCom.klass, "<<", VALUEFUNC(_wrap_RawCom___lshift__), -1);
  rb_define_singleton_method(SwigClassRawCom.klass, "castTo", VALUEFUNC(_wrap_RawCom_castTo), -1);
  SwigClassRawCom.mark = 0;
  SwigClassRawCom.destroy = (void (*)(void *)) free_sword_RawCom;
  SwigClassRawCom.trackObjects = 0;
  
  SwigClassZCom.klass = rb_define_class_under(mSword, "ZCom", ((swig_class *) SWIGTYPE_p_sword__zVerse->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__zCom, (void *) &SwigClassZCom);
  rb_define_alloc_func(SwigClassZCom.klass, _wrap_zCom_allocate);
  rb_define_method(SwigClassZCom.klass, "initialize", VALUEFUNC(_wrap_new_zCom), -1);
  rb_define_method(SwigClassZCom.klass, "getRawEntryBuf", VALUEFUNC(_wrap_zCom_getRawEntryBuf), -1);
  rb_define_method(SwigClassZCom.klass, "increment", VALUEFUNC(_wrap_zCom_increment), -1);
  rb_define_method(SwigClassZCom.klass, "decrement", VALUEFUNC(_wrap_zCom_decrement), -1);
  rb_define_method(SwigClassZCom.klass, "isWritable", VALUEFUNC(_wrap_zCom_isWritable), -1);
  rb_define_singleton_method(SwigClassZCom.klass, "createModule", VALUEFUNC(_wrap_zCom_createModule), -1);
  rb_define_method(SwigClassZCom.klass, "setEntry", VALUEFUNC(_wrap_zCom_setEntry), -1);
  rb_define_method(SwigClassZCom.klass, "linkEntry", VALUEFUNC(_wrap_zCom_linkEntry), -1);
  rb_define_method(SwigClassZCom.klass, "deleteEntry", VALUEFUNC(_wrap_zCom_deleteEntry), -1);
  rb_define_method(SwigClassZCom.klass, "rawZFilter", VALUEFUNC(_wrap_zCom_rawZFilter), -1);
  rb_define_method(SwigClassZCom.klass, "flush", VALUEFUNC(_wrap_zCom_flush), -1);
  rb_define_method(SwigClassZCom.klass, "isLinked", VALUEFUNC(_wrap_zCom_isLinked), -1);
  rb_define_method(SwigClassZCom.klass, "hasEntry", VALUEFUNC(_wrap_zCom_hasEntry), -1);
  rb_define_method(SwigClassZCom.klass, "<<", VALUEFUNC(_wrap_zCom___lshift__), -1);
  rb_define_singleton_method(SwigClassZCom.klass, "castTo", VALUEFUNC(_wrap_zCom_castTo), -1);
  SwigClassZCom.mark = 0;
  SwigClassZCom.destroy = (void (*)(void *)) free_sword_zCom;
  SwigClassZCom.trackObjects = 0;
  
  SwigClassSWGenBook.klass = rb_define_class_under(mSword, "SWGenBook", ((swig_class *) SWIGTYPE_p_sword__SWModule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWGenBook, (void *) &SwigClassSWGenBook);
  rb_undef_alloc_func(SwigClassSWGenBook.klass);
  rb_define_method(SwigClassSWGenBook.klass, "CreateKey", VALUEFUNC(_wrap_SWGenBook_CreateKey), -1);
  rb_define_method(SwigClassSWGenBook.klass, "<<", VALUEFUNC(_wrap_SWGenBook___lshift__), -1);
  rb_define_singleton_method(SwigClassSWGenBook.klass, "castTo", VALUEFUNC(_wrap_SWGenBook_castTo), -1);
  SwigClassSWGenBook.mark = 0;
  SwigClassSWGenBook.destroy = (void (*)(void *)) free_sword_SWGenBook;
  SwigClassSWGenBook.trackObjects = 0;
  
  SwigClassRawGenBook.klass = rb_define_class_under(mSword, "RawGenBook", ((swig_class *) SWIGTYPE_p_sword__SWGenBook->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawGenBook, (void *) &SwigClassRawGenBook);
  rb_define_alloc_func(SwigClassRawGenBook.klass, _wrap_RawGenBook_allocate);
  rb_define_method(SwigClassRawGenBook.klass, "initialize", VALUEFUNC(_wrap_new_RawGenBook), -1);
  rb_define_method(SwigClassRawGenBook.klass, "getRawEntryBuf", VALUEFUNC(_wrap_RawGenBook_getRawEntryBuf), -1);
  rb_define_method(SwigClassRawGenBook.klass, "isWritable", VALUEFUNC(_wrap_RawGenBook_isWritable), -1);
  rb_define_singleton_method(SwigClassRawGenBook.klass, "createModule", VALUEFUNC(_wrap_RawGenBook_createModule), -1);
  rb_define_method(SwigClassRawGenBook.klass, "setEntry", VALUEFUNC(_wrap_RawGenBook_setEntry), -1);
  rb_define_method(SwigClassRawGenBook.klass, "linkEntry", VALUEFUNC(_wrap_RawGenBook_linkEntry), -1);
  rb_define_method(SwigClassRawGenBook.klass, "deleteEntry", VALUEFUNC(_wrap_RawGenBook_deleteEntry), -1);
  rb_define_method(SwigClassRawGenBook.klass, "CreateKey", VALUEFUNC(_wrap_RawGenBook_CreateKey), -1);
  rb_define_method(SwigClassRawGenBook.klass, "hasEntry", VALUEFUNC(_wrap_RawGenBook_hasEntry), -1);
  rb_define_method(SwigClassRawGenBook.klass, "<<", VALUEFUNC(_wrap_RawGenBook___lshift__), -1);
  rb_define_singleton_method(SwigClassRawGenBook.klass, "castTo", VALUEFUNC(_wrap_RawGenBook_castTo), -1);
  SwigClassRawGenBook.mark = 0;
  SwigClassRawGenBook.destroy = (void (*)(void *)) free_sword_RawGenBook;
  SwigClassRawGenBook.trackObjects = 0;
  
  SwigClassSWLD.klass = rb_define_class_under(mSword, "SWLD", ((swig_class *) SWIGTYPE_p_sword__SWModule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWLD, (void *) &SwigClassSWLD);
  rb_undef_alloc_func(SwigClassSWLD.klass);
  rb_define_method(SwigClassSWLD.klass, "CreateKey", VALUEFUNC(_wrap_SWLD_CreateKey), -1);
  rb_define_method(SwigClassSWLD.klass, "KeyText", VALUEFUNC(_wrap_SWLD_KeyText), -1);
  rb_define_method(SwigClassSWLD.klass, "setPosition", VALUEFUNC(_wrap_SWLD_setPosition), -1);
  rb_define_method(SwigClassSWLD.klass, "getEntryCount", VALUEFUNC(_wrap_SWLD_getEntryCount), -1);
  rb_define_method(SwigClassSWLD.klass, "getEntryForKey", VALUEFUNC(_wrap_SWLD_getEntryForKey), -1);
  rb_define_method(SwigClassSWLD.klass, "getKeyForEntry", VALUEFUNC(_wrap_SWLD_getKeyForEntry), -1);
  rb_define_method(SwigClassSWLD.klass, "hasEntry", VALUEFUNC(_wrap_SWLD_hasEntry), -1);
  rb_define_method(SwigClassSWLD.klass, "<<", VALUEFUNC(_wrap_SWLD___lshift__), -1);
  rb_define_singleton_method(SwigClassSWLD.klass, "castTo", VALUEFUNC(_wrap_SWLD_castTo), -1);
  SwigClassSWLD.mark = 0;
  SwigClassSWLD.destroy = (void (*)(void *)) free_sword_SWLD;
  SwigClassSWLD.trackObjects = 0;
  
  SwigClassRawLD.klass = rb_define_class_under(mSword, "RawLD", ((swig_class *) SWIGTYPE_p_sword__RawStr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawLD, (void *) &SwigClassRawLD);
  rb_define_alloc_func(SwigClassRawLD.klass, _wrap_RawLD_allocate);
  rb_define_method(SwigClassRawLD.klass, "initialize", VALUEFUNC(_wrap_new_RawLD), -1);
  rb_define_method(SwigClassRawLD.klass, "getRawEntryBuf", VALUEFUNC(_wrap_RawLD_getRawEntryBuf), -1);
  rb_define_method(SwigClassRawLD.klass, "increment", VALUEFUNC(_wrap_RawLD_increment), -1);
  rb_define_method(SwigClassRawLD.klass, "decrement", VALUEFUNC(_wrap_RawLD_decrement), -1);
  rb_define_method(SwigClassRawLD.klass, "isWritable", VALUEFUNC(_wrap_RawLD_isWritable), -1);
  rb_define_singleton_method(SwigClassRawLD.klass, "createModule", VALUEFUNC(_wrap_RawLD_createModule), -1);
  rb_define_method(SwigClassRawLD.klass, "setEntry", VALUEFUNC(_wrap_RawLD_setEntry), -1);
  rb_define_method(SwigClassRawLD.klass, "linkEntry", VALUEFUNC(_wrap_RawLD_linkEntry), -1);
  rb_define_method(SwigClassRawLD.klass, "deleteEntry", VALUEFUNC(_wrap_RawLD_deleteEntry), -1);
  rb_define_method(SwigClassRawLD.klass, "getEntryCount", VALUEFUNC(_wrap_RawLD_getEntryCount), -1);
  rb_define_method(SwigClassRawLD.klass, "getEntryForKey", VALUEFUNC(_wrap_RawLD_getEntryForKey), -1);
  rb_define_method(SwigClassRawLD.klass, "getKeyForEntry", VALUEFUNC(_wrap_RawLD_getKeyForEntry), -1);
  rb_define_method(SwigClassRawLD.klass, "<<", VALUEFUNC(_wrap_RawLD___lshift__), -1);
  rb_define_singleton_method(SwigClassRawLD.klass, "castTo", VALUEFUNC(_wrap_RawLD_castTo), -1);
  SwigClassRawLD.mark = 0;
  SwigClassRawLD.destroy = (void (*)(void *)) free_sword_RawLD;
  SwigClassRawLD.trackObjects = 0;
  
  SwigClassRawLD4.klass = rb_define_class_under(mSword, "RawLD4", ((swig_class *) SWIGTYPE_p_sword__RawStr4->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawLD4, (void *) &SwigClassRawLD4);
  rb_define_alloc_func(SwigClassRawLD4.klass, _wrap_RawLD4_allocate);
  rb_define_method(SwigClassRawLD4.klass, "initialize", VALUEFUNC(_wrap_new_RawLD4), -1);
  rb_define_method(SwigClassRawLD4.klass, "getRawEntryBuf", VALUEFUNC(_wrap_RawLD4_getRawEntryBuf), -1);
  rb_define_method(SwigClassRawLD4.klass, "increment", VALUEFUNC(_wrap_RawLD4_increment), -1);
  rb_define_method(SwigClassRawLD4.klass, "decrement", VALUEFUNC(_wrap_RawLD4_decrement), -1);
  rb_define_method(SwigClassRawLD4.klass, "isWritable", VALUEFUNC(_wrap_RawLD4_isWritable), -1);
  rb_define_singleton_method(SwigClassRawLD4.klass, "createModule", VALUEFUNC(_wrap_RawLD4_createModule), -1);
  rb_define_method(SwigClassRawLD4.klass, "setEntry", VALUEFUNC(_wrap_RawLD4_setEntry), -1);
  rb_define_method(SwigClassRawLD4.klass, "linkEntry", VALUEFUNC(_wrap_RawLD4_linkEntry), -1);
  rb_define_method(SwigClassRawLD4.klass, "deleteEntry", VALUEFUNC(_wrap_RawLD4_deleteEntry), -1);
  rb_define_method(SwigClassRawLD4.klass, "getEntryCount", VALUEFUNC(_wrap_RawLD4_getEntryCount), -1);
  rb_define_method(SwigClassRawLD4.klass, "getEntryForKey", VALUEFUNC(_wrap_RawLD4_getEntryForKey), -1);
  rb_define_method(SwigClassRawLD4.klass, "getKeyForEntry", VALUEFUNC(_wrap_RawLD4_getKeyForEntry), -1);
  rb_define_method(SwigClassRawLD4.klass, "<<", VALUEFUNC(_wrap_RawLD4___lshift__), -1);
  rb_define_singleton_method(SwigClassRawLD4.klass, "castTo", VALUEFUNC(_wrap_RawLD4_castTo), -1);
  SwigClassRawLD4.mark = 0;
  SwigClassRawLD4.destroy = (void (*)(void *)) free_sword_RawLD4;
  SwigClassRawLD4.trackObjects = 0;
  
  SwigClassZLD.klass = rb_define_class_under(mSword, "ZLD", ((swig_class *) SWIGTYPE_p_sword__zStr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__zLD, (void *) &SwigClassZLD);
  rb_define_alloc_func(SwigClassZLD.klass, _wrap_zLD_allocate);
  rb_define_method(SwigClassZLD.klass, "initialize", VALUEFUNC(_wrap_new_zLD), -1);
  rb_define_method(SwigClassZLD.klass, "getRawEntryBuf", VALUEFUNC(_wrap_zLD_getRawEntryBuf), -1);
  rb_define_method(SwigClassZLD.klass, "increment", VALUEFUNC(_wrap_zLD_increment), -1);
  rb_define_method(SwigClassZLD.klass, "decrement", VALUEFUNC(_wrap_zLD_decrement), -1);
  rb_define_method(SwigClassZLD.klass, "isWritable", VALUEFUNC(_wrap_zLD_isWritable), -1);
  rb_define_singleton_method(SwigClassZLD.klass, "createModule", VALUEFUNC(_wrap_zLD_createModule), -1);
  rb_define_method(SwigClassZLD.klass, "setEntry", VALUEFUNC(_wrap_zLD_setEntry), -1);
  rb_define_method(SwigClassZLD.klass, "linkEntry", VALUEFUNC(_wrap_zLD_linkEntry), -1);
  rb_define_method(SwigClassZLD.klass, "deleteEntry", VALUEFUNC(_wrap_zLD_deleteEntry), -1);
  rb_define_method(SwigClassZLD.klass, "rawZFilter", VALUEFUNC(_wrap_zLD_rawZFilter), -1);
  rb_define_method(SwigClassZLD.klass, "flush", VALUEFUNC(_wrap_zLD_flush), -1);
  rb_define_method(SwigClassZLD.klass, "getEntryCount", VALUEFUNC(_wrap_zLD_getEntryCount), -1);
  rb_define_method(SwigClassZLD.klass, "getEntryForKey", VALUEFUNC(_wrap_zLD_getEntryForKey), -1);
  rb_define_method(SwigClassZLD.klass, "getKeyForEntry", VALUEFUNC(_wrap_zLD_getKeyForEntry), -1);
  rb_define_method(SwigClassZLD.klass, "<<", VALUEFUNC(_wrap_zLD___lshift__), -1);
  rb_define_singleton_method(SwigClassZLD.klass, "castTo", VALUEFUNC(_wrap_zLD_castTo), -1);
  SwigClassZLD.mark = 0;
  SwigClassZLD.destroy = (void (*)(void *)) free_sword_zLD;
  SwigClassZLD.trackObjects = 0;
  
  SwigClassSWText.klass = rb_define_class_under(mSword, "SWText", ((swig_class *) SWIGTYPE_p_sword__SWModule->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWText, (void *) &SwigClassSWText);
  rb_undef_alloc_func(SwigClassSWText.klass);
  rb_define_method(SwigClassSWText.klass, "CreateKey", VALUEFUNC(_wrap_SWText_CreateKey), -1);
  rb_define_method(SwigClassSWText.klass, "getIndex", VALUEFUNC(_wrap_SWText_getIndex), -1);
  rb_define_method(SwigClassSWText.klass, "setIndex", VALUEFUNC(_wrap_SWText_setIndex), -1);
  rb_define_method(SwigClassSWText.klass, "<<", VALUEFUNC(_wrap_SWText___lshift__), -1);
  rb_define_singleton_method(SwigClassSWText.klass, "castTo", VALUEFUNC(_wrap_SWText_castTo), -1);
  SwigClassSWText.mark = 0;
  SwigClassSWText.destroy = (void (*)(void *)) free_sword_SWText;
  SwigClassSWText.trackObjects = 0;
  
  SwigClassRawText.klass = rb_define_class_under(mSword, "RawText", ((swig_class *) SWIGTYPE_p_sword__SWText->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__RawText, (void *) &SwigClassRawText);
  rb_define_alloc_func(SwigClassRawText.klass, _wrap_RawText_allocate);
  rb_define_method(SwigClassRawText.klass, "initialize", VALUEFUNC(_wrap_new_RawText), -1);
  rb_define_method(SwigClassRawText.klass, "getRawEntryBuf", VALUEFUNC(_wrap_RawText_getRawEntryBuf), -1);
  rb_define_method(SwigClassRawText.klass, "increment", VALUEFUNC(_wrap_RawText_increment), -1);
  rb_define_method(SwigClassRawText.klass, "decrement", VALUEFUNC(_wrap_RawText_decrement), -1);
  rb_define_method(SwigClassRawText.klass, "isWritable", VALUEFUNC(_wrap_RawText_isWritable), -1);
  rb_define_singleton_method(SwigClassRawText.klass, "createModule", VALUEFUNC(_wrap_RawText_createModule), -1);
  rb_define_method(SwigClassRawText.klass, "setEntry", VALUEFUNC(_wrap_RawText_setEntry), -1);
  rb_define_method(SwigClassRawText.klass, "linkEntry", VALUEFUNC(_wrap_RawText_linkEntry), -1);
  rb_define_method(SwigClassRawText.klass, "deleteEntry", VALUEFUNC(_wrap_RawText_deleteEntry), -1);
  rb_define_method(SwigClassRawText.klass, "isLinked", VALUEFUNC(_wrap_RawText_isLinked), -1);
  rb_define_method(SwigClassRawText.klass, "hasEntry", VALUEFUNC(_wrap_RawText_hasEntry), -1);
  rb_define_method(SwigClassRawText.klass, "<<", VALUEFUNC(_wrap_RawText___lshift__), -1);
  rb_define_singleton_method(SwigClassRawText.klass, "castTo", VALUEFUNC(_wrap_RawText_castTo), -1);
  SwigClassRawText.mark = 0;
  SwigClassRawText.destroy = (void (*)(void *)) free_sword_RawText;
  SwigClassRawText.trackObjects = 0;
  
  SwigClassZText.klass = rb_define_class_under(mSword, "ZText", ((swig_class *) SWIGTYPE_p_sword__zVerse->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__zText, (void *) &SwigClassZText);
  rb_define_alloc_func(SwigClassZText.klass, _wrap_zText_allocate);
  rb_define_method(SwigClassZText.klass, "initialize", VALUEFUNC(_wrap_new_zText), -1);
  rb_define_method(SwigClassZText.klass, "getRawEntryBuf", VALUEFUNC(_wrap_zText_getRawEntryBuf), -1);
  rb_define_method(SwigClassZText.klass, "increment", VALUEFUNC(_wrap_zText_increment), -1);
  rb_define_method(SwigClassZText.klass, "decrement", VALUEFUNC(_wrap_zText_decrement), -1);
  rb_define_method(SwigClassZText.klass, "isWritable", VALUEFUNC(_wrap_zText_isWritable), -1);
  rb_define_singleton_method(SwigClassZText.klass, "createModule", VALUEFUNC(_wrap_zText_createModule), -1);
  rb_define_method(SwigClassZText.klass, "setEntry", VALUEFUNC(_wrap_zText_setEntry), -1);
  rb_define_method(SwigClassZText.klass, "linkEntry", VALUEFUNC(_wrap_zText_linkEntry), -1);
  rb_define_method(SwigClassZText.klass, "deleteEntry", VALUEFUNC(_wrap_zText_deleteEntry), -1);
  rb_define_method(SwigClassZText.klass, "rawZFilter", VALUEFUNC(_wrap_zText_rawZFilter), -1);
  rb_define_method(SwigClassZText.klass, "flush", VALUEFUNC(_wrap_zText_flush), -1);
  rb_define_method(SwigClassZText.klass, "isLinked", VALUEFUNC(_wrap_zText_isLinked), -1);
  rb_define_method(SwigClassZText.klass, "hasEntry", VALUEFUNC(_wrap_zText_hasEntry), -1);
  rb_define_method(SwigClassZText.klass, "<<", VALUEFUNC(_wrap_zText___lshift__), -1);
  rb_define_singleton_method(SwigClassZText.klass, "castTo", VALUEFUNC(_wrap_zText_castTo), -1);
  SwigClassZText.mark = 0;
  SwigClassZText.destroy = (void (*)(void *)) free_sword_zText;
  SwigClassZText.trackObjects = 0;
  
  SwigClassLocaleMgr.klass = rb_define_class_under(mSword, "LocaleMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__LocaleMgr, (void *) &SwigClassLocaleMgr);
  rb_define_alloc_func(SwigClassLocaleMgr.klass, _wrap_LocaleMgr_allocate);
  rb_define_method(SwigClassLocaleMgr.klass, "initialize", VALUEFUNC(_wrap_new_LocaleMgr), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "getLocale", VALUEFUNC(_wrap_LocaleMgr_getLocale), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "getAvailableLocales", VALUEFUNC(_wrap_LocaleMgr_getAvailableLocales), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "translate", VALUEFUNC(_wrap_LocaleMgr_translate), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "getDefaultLocaleName", VALUEFUNC(_wrap_LocaleMgr_getDefaultLocaleName), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "setDefaultLocaleName", VALUEFUNC(_wrap_LocaleMgr_setDefaultLocaleName), -1);
  rb_define_singleton_method(SwigClassLocaleMgr.klass, "getSystemLocaleMgr", VALUEFUNC(_wrap_LocaleMgr_getSystemLocaleMgr), -1);
  rb_define_singleton_method(SwigClassLocaleMgr.klass, "setSystemLocaleMgr", VALUEFUNC(_wrap_LocaleMgr_setSystemLocaleMgr), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "loadConfigDir", VALUEFUNC(_wrap_LocaleMgr_loadConfigDir), -1);
  rb_define_method(SwigClassLocaleMgr.klass, "getAvailableLocalesVector", VALUEFUNC(_wrap_LocaleMgr_getAvailableLocalesVector), -1);
  SwigClassLocaleMgr.mark = 0;
  SwigClassLocaleMgr.destroy = (void (*)(void *)) free_sword_LocaleMgr;
  SwigClassLocaleMgr.trackObjects = 0;
  
  SwigClassURL.klass = rb_define_class_under(mSword, "URL", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__URL, (void *) &SwigClassURL);
  rb_define_alloc_func(SwigClassURL.klass, _wrap_URL_allocate);
  rb_define_method(SwigClassURL.klass, "initialize", VALUEFUNC(_wrap_new_URL), -1);
  rb_define_method(SwigClassURL.klass, "getProtocol", VALUEFUNC(_wrap_URL_getProtocol), -1);
  rb_define_method(SwigClassURL.klass, "getHostName", VALUEFUNC(_wrap_URL_getHostName), -1);
  rb_define_method(SwigClassURL.klass, "getPath", VALUEFUNC(_wrap_URL_getPath), -1);
  rb_define_method(SwigClassURL.klass, "getParameters", VALUEFUNC(_wrap_URL_getParameters), -1);
  rb_define_method(SwigClassURL.klass, "getParameterValue", VALUEFUNC(_wrap_URL_getParameterValue), -1);
  rb_define_singleton_method(SwigClassURL.klass, "encode", VALUEFUNC(_wrap_URL_encode), -1);
  rb_define_singleton_method(SwigClassURL.klass, "decode", VALUEFUNC(_wrap_URL_decode), -1);
  SwigClassURL.mark = 0;
  SwigClassURL.destroy = (void (*)(void *)) free_sword_URL;
  SwigClassURL.trackObjects = 0;
  
  SwigClassXMLTag.klass = rb_define_class_under(mSword, "XMLTag", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__XMLTag, (void *) &SwigClassXMLTag);
  rb_define_alloc_func(SwigClassXMLTag.klass, _wrap_XMLTag_allocate);
  rb_define_method(SwigClassXMLTag.klass, "initialize", VALUEFUNC(_wrap_new_XMLTag), -1);
  rb_define_method(SwigClassXMLTag.klass, "setText", VALUEFUNC(_wrap_XMLTag_setText), -1);
  rb_define_method(SwigClassXMLTag.klass, "getName", VALUEFUNC(_wrap_XMLTag_getName), -1);
  rb_define_method(SwigClassXMLTag.klass, "isEmpty", VALUEFUNC(_wrap_XMLTag_isEmpty), -1);
  rb_define_method(SwigClassXMLTag.klass, "setEmpty", VALUEFUNC(_wrap_XMLTag_setEmpty), -1);
  rb_define_method(SwigClassXMLTag.klass, "isEndTag", VALUEFUNC(_wrap_XMLTag_isEndTag), -1);
  rb_define_method(SwigClassXMLTag.klass, "getAttributeNames", VALUEFUNC(_wrap_XMLTag_getAttributeNames), -1);
  rb_define_method(SwigClassXMLTag.klass, "getAttributePartCount", VALUEFUNC(_wrap_XMLTag_getAttributePartCount), -1);
  rb_define_method(SwigClassXMLTag.klass, "getAttribute", VALUEFUNC(_wrap_XMLTag_getAttribute), -1);
  rb_define_method(SwigClassXMLTag.klass, "setAttribute", VALUEFUNC(_wrap_XMLTag_setAttribute), -1);
  rb_define_method(SwigClassXMLTag.klass, "toString", VALUEFUNC(_wrap_XMLTag_toString), -1);
  SwigClassXMLTag.mark = 0;
  SwigClassXMLTag.destroy = (void (*)(void *)) free_sword_XMLTag;
  SwigClassXMLTag.trackObjects = 0;
  
  SwigClassBasicFilterUserData.klass = rb_define_class_under(mSword, "BasicFilterUserData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__BasicFilterUserData, (void *) &SwigClassBasicFilterUserData);
  rb_define_alloc_func(SwigClassBasicFilterUserData.klass, _wrap_BasicFilterUserData_allocate);
  rb_define_method(SwigClassBasicFilterUserData.klass, "initialize", VALUEFUNC(_wrap_new_BasicFilterUserData), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "module=", VALUEFUNC(_wrap_BasicFilterUserData_module_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "module", VALUEFUNC(_wrap_BasicFilterUserData_module_get), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "key=", VALUEFUNC(_wrap_BasicFilterUserData_key_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "key", VALUEFUNC(_wrap_BasicFilterUserData_key_get), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "lastTextNode=", VALUEFUNC(_wrap_BasicFilterUserData_lastTextNode_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "lastTextNode", VALUEFUNC(_wrap_BasicFilterUserData_lastTextNode_get), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "lastSuspendSegment=", VALUEFUNC(_wrap_BasicFilterUserData_lastSuspendSegment_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "lastSuspendSegment", VALUEFUNC(_wrap_BasicFilterUserData_lastSuspendSegment_get), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "suspendTextPassThru=", VALUEFUNC(_wrap_BasicFilterUserData_suspendTextPassThru_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "suspendTextPassThru", VALUEFUNC(_wrap_BasicFilterUserData_suspendTextPassThru_get), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "supressAdjacentWhitespace=", VALUEFUNC(_wrap_BasicFilterUserData_supressAdjacentWhitespace_set), -1);
  rb_define_method(SwigClassBasicFilterUserData.klass, "supressAdjacentWhitespace", VALUEFUNC(_wrap_BasicFilterUserData_supressAdjacentWhitespace_get), -1);
  SwigClassBasicFilterUserData.mark = 0;
  SwigClassBasicFilterUserData.destroy = (void (*)(void *)) free_sword_BasicFilterUserData;
  SwigClassBasicFilterUserData.trackObjects = 0;
  
  SwigClassSWBasicFilter.klass = rb_define_class_under(mSword, "SWBasicFilter", ((swig_class *) SWIGTYPE_p_sword__SWFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWBasicFilter, (void *) &SwigClassSWBasicFilter);
  rb_define_alloc_func(SwigClassSWBasicFilter.klass, _wrap_SWBasicFilter_allocate);
  rb_define_method(SwigClassSWBasicFilter.klass, "initialize", VALUEFUNC(_wrap_new_SWBasicFilter), -1);
  rb_define_method(SwigClassSWBasicFilter.klass, "processText", VALUEFUNC(_wrap_SWBasicFilter_processText), -1);
  SwigClassSWBasicFilter.mark = 0;
  SwigClassSWBasicFilter.destroy = (void (*)(void *)) free_sword_SWBasicFilter;
  SwigClassSWBasicFilter.trackObjects = 0;
  
  SwigClassOSISHTMLHREF.klass = rb_define_class_under(mSword, "OSISHTMLHREF", ((swig_class *) SWIGTYPE_p_sword__SWBasicFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__OSISHTMLHREF, (void *) &SwigClassOSISHTMLHREF);
  rb_define_alloc_func(SwigClassOSISHTMLHREF.klass, _wrap_OSISHTMLHREF_allocate);
  rb_define_method(SwigClassOSISHTMLHREF.klass, "initialize", VALUEFUNC(_wrap_new_OSISHTMLHREF), -1);
  rb_define_method(SwigClassOSISHTMLHREF.klass, "setMorphFirst", VALUEFUNC(_wrap_OSISHTMLHREF_setMorphFirst), -1);
  SwigClassOSISHTMLHREF.mark = 0;
  SwigClassOSISHTMLHREF.destroy = (void (*)(void *)) free_sword_OSISHTMLHREF;
  SwigClassOSISHTMLHREF.trackObjects = 0;
  
  SwigClassPLAINHTML.klass = rb_define_class_under(mSword, "PLAINHTML", ((swig_class *) SWIGTYPE_p_sword__SWFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__PLAINHTML, (void *) &SwigClassPLAINHTML);
  rb_define_alloc_func(SwigClassPLAINHTML.klass, _wrap_PLAINHTML_allocate);
  rb_define_method(SwigClassPLAINHTML.klass, "initialize", VALUEFUNC(_wrap_new_PLAINHTML), -1);
  rb_define_method(SwigClassPLAINHTML.klass, "processText", VALUEFUNC(_wrap_PLAINHTML_processText), -1);
  SwigClassPLAINHTML.mark = 0;
  SwigClassPLAINHTML.destroy = (void (*)(void *)) free_sword_PLAINHTML;
  SwigClassPLAINHTML.trackObjects = 0;
  
  SwigClassThMLHTMLHREF.klass = rb_define_class_under(mSword, "ThMLHTMLHREF", ((swig_class *) SWIGTYPE_p_sword__SWBasicFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__ThMLHTMLHREF, (void *) &SwigClassThMLHTMLHREF);
  rb_define_alloc_func(SwigClassThMLHTMLHREF.klass, _wrap_ThMLHTMLHREF_allocate);
  rb_define_method(SwigClassThMLHTMLHREF.klass, "initialize", VALUEFUNC(_wrap_new_ThMLHTMLHREF), -1);
  rb_define_method(SwigClassThMLHTMLHREF.klass, "getImagePrefix", VALUEFUNC(_wrap_ThMLHTMLHREF_getImagePrefix), -1);
  rb_define_method(SwigClassThMLHTMLHREF.klass, "setImagePrefix", VALUEFUNC(_wrap_ThMLHTMLHREF_setImagePrefix), -1);
  SwigClassThMLHTMLHREF.mark = 0;
  SwigClassThMLHTMLHREF.destroy = (void (*)(void *)) free_sword_ThMLHTMLHREF;
  SwigClassThMLHTMLHREF.trackObjects = 0;
  
  SwigClassGBFHTMLHREF.klass = rb_define_class_under(mSword, "GBFHTMLHREF", ((swig_class *) SWIGTYPE_p_sword__SWBasicFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__GBFHTMLHREF, (void *) &SwigClassGBFHTMLHREF);
  rb_define_alloc_func(SwigClassGBFHTMLHREF.klass, _wrap_GBFHTMLHREF_allocate);
  rb_define_method(SwigClassGBFHTMLHREF.klass, "initialize", VALUEFUNC(_wrap_new_GBFHTMLHREF), -1);
  SwigClassGBFHTMLHREF.mark = 0;
  SwigClassGBFHTMLHREF.destroy = (void (*)(void *)) free_sword_GBFHTMLHREF;
  SwigClassGBFHTMLHREF.trackObjects = 0;
  
  SwigClassUTF8HTML.klass = rb_define_class_under(mSword, "UTF8HTML", ((swig_class *) SWIGTYPE_p_sword__SWFilter->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_sword__UTF8HTML, (void *) &SwigClassUTF8HTML);
  rb_define_alloc_func(SwigClassUTF8HTML.klass, _wrap_UTF8HTML_allocate);
  rb_define_method(SwigClassUTF8HTML.klass, "initialize", VALUEFUNC(_wrap_new_UTF8HTML), -1);
  rb_define_method(SwigClassUTF8HTML.klass, "processText", VALUEFUNC(_wrap_UTF8HTML_processText), -1);
  SwigClassUTF8HTML.mark = 0;
  SwigClassUTF8HTML.destroy = (void (*)(void *)) free_sword_UTF8HTML;
  SwigClassUTF8HTML.trackObjects = 0;
  
  SwigClassMarkupCallback.klass = rb_define_class_under(mSword, "MarkupCallback", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_MarkupCallback, (void *) &SwigClassMarkupCallback);
  rb_define_alloc_func(SwigClassMarkupCallback.klass, _wrap_MarkupCallback_allocate);
  rb_define_method(SwigClassMarkupCallback.klass, "initialize", VALUEFUNC(_wrap_new_MarkupCallback), -1);
  rb_define_method(SwigClassMarkupCallback.klass, "run", VALUEFUNC(_wrap_MarkupCallback_run), -1);
  SwigClassMarkupCallback.mark = 0;
  SwigClassMarkupCallback.destroy = (void (*)(void *)) free_MarkupCallback;
  SwigClassMarkupCallback.trackObjects = 0;
  
  SwigClassMyMarkup.klass = rb_define_class_under(mSword, "MyMarkup", ((swig_class *) SWIGTYPE_p_sword__MarkupFilterMgr->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_MyMarkup, (void *) &SwigClassMyMarkup);
  rb_define_alloc_func(SwigClassMyMarkup.klass, _wrap_MyMarkup_allocate);
  rb_define_method(SwigClassMyMarkup.klass, "initialize", VALUEFUNC(_wrap_new_MyMarkup), -1);
  rb_define_method(SwigClassMyMarkup.klass, "delCallback", VALUEFUNC(_wrap_MyMarkup_delCallback), -1);
  rb_define_method(SwigClassMyMarkup.klass, "setCallback", VALUEFUNC(_wrap_MyMarkup_setCallback), -1);
  rb_define_method(SwigClassMyMarkup.klass, "call", VALUEFUNC(_wrap_MyMarkup_call), -1);
  SwigClassMyMarkup.mark = 0;
  SwigClassMyMarkup.destroy = (void (*)(void *)) free_MyMarkup;
  SwigClassMyMarkup.trackObjects = 0;
  rb_define_const(mSword, "FAILED", SWIG_From_int(static_cast< int >(0)));
  rb_define_const(mSword, "SUCCEEDED", SWIG_From_int(static_cast< int >(1)));
  rb_define_const(mSword, "INHERITED", SWIG_From_int(static_cast< int >(2)));
  
  SwigClassReturnSuccess.klass = rb_define_class_under(mSword, "ReturnSuccess", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_ReturnSuccess, (void *) &SwigClassReturnSuccess);
  rb_define_alloc_func(SwigClassReturnSuccess.klass, _wrap_ReturnSuccess_allocate);
  rb_define_method(SwigClassReturnSuccess.klass, "initialize", VALUEFUNC(_wrap_new_ReturnSuccess), -1);
  rb_define_method(SwigClassReturnSuccess.klass, "data=", VALUEFUNC(_wrap_ReturnSuccess_data_set), -1);
  rb_define_method(SwigClassReturnSuccess.klass, "data", VALUEFUNC(_wrap_ReturnSuccess_data_get), -1);
  rb_define_method(SwigClassReturnSuccess.klass, "success=", VALUEFUNC(_wrap_ReturnSuccess_success_set), -1);
  rb_define_method(SwigClassReturnSuccess.klass, "success", VALUEFUNC(_wrap_ReturnSuccess_success_get), -1);
  SwigClassReturnSuccess.mark = 0;
  SwigClassReturnSuccess.destroy = (void (*)(void *)) free_ReturnSuccess;
  SwigClassReturnSuccess.trackObjects = 0;
  
  SwigClassRenderCallback.klass = rb_define_class_under(mSword, "RenderCallback", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_RenderCallback, (void *) &SwigClassRenderCallback);
  rb_define_alloc_func(SwigClassRenderCallback.klass, _wrap_RenderCallback_allocate);
  rb_define_method(SwigClassRenderCallback.klass, "initialize", VALUEFUNC(_wrap_new_RenderCallback), -1);
  rb_define_method(SwigClassRenderCallback.klass, "run", VALUEFUNC(_wrap_RenderCallback_run), -1);
  SwigClassRenderCallback.mark = 0;
  SwigClassRenderCallback.destroy = (void (*)(void *)) free_RenderCallback;
  SwigClassRenderCallback.trackObjects = 0;
  
  SwigClassPyOSISHTMLHREF.klass = rb_define_class_under(mSword, "PyOSISHTMLHREF", ((swig_class *) SWIGTYPE_p_sword__OSISHTMLHREF->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_PyOSISHTMLHREF, (void *) &SwigClassPyOSISHTMLHREF);
  rb_define_alloc_func(SwigClassPyOSISHTMLHREF.klass, _wrap_PyOSISHTMLHREF_allocate);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "initialize", VALUEFUNC(_wrap_new_PyOSISHTMLHREF), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "removeTokenSubstitute", VALUEFUNC(_wrap_PyOSISHTMLHREF_removeTokenSubstitute), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "addTokenSubstitute", VALUEFUNC(_wrap_PyOSISHTMLHREF_addTokenSubstitute), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "addAllowedEscapeString", VALUEFUNC(_wrap_PyOSISHTMLHREF_addAllowedEscapeString), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "removeAllowedEscapeString", VALUEFUNC(_wrap_PyOSISHTMLHREF_removeAllowedEscapeString), -1);
  rb_define_singleton_method(SwigClassPyOSISHTMLHREF.klass, "getData", VALUEFUNC(_wrap_PyOSISHTMLHREF_getData), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "delCallback", VALUEFUNC(_wrap_PyOSISHTMLHREF_delCallback), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "setCallback", VALUEFUNC(_wrap_PyOSISHTMLHREF_setCallback), -1);
  rb_define_method(SwigClassPyOSISHTMLHREF.klass, "call", VALUEFUNC(_wrap_PyOSISHTMLHREF_call), -1);
  SwigClassPyOSISHTMLHREF.mark = 0;
  SwigClassPyOSISHTMLHREF.destroy = (void (*)(void *)) free_PyOSISHTMLHREF;
  SwigClassPyOSISHTMLHREF.trackObjects = 0;
  
  SwigClassPyThMLHTMLHREF.klass = rb_define_class_under(mSword, "PyThMLHTMLHREF", ((swig_class *) SWIGTYPE_p_sword__ThMLHTMLHREF->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_PyThMLHTMLHREF, (void *) &SwigClassPyThMLHTMLHREF);
  rb_define_alloc_func(SwigClassPyThMLHTMLHREF.klass, _wrap_PyThMLHTMLHREF_allocate);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "initialize", VALUEFUNC(_wrap_new_PyThMLHTMLHREF), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "removeTokenSubstitute", VALUEFUNC(_wrap_PyThMLHTMLHREF_removeTokenSubstitute), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "addTokenSubstitute", VALUEFUNC(_wrap_PyThMLHTMLHREF_addTokenSubstitute), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "addAllowedEscapeString", VALUEFUNC(_wrap_PyThMLHTMLHREF_addAllowedEscapeString), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "removeAllowedEscapeString", VALUEFUNC(_wrap_PyThMLHTMLHREF_removeAllowedEscapeString), -1);
  rb_define_singleton_method(SwigClassPyThMLHTMLHREF.klass, "getData", VALUEFUNC(_wrap_PyThMLHTMLHREF_getData), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "delCallback", VALUEFUNC(_wrap_PyThMLHTMLHREF_delCallback), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "setCallback", VALUEFUNC(_wrap_PyThMLHTMLHREF_setCallback), -1);
  rb_define_method(SwigClassPyThMLHTMLHREF.klass, "call", VALUEFUNC(_wrap_PyThMLHTMLHREF_call), -1);
  SwigClassPyThMLHTMLHREF.mark = 0;
  SwigClassPyThMLHTMLHREF.destroy = (void (*)(void *)) free_PyThMLHTMLHREF;
  SwigClassPyThMLHTMLHREF.trackObjects = 0;
  
  SwigClassOSISData.klass = rb_define_class_under(mSword, "OSISData", ((swig_class *) SWIGTYPE_p_sword__BasicFilterUserData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OSISData, (void *) &SwigClassOSISData);
  rb_undef_alloc_func(SwigClassOSISData.klass);
  rb_define_method(SwigClassOSISData.klass, "osisQToTick=", VALUEFUNC(_wrap_OSISData_osisQToTick_set), -1);
  rb_define_method(SwigClassOSISData.klass, "osisQToTick", VALUEFUNC(_wrap_OSISData_osisQToTick_get), -1);
  rb_define_method(SwigClassOSISData.klass, "inBold=", VALUEFUNC(_wrap_OSISData_inBold_set), -1);
  rb_define_method(SwigClassOSISData.klass, "inBold", VALUEFUNC(_wrap_OSISData_inBold_get), -1);
  rb_define_method(SwigClassOSISData.klass, "inXRefNote=", VALUEFUNC(_wrap_OSISData_inXRefNote_set), -1);
  rb_define_method(SwigClassOSISData.klass, "inXRefNote", VALUEFUNC(_wrap_OSISData_inXRefNote_get), -1);
  rb_define_method(SwigClassOSISData.klass, "BiblicalText=", VALUEFUNC(_wrap_OSISData_BiblicalText_set), -1);
  rb_define_method(SwigClassOSISData.klass, "BiblicalText", VALUEFUNC(_wrap_OSISData_BiblicalText_get), -1);
  rb_define_method(SwigClassOSISData.klass, "suspendLevel=", VALUEFUNC(_wrap_OSISData_suspendLevel_set), -1);
  rb_define_method(SwigClassOSISData.klass, "suspendLevel", VALUEFUNC(_wrap_OSISData_suspendLevel_get), -1);
  rb_define_method(SwigClassOSISData.klass, "wordsOfChristStart=", VALUEFUNC(_wrap_OSISData_wordsOfChristStart_set), -1);
  rb_define_method(SwigClassOSISData.klass, "wordsOfChristStart", VALUEFUNC(_wrap_OSISData_wordsOfChristStart_get), -1);
  rb_define_method(SwigClassOSISData.klass, "wordsOfChristEnd=", VALUEFUNC(_wrap_OSISData_wordsOfChristEnd_set), -1);
  rb_define_method(SwigClassOSISData.klass, "wordsOfChristEnd", VALUEFUNC(_wrap_OSISData_wordsOfChristEnd_get), -1);
  rb_define_method(SwigClassOSISData.klass, "lastTransChange=", VALUEFUNC(_wrap_OSISData_lastTransChange_set), -1);
  rb_define_method(SwigClassOSISData.klass, "lastTransChange", VALUEFUNC(_wrap_OSISData_lastTransChange_get), -1);
  rb_define_method(SwigClassOSISData.klass, "w=", VALUEFUNC(_wrap_OSISData_w_set), -1);
  rb_define_method(SwigClassOSISData.klass, "w", VALUEFUNC(_wrap_OSISData_w_get), -1);
  rb_define_method(SwigClassOSISData.klass, "fn=", VALUEFUNC(_wrap_OSISData_fn_set), -1);
  rb_define_method(SwigClassOSISData.klass, "fn", VALUEFUNC(_wrap_OSISData_fn_get), -1);
  rb_define_method(SwigClassOSISData.klass, "version=", VALUEFUNC(_wrap_OSISData_version_set), -1);
  rb_define_method(SwigClassOSISData.klass, "version", VALUEFUNC(_wrap_OSISData_version_get), -1);
  SwigClassOSISData.mark = 0;
  SwigClassOSISData.destroy = (void (*)(void *)) free_OSISData;
  SwigClassOSISData.trackObjects = 0;
  
  SwigClassThMLData.klass = rb_define_class_under(mSword, "ThMLData", ((swig_class *) SWIGTYPE_p_sword__BasicFilterUserData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_ThMLData, (void *) &SwigClassThMLData);
  rb_undef_alloc_func(SwigClassThMLData.klass);
  rb_define_method(SwigClassThMLData.klass, "inscriptRef=", VALUEFUNC(_wrap_ThMLData_inscriptRef_set), -1);
  rb_define_method(SwigClassThMLData.klass, "inscriptRef", VALUEFUNC(_wrap_ThMLData_inscriptRef_get), -1);
  rb_define_method(SwigClassThMLData.klass, "SecHead=", VALUEFUNC(_wrap_ThMLData_SecHead_set), -1);
  rb_define_method(SwigClassThMLData.klass, "SecHead", VALUEFUNC(_wrap_ThMLData_SecHead_get), -1);
  rb_define_method(SwigClassThMLData.klass, "BiblicalText=", VALUEFUNC(_wrap_ThMLData_BiblicalText_set), -1);
  rb_define_method(SwigClassThMLData.klass, "BiblicalText", VALUEFUNC(_wrap_ThMLData_BiblicalText_get), -1);
  rb_define_method(SwigClassThMLData.klass, "version=", VALUEFUNC(_wrap_ThMLData_version_set), -1);
  rb_define_method(SwigClassThMLData.klass, "version", VALUEFUNC(_wrap_ThMLData_version_get), -1);
  rb_define_method(SwigClassThMLData.klass, "startTag=", VALUEFUNC(_wrap_ThMLData_startTag_set), -1);
  rb_define_method(SwigClassThMLData.klass, "startTag", VALUEFUNC(_wrap_ThMLData_startTag_get), -1);
  SwigClassThMLData.mark = 0;
  SwigClassThMLData.destroy = (void (*)(void *)) free_ThMLData;
  SwigClassThMLData.trackObjects = 0;
  
  SwigClassSWSearcher.klass = rb_define_class_under(mSword, "SWSearcher", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_SWSearcher, (void *) &SwigClassSWSearcher);
  rb_define_alloc_func(SwigClassSWSearcher.klass, _wrap_SWSearcher_allocate);
  rb_define_method(SwigClassSWSearcher.klass, "initialize", VALUEFUNC(_wrap_new_SWSearcher), -1);
  rb_define_method(SwigClassSWSearcher.klass, "mod=", VALUEFUNC(_wrap_SWSearcher_mod_set), -1);
  rb_define_method(SwigClassSWSearcher.klass, "mod", VALUEFUNC(_wrap_SWSearcher_mod_get), -1);
  rb_define_method(SwigClassSWSearcher.klass, "percent=", VALUEFUNC(_wrap_SWSearcher_percent_set), -1);
  rb_define_method(SwigClassSWSearcher.klass, "percent", VALUEFUNC(_wrap_SWSearcher_percent_get), -1);
  rb_define_singleton_method(SwigClassSWSearcher.klass, "Callback", VALUEFUNC(_wrap_SWSearcher_Callback), -1);
  rb_define_method(SwigClassSWSearcher.klass, "PercentFunction", VALUEFUNC(_wrap_SWSearcher_PercentFunction), -1);
  rb_define_method(SwigClassSWSearcher.klass, "GetPercent", VALUEFUNC(_wrap_SWSearcher_GetPercent), -1);
  rb_define_method(SwigClassSWSearcher.klass, "isSearchSupported", VALUEFUNC(_wrap_SWSearcher_isSearchSupported), -1);
  rb_define_method(SwigClassSWSearcher.klass, "doSearch", VALUEFUNC(_wrap_SWSearcher_doSearch), -1);
  rb_define_method(SwigClassSWSearcher.klass, "TerminateSearch", VALUEFUNC(_wrap_SWSearcher_TerminateSearch), -1);
  SwigClassSWSearcher.mark = 0;
  SwigClassSWSearcher.destroy = (void (*)(void *)) free_SWSearcher;
  SwigClassSWSearcher.trackObjects = 0;
  
  SwigClassSWLog.klass = rb_define_class_under(mSword, "SWLog", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__SWLog, (void *) &SwigClassSWLog);
  rb_define_alloc_func(SwigClassSWLog.klass, _wrap_SWLog_allocate);
  rb_define_method(SwigClassSWLog.klass, "initialize", VALUEFUNC(_wrap_new_SWLog), -1);
  rb_define_singleton_method(SwigClassSWLog.klass, "LOG_ERROR", VALUEFUNC(_wrap_SWLog_LOG_ERROR_get), 0);
  rb_define_singleton_method(SwigClassSWLog.klass, "LOG_WARN", VALUEFUNC(_wrap_SWLog_LOG_WARN_get), 0);
  rb_define_singleton_method(SwigClassSWLog.klass, "LOG_INFO", VALUEFUNC(_wrap_SWLog_LOG_INFO_get), 0);
  rb_define_singleton_method(SwigClassSWLog.klass, "LOG_TIMEDINFO", VALUEFUNC(_wrap_SWLog_LOG_TIMEDINFO_get), 0);
  rb_define_singleton_method(SwigClassSWLog.klass, "LOG_DEBUG", VALUEFUNC(_wrap_SWLog_LOG_DEBUG_get), 0);
  rb_define_singleton_method(SwigClassSWLog.klass, "getSystemLog", VALUEFUNC(_wrap_SWLog_getSystemLog), -1);
  rb_define_singleton_method(SwigClassSWLog.klass, "setSystemLog", VALUEFUNC(_wrap_SWLog_setSystemLog), -1);
  rb_define_method(SwigClassSWLog.klass, "setLogLevel", VALUEFUNC(_wrap_SWLog_setLogLevel), -1);
  rb_define_method(SwigClassSWLog.klass, "getLogLevel", VALUEFUNC(_wrap_SWLog_getLogLevel), -1);
  rb_define_method(SwigClassSWLog.klass, "logWarning", VALUEFUNC(_wrap_SWLog_logWarning), -1);
  rb_define_method(SwigClassSWLog.klass, "logError", VALUEFUNC(_wrap_SWLog_logError), -1);
  rb_define_method(SwigClassSWLog.klass, "logInformation", VALUEFUNC(_wrap_SWLog_logInformation), -1);
  rb_define_method(SwigClassSWLog.klass, "logTimedInformation", VALUEFUNC(_wrap_SWLog_logTimedInformation), -1);
  rb_define_method(SwigClassSWLog.klass, "logDebug", VALUEFUNC(_wrap_SWLog_logDebug), -1);
  rb_define_method(SwigClassSWLog.klass, "logMessage", VALUEFUNC(_wrap_SWLog_logMessage), -1);
  SwigClassSWLog.mark = 0;
  SwigClassSWLog.destroy = (void (*)(void *)) free_sword_SWLog;
  SwigClassSWLog.trackObjects = 0;
  
  SwigClassStatusReporter.klass = rb_define_class_under(mSword, "StatusReporter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__StatusReporter, (void *) &SwigClassStatusReporter);
  rb_define_alloc_func(SwigClassStatusReporter.klass, _wrap_StatusReporter_allocate);
  rb_define_method(SwigClassStatusReporter.klass, "initialize", VALUEFUNC(_wrap_new_StatusReporter), -1);
  rb_define_method(SwigClassStatusReporter.klass, "preStatus", VALUEFUNC(_wrap_StatusReporter_preStatus), -1);
  rb_define_method(SwigClassStatusReporter.klass, "statusUpdate", VALUEFUNC(_wrap_StatusReporter_statusUpdate), -1);
  SwigClassStatusReporter.mark = 0;
  SwigClassStatusReporter.destroy = (void (*)(void *)) free_sword_StatusReporter;
  SwigClassStatusReporter.trackObjects = 0;
  
  SwigClassFTPTransport.klass = rb_define_class_under(mSword, "FTPTransport", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__FTPTransport, (void *) &SwigClassFTPTransport);
  rb_define_alloc_func(SwigClassFTPTransport.klass, _wrap_FTPTransport_allocate);
  rb_define_method(SwigClassFTPTransport.klass, "initialize", VALUEFUNC(_wrap_new_FTPTransport), -1);
  rb_define_method(SwigClassFTPTransport.klass, "getURL", VALUEFUNC(_wrap_FTPTransport_getURL), -1);
  rb_define_method(SwigClassFTPTransport.klass, "copyDirectory", VALUEFUNC(_wrap_FTPTransport_copyDirectory), -1);
  rb_define_method(SwigClassFTPTransport.klass, "getDirList", VALUEFUNC(_wrap_FTPTransport_getDirList), -1);
  rb_define_method(SwigClassFTPTransport.klass, "setPassive", VALUEFUNC(_wrap_FTPTransport_setPassive), -1);
  rb_define_method(SwigClassFTPTransport.klass, "setUser", VALUEFUNC(_wrap_FTPTransport_setUser), -1);
  rb_define_method(SwigClassFTPTransport.klass, "setPasswd", VALUEFUNC(_wrap_FTPTransport_setPasswd), -1);
  rb_define_method(SwigClassFTPTransport.klass, "terminate", VALUEFUNC(_wrap_FTPTransport_terminate), -1);
  SwigClassFTPTransport.mark = 0;
  SwigClassFTPTransport.destroy = (void (*)(void *)) free_sword_FTPTransport;
  SwigClassFTPTransport.trackObjects = 0;
  
  SwigClassInstallSource.klass = rb_define_class_under(mSword, "InstallSource", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__InstallSource, (void *) &SwigClassInstallSource);
  rb_define_alloc_func(SwigClassInstallSource.klass, _wrap_InstallSource_allocate);
  rb_define_method(SwigClassInstallSource.klass, "initialize", VALUEFUNC(_wrap_new_InstallSource), -1);
  rb_define_method(SwigClassInstallSource.klass, "getConfEnt", VALUEFUNC(_wrap_InstallSource_getConfEnt), -1);
  rb_define_method(SwigClassInstallSource.klass, "caption=", VALUEFUNC(_wrap_InstallSource_caption_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "caption", VALUEFUNC(_wrap_InstallSource_caption_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "source=", VALUEFUNC(_wrap_InstallSource_source_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "source", VALUEFUNC(_wrap_InstallSource_source_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "directory=", VALUEFUNC(_wrap_InstallSource_directory_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "directory", VALUEFUNC(_wrap_InstallSource_directory_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "u=", VALUEFUNC(_wrap_InstallSource_u_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "u", VALUEFUNC(_wrap_InstallSource_u_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "p=", VALUEFUNC(_wrap_InstallSource_p_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "p", VALUEFUNC(_wrap_InstallSource_p_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "uid=", VALUEFUNC(_wrap_InstallSource_uid_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "uid", VALUEFUNC(_wrap_InstallSource_uid_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "type=", VALUEFUNC(_wrap_InstallSource_type_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "type", VALUEFUNC(_wrap_InstallSource_type_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "localShadow=", VALUEFUNC(_wrap_InstallSource_localShadow_set), -1);
  rb_define_method(SwigClassInstallSource.klass, "localShadow", VALUEFUNC(_wrap_InstallSource_localShadow_get), -1);
  rb_define_method(SwigClassInstallSource.klass, "getMgr", VALUEFUNC(_wrap_InstallSource_getMgr), -1);
  rb_define_method(SwigClassInstallSource.klass, "flush", VALUEFUNC(_wrap_InstallSource_flush), -1);
  SwigClassInstallSource.mark = 0;
  SwigClassInstallSource.destroy = (void (*)(void *)) free_sword_InstallSource;
  SwigClassInstallSource.trackObjects = 0;
  
  SwigClassInstallMgr.klass = rb_define_class_under(mSword, "InstallMgr", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_sword__InstallMgr, (void *) &SwigClassInstallMgr);
  rb_define_alloc_func(SwigClassInstallMgr.klass, _wrap_InstallMgr_allocate);
  rb_define_method(SwigClassInstallMgr.klass, "initialize", VALUEFUNC(_wrap_new_InstallMgr), -1);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_OLDER", VALUEFUNC(_wrap_InstallMgr_MODSTAT_OLDER_get), 0);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_SAMEVERSION", VALUEFUNC(_wrap_InstallMgr_MODSTAT_SAMEVERSION_get), 0);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_UPDATED", VALUEFUNC(_wrap_InstallMgr_MODSTAT_UPDATED_get), 0);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_NEW", VALUEFUNC(_wrap_InstallMgr_MODSTAT_NEW_get), 0);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_CIPHERED", VALUEFUNC(_wrap_InstallMgr_MODSTAT_CIPHERED_get), 0);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "MODSTAT_CIPHERKEYPRESENT", VALUEFUNC(_wrap_InstallMgr_MODSTAT_CIPHERKEYPRESENT_get), 0);
  rb_define_method(SwigClassInstallMgr.klass, "installConf=", VALUEFUNC(_wrap_InstallMgr_installConf_set), -1);
  rb_define_method(SwigClassInstallMgr.klass, "installConf", VALUEFUNC(_wrap_InstallMgr_installConf_get), -1);
  rb_define_method(SwigClassInstallMgr.klass, "sources=", VALUEFUNC(_wrap_InstallMgr_sources_set), -1);
  rb_define_method(SwigClassInstallMgr.klass, "sources", VALUEFUNC(_wrap_InstallMgr_sources_get), -1);
  rb_define_method(SwigClassInstallMgr.klass, "readInstallConf", VALUEFUNC(_wrap_InstallMgr_readInstallConf), -1);
  rb_define_method(SwigClassInstallMgr.klass, "saveInstallConf", VALUEFUNC(_wrap_InstallMgr_saveInstallConf), -1);
  rb_define_method(SwigClassInstallMgr.klass, "clearSources", VALUEFUNC(_wrap_InstallMgr_clearSources), -1);
  rb_define_method(SwigClassInstallMgr.klass, "removeModule", VALUEFUNC(_wrap_InstallMgr_removeModule), -1);
  rb_define_method(SwigClassInstallMgr.klass, "ftpCopy", VALUEFUNC(_wrap_InstallMgr_ftpCopy), -1);
  rb_define_method(SwigClassInstallMgr.klass, "installModule", VALUEFUNC(_wrap_InstallMgr_installModule), -1);
  rb_define_method(SwigClassInstallMgr.klass, "refreshRemoteSource", VALUEFUNC(_wrap_InstallMgr_refreshRemoteSource), -1);
  rb_define_method(SwigClassInstallMgr.klass, "refreshRemoteSourceConfiguration", VALUEFUNC(_wrap_InstallMgr_refreshRemoteSourceConfiguration), -1);
  rb_define_method(SwigClassInstallMgr.klass, "isUserDisclaimerConfirmed", VALUEFUNC(_wrap_InstallMgr_isUserDisclaimerConfirmed), -1);
  rb_define_method(SwigClassInstallMgr.klass, "setUserDisclaimerConfirmed", VALUEFUNC(_wrap_InstallMgr_setUserDisclaimerConfirmed), -1);
  rb_define_method(SwigClassInstallMgr.klass, "getCipherCode", VALUEFUNC(_wrap_InstallMgr_getCipherCode), -1);
  rb_define_method(SwigClassInstallMgr.klass, "setFTPPassive", VALUEFUNC(_wrap_InstallMgr_setFTPPassive), -1);
  rb_define_method(SwigClassInstallMgr.klass, "isFTPPassive", VALUEFUNC(_wrap_InstallMgr_isFTPPassive), -1);
  rb_define_method(SwigClassInstallMgr.klass, "terminate", VALUEFUNC(_wrap_InstallMgr_terminate), -1);
  rb_define_singleton_method(SwigClassInstallMgr.klass, "getModuleStatus", VALUEFUNC(_wrap_InstallMgr_getModuleStatus), -1);
  rb_define_method(SwigClassInstallMgr.klass, "isDefaultModule", VALUEFUNC(_wrap_InstallMgr_isDefaultModule), -1);
  SwigClassInstallMgr.mark = 0;
  SwigClassInstallMgr.destroy = (void (*)(void *)) free_sword_InstallMgr;
  SwigClassInstallMgr.trackObjects = 0;
}

